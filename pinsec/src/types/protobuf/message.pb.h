// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "dba.pb.h"
#include "config.pb.h"
// @@protoc_insertion_point(includes)
class message_bp_reached;
class message_bp_reachedDefaultTypeInternal;
extern message_bp_reachedDefaultTypeInternal _message_bp_reached_default_instance_;
class message_decode_instr;
class message_decode_instrDefaultTypeInternal;
extern message_decode_instrDefaultTypeInternal _message_decode_instr_default_instance_;
class message_decode_instr_instr_entry;
class message_decode_instr_instr_entryDefaultTypeInternal;
extern message_decode_instr_instr_entryDefaultTypeInternal _message_decode_instr_instr_entry_default_instance_;
class message_decode_instr_reply;
class message_decode_instr_replyDefaultTypeInternal;
extern message_decode_instr_replyDefaultTypeInternal _message_decode_instr_reply_default_instance_;
class message_decode_instr_reply_instr_entry;
class message_decode_instr_reply_instr_entryDefaultTypeInternal;
extern message_decode_instr_reply_instr_entryDefaultTypeInternal _message_decode_instr_reply_instr_entry_default_instance_;
class message_infos;
class message_infosDefaultTypeInternal;
extern message_infosDefaultTypeInternal _message_infos_default_instance_;
class message_output;
class message_outputDefaultTypeInternal;
extern message_outputDefaultTypeInternal _message_output_default_instance_;
class message_patch;
class message_patchDefaultTypeInternal;
extern message_patchDefaultTypeInternal _message_patch_default_instance_;
class message_start_exec;
class message_start_execDefaultTypeInternal;
extern message_start_execDefaultTypeInternal _message_start_exec_default_instance_;
class message_start_symb_exec;
class message_start_symb_execDefaultTypeInternal;
extern message_start_symb_execDefaultTypeInternal _message_start_symb_exec_default_instance_;
namespace common {
class indirect_register_t;
class indirect_register_tDefaultTypeInternal;
extern indirect_register_tDefaultTypeInternal _indirect_register_t_default_instance_;
class memory_pol;
class memory_polDefaultTypeInternal;
extern memory_polDefaultTypeInternal _memory_pol_default_instance_;
class memory_t;
class memory_tDefaultTypeInternal;
extern memory_tDefaultTypeInternal _memory_t_default_instance_;
class register_t;
class register_tDefaultTypeInternal;
extern register_tDefaultTypeInternal _register_t_default_instance_;
class register_value_t;
class register_value_tDefaultTypeInternal;
extern register_value_tDefaultTypeInternal _register_value_t_default_instance_;
}  // namespace common
namespace configuration {
class call_name_t;
class call_name_tDefaultTypeInternal;
extern call_name_tDefaultTypeInternal _call_name_t_default_instance_;
class configuration;
class configurationDefaultTypeInternal;
extern configurationDefaultTypeInternal _configuration_default_instance_;
class input_t;
class input_tDefaultTypeInternal;
extern input_tDefaultTypeInternal _input_t_default_instance_;
}  // namespace configuration
namespace dba {
class bitvector;
class bitvectorDefaultTypeInternal;
extern bitvectorDefaultTypeInternal _bitvector_default_instance_;
class codeaddress;
class codeaddressDefaultTypeInternal;
extern codeaddressDefaultTypeInternal _codeaddress_default_instance_;
class dbaLhs;
class dbaLhsDefaultTypeInternal;
extern dbaLhsDefaultTypeInternal _dbaLhs_default_instance_;
class dba_list;
class dba_listDefaultTypeInternal;
extern dba_listDefaultTypeInternal _dba_list_default_instance_;
class dbacodeaddress;
class dbacodeaddressDefaultTypeInternal;
extern dbacodeaddressDefaultTypeInternal _dbacodeaddress_default_instance_;
class dbacond;
class dbacondDefaultTypeInternal;
extern dbacondDefaultTypeInternal _dbacond_default_instance_;
class dbaexpr;
class dbaexprDefaultTypeInternal;
extern dbaexprDefaultTypeInternal _dbaexpr_default_instance_;
class dbainstr;
class dbainstrDefaultTypeInternal;
extern dbainstrDefaultTypeInternal _dbainstr_default_instance_;
class dbastopstate;
class dbastopstateDefaultTypeInternal;
extern dbastopstateDefaultTypeInternal _dbastopstate_default_instance_;
class dbatag;
class dbatagDefaultTypeInternal;
extern dbatagDefaultTypeInternal _dbatag_default_instance_;
}  // namespace dba

namespace protobuf_message_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_message_2eproto

enum message_decode_instr_bin_kind {
  message_decode_instr_bin_kind_HEXA = 1,
  message_decode_instr_bin_kind_BIN = 2
};
bool message_decode_instr_bin_kind_IsValid(int value);
const message_decode_instr_bin_kind message_decode_instr_bin_kind_bin_kind_MIN = message_decode_instr_bin_kind_HEXA;
const message_decode_instr_bin_kind message_decode_instr_bin_kind_bin_kind_MAX = message_decode_instr_bin_kind_BIN;
const int message_decode_instr_bin_kind_bin_kind_ARRAYSIZE = message_decode_instr_bin_kind_bin_kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* message_decode_instr_bin_kind_descriptor();
inline const ::std::string& message_decode_instr_bin_kind_Name(message_decode_instr_bin_kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    message_decode_instr_bin_kind_descriptor(), value);
}
inline bool message_decode_instr_bin_kind_Parse(
    const ::std::string& name, message_decode_instr_bin_kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<message_decode_instr_bin_kind>(
    message_decode_instr_bin_kind_descriptor(), name, value);
}
enum message_start_symb_exec_trace_kind {
  message_start_symb_exec_trace_kind_FILE = 1,
  message_start_symb_exec_trace_kind_STREAM = 2
};
bool message_start_symb_exec_trace_kind_IsValid(int value);
const message_start_symb_exec_trace_kind message_start_symb_exec_trace_kind_trace_kind_MIN = message_start_symb_exec_trace_kind_FILE;
const message_start_symb_exec_trace_kind message_start_symb_exec_trace_kind_trace_kind_MAX = message_start_symb_exec_trace_kind_STREAM;
const int message_start_symb_exec_trace_kind_trace_kind_ARRAYSIZE = message_start_symb_exec_trace_kind_trace_kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* message_start_symb_exec_trace_kind_descriptor();
inline const ::std::string& message_start_symb_exec_trace_kind_Name(message_start_symb_exec_trace_kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    message_start_symb_exec_trace_kind_descriptor(), value);
}
inline bool message_start_symb_exec_trace_kind_Parse(
    const ::std::string& name, message_start_symb_exec_trace_kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<message_start_symb_exec_trace_kind>(
    message_start_symb_exec_trace_kind_descriptor(), name, value);
}
enum message_output_output_kind {
  message_output_output_kind_SUCCESS = 1,
  message_output_output_kind_RESULT = 2,
  message_output_output_kind_DEBUG = 3,
  message_output_output_kind_WARNING = 4,
  message_output_output_kind_ERROR = 5,
  message_output_output_kind_FAILURE = 6
};
bool message_output_output_kind_IsValid(int value);
const message_output_output_kind message_output_output_kind_output_kind_MIN = message_output_output_kind_SUCCESS;
const message_output_output_kind message_output_output_kind_output_kind_MAX = message_output_output_kind_FAILURE;
const int message_output_output_kind_output_kind_ARRAYSIZE = message_output_output_kind_output_kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* message_output_output_kind_descriptor();
inline const ::std::string& message_output_output_kind_Name(message_output_output_kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    message_output_output_kind_descriptor(), value);
}
inline bool message_output_output_kind_Parse(
    const ::std::string& name, message_output_output_kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<message_output_output_kind>(
    message_output_output_kind_descriptor(), name, value);
}
// ===================================================================

class message_start_exec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message_start_exec) */ {
 public:
  message_start_exec();
  virtual ~message_start_exec();

  message_start_exec(const message_start_exec& from);

  inline message_start_exec& operator=(const message_start_exec& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const message_start_exec& default_instance();

  static inline const message_start_exec* internal_default_instance() {
    return reinterpret_cast<const message_start_exec*>(
               &_message_start_exec_default_instance_);
  }

  void Swap(message_start_exec* other);

  // implements Message ----------------------------------------------

  inline message_start_exec* New() const PROTOBUF_FINAL { return New(NULL); }

  message_start_exec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const message_start_exec& from);
  void MergeFrom(const message_start_exec& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(message_start_exec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 breakpoints = 4;
  int breakpoints_size() const;
  void clear_breakpoints();
  static const int kBreakpointsFieldNumber = 4;
  ::google::protobuf::uint64 breakpoints(int index) const;
  void set_breakpoints(int index, ::google::protobuf::uint64 value);
  void add_breakpoints(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      breakpoints() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_breakpoints();

  // repeated .configuration.input_t inputs = 5;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 5;
  const ::configuration::input_t& inputs(int index) const;
  ::configuration::input_t* mutable_inputs(int index);
  ::configuration::input_t* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::configuration::input_t >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::configuration::input_t >&
      inputs() const;

  // repeated uint64 skips = 6;
  int skips_size() const;
  void clear_skips();
  static const int kSkipsFieldNumber = 6;
  ::google::protobuf::uint64 skips(int index) const;
  void set_skips(int index, ::google::protobuf::uint64 value);
  void add_skips(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      skips() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_skips();

  // required uint64 start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  ::google::protobuf::uint64 start() const;
  void set_start(::google::protobuf::uint64 value);

  // required uint64 stop = 2;
  bool has_stop() const;
  void clear_stop();
  static const int kStopFieldNumber = 2;
  ::google::protobuf::uint64 stop() const;
  void set_stop(::google::protobuf::uint64 value);

  // optional uint32 size_chunks = 3 [default = 1000];
  bool has_size_chunks() const;
  void clear_size_chunks();
  static const int kSizeChunksFieldNumber = 3;
  ::google::protobuf::uint32 size_chunks() const;
  void set_size_chunks(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message_start_exec)
 private:
  void set_has_start();
  void clear_has_start();
  void set_has_stop();
  void clear_has_stop();
  void set_has_size_chunks();
  void clear_has_size_chunks();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > breakpoints_;
  ::google::protobuf::RepeatedPtrField< ::configuration::input_t > inputs_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > skips_;
  ::google::protobuf::uint64 start_;
  ::google::protobuf::uint64 stop_;
  ::google::protobuf::uint32 size_chunks_;
  friend struct  protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class message_bp_reached : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message_bp_reached) */ {
 public:
  message_bp_reached();
  virtual ~message_bp_reached();

  message_bp_reached(const message_bp_reached& from);

  inline message_bp_reached& operator=(const message_bp_reached& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const message_bp_reached& default_instance();

  static inline const message_bp_reached* internal_default_instance() {
    return reinterpret_cast<const message_bp_reached*>(
               &_message_bp_reached_default_instance_);
  }

  void Swap(message_bp_reached* other);

  // implements Message ----------------------------------------------

  inline message_bp_reached* New() const PROTOBUF_FINAL { return New(NULL); }

  message_bp_reached* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const message_bp_reached& from);
  void MergeFrom(const message_bp_reached& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(message_bp_reached* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 addr = 1;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  ::google::protobuf::uint64 addr() const;
  void set_addr(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:message_bp_reached)
 private:
  void set_has_addr();
  void clear_has_addr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 addr_;
  friend struct  protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class message_patch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message_patch) */ {
 public:
  message_patch();
  virtual ~message_patch();

  message_patch(const message_patch& from);

  inline message_patch& operator=(const message_patch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const message_patch& default_instance();

  static inline const message_patch* internal_default_instance() {
    return reinterpret_cast<const message_patch*>(
               &_message_patch_default_instance_);
  }

  void Swap(message_patch* other);

  // implements Message ----------------------------------------------

  inline message_patch* New() const PROTOBUF_FINAL { return New(NULL); }

  message_patch* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const message_patch& from);
  void MergeFrom(const message_patch& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(message_patch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .configuration.input_t patch = 1;
  int patch_size() const;
  void clear_patch();
  static const int kPatchFieldNumber = 1;
  const ::configuration::input_t& patch(int index) const;
  ::configuration::input_t* mutable_patch(int index);
  ::configuration::input_t* add_patch();
  ::google::protobuf::RepeatedPtrField< ::configuration::input_t >*
      mutable_patch();
  const ::google::protobuf::RepeatedPtrField< ::configuration::input_t >&
      patch() const;

  // @@protoc_insertion_point(class_scope:message_patch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::configuration::input_t > patch_;
  friend struct  protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class message_infos : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message_infos) */ {
 public:
  message_infos();
  virtual ~message_infos();

  message_infos(const message_infos& from);

  inline message_infos& operator=(const message_infos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const message_infos& default_instance();

  static inline const message_infos* internal_default_instance() {
    return reinterpret_cast<const message_infos*>(
               &_message_infos_default_instance_);
  }

  void Swap(message_infos* other);

  // implements Message ----------------------------------------------

  inline message_infos* New() const PROTOBUF_FINAL { return New(NULL); }

  message_infos* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const message_infos& from);
  void MergeFrom(const message_infos& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(message_infos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string analyses = 2;
  int analyses_size() const;
  void clear_analyses();
  static const int kAnalysesFieldNumber = 2;
  const ::std::string& analyses(int index) const;
  ::std::string* mutable_analyses(int index);
  void set_analyses(int index, const ::std::string& value);
  void set_analyses(int index, const char* value);
  void set_analyses(int index, const char* value, size_t size);
  ::std::string* add_analyses();
  void add_analyses(const ::std::string& value);
  void add_analyses(const char* value);
  void add_analyses(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& analyses() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_analyses();

  // repeated string solvers = 3;
  int solvers_size() const;
  void clear_solvers();
  static const int kSolversFieldNumber = 3;
  const ::std::string& solvers(int index) const;
  ::std::string* mutable_solvers(int index);
  void set_solvers(int index, const ::std::string& value);
  void set_solvers(int index, const char* value);
  void set_solvers(int index, const char* value, size_t size);
  ::std::string* add_solvers();
  void add_solvers(const ::std::string& value);
  void add_solvers(const char* value);
  void add_solvers(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& solvers() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_solvers();

  // required uint32 nb_workers = 1;
  bool has_nb_workers() const;
  void clear_nb_workers();
  static const int kNbWorkersFieldNumber = 1;
  ::google::protobuf::uint32 nb_workers() const;
  void set_nb_workers(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:message_infos)
 private:
  void set_has_nb_workers();
  void clear_has_nb_workers();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> analyses_;
  ::google::protobuf::RepeatedPtrField< ::std::string> solvers_;
  ::google::protobuf::uint32 nb_workers_;
  friend struct  protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class message_decode_instr_instr_entry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message_decode_instr.instr_entry) */ {
 public:
  message_decode_instr_instr_entry();
  virtual ~message_decode_instr_instr_entry();

  message_decode_instr_instr_entry(const message_decode_instr_instr_entry& from);

  inline message_decode_instr_instr_entry& operator=(const message_decode_instr_instr_entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const message_decode_instr_instr_entry& default_instance();

  static inline const message_decode_instr_instr_entry* internal_default_instance() {
    return reinterpret_cast<const message_decode_instr_instr_entry*>(
               &_message_decode_instr_instr_entry_default_instance_);
  }

  void Swap(message_decode_instr_instr_entry* other);

  // implements Message ----------------------------------------------

  inline message_decode_instr_instr_entry* New() const PROTOBUF_FINAL { return New(NULL); }

  message_decode_instr_instr_entry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const message_decode_instr_instr_entry& from);
  void MergeFrom(const message_decode_instr_instr_entry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(message_decode_instr_instr_entry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string instr = 1;
  bool has_instr() const;
  void clear_instr();
  static const int kInstrFieldNumber = 1;
  const ::std::string& instr() const;
  void set_instr(const ::std::string& value);
  #if LANG_CXX11
  void set_instr(::std::string&& value);
  #endif
  void set_instr(const char* value);
  void set_instr(const char* value, size_t size);
  ::std::string* mutable_instr();
  ::std::string* release_instr();
  void set_allocated_instr(::std::string* instr);

  // optional uint64 base_addr = 2 [default = 0];
  bool has_base_addr() const;
  void clear_base_addr();
  static const int kBaseAddrFieldNumber = 2;
  ::google::protobuf::uint64 base_addr() const;
  void set_base_addr(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:message_decode_instr.instr_entry)
 private:
  void set_has_instr();
  void clear_has_instr();
  void set_has_base_addr();
  void clear_has_base_addr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr instr_;
  ::google::protobuf::uint64 base_addr_;
  friend struct  protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class message_decode_instr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message_decode_instr) */ {
 public:
  message_decode_instr();
  virtual ~message_decode_instr();

  message_decode_instr(const message_decode_instr& from);

  inline message_decode_instr& operator=(const message_decode_instr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const message_decode_instr& default_instance();

  static inline const message_decode_instr* internal_default_instance() {
    return reinterpret_cast<const message_decode_instr*>(
               &_message_decode_instr_default_instance_);
  }

  void Swap(message_decode_instr* other);

  // implements Message ----------------------------------------------

  inline message_decode_instr* New() const PROTOBUF_FINAL { return New(NULL); }

  message_decode_instr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const message_decode_instr& from);
  void MergeFrom(const message_decode_instr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(message_decode_instr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef message_decode_instr_instr_entry instr_entry;

  typedef message_decode_instr_bin_kind bin_kind;
  static const bin_kind HEXA =
    message_decode_instr_bin_kind_HEXA;
  static const bin_kind BIN =
    message_decode_instr_bin_kind_BIN;
  static inline bool bin_kind_IsValid(int value) {
    return message_decode_instr_bin_kind_IsValid(value);
  }
  static const bin_kind bin_kind_MIN =
    message_decode_instr_bin_kind_bin_kind_MIN;
  static const bin_kind bin_kind_MAX =
    message_decode_instr_bin_kind_bin_kind_MAX;
  static const int bin_kind_ARRAYSIZE =
    message_decode_instr_bin_kind_bin_kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  bin_kind_descriptor() {
    return message_decode_instr_bin_kind_descriptor();
  }
  static inline const ::std::string& bin_kind_Name(bin_kind value) {
    return message_decode_instr_bin_kind_Name(value);
  }
  static inline bool bin_kind_Parse(const ::std::string& name,
      bin_kind* value) {
    return message_decode_instr_bin_kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .message_decode_instr.instr_entry instrs = 1;
  int instrs_size() const;
  void clear_instrs();
  static const int kInstrsFieldNumber = 1;
  const ::message_decode_instr_instr_entry& instrs(int index) const;
  ::message_decode_instr_instr_entry* mutable_instrs(int index);
  ::message_decode_instr_instr_entry* add_instrs();
  ::google::protobuf::RepeatedPtrField< ::message_decode_instr_instr_entry >*
      mutable_instrs();
  const ::google::protobuf::RepeatedPtrField< ::message_decode_instr_instr_entry >&
      instrs() const;

  // optional .message_decode_instr.bin_kind kind = 2 [default = BIN];
  bool has_kind() const;
  void clear_kind();
  static const int kKindFieldNumber = 2;
  ::message_decode_instr_bin_kind kind() const;
  void set_kind(::message_decode_instr_bin_kind value);

  // optional .common.ir_kind_t irkind = 3 [default = DBA];
  bool has_irkind() const;
  void clear_irkind();
  static const int kIrkindFieldNumber = 3;
  ::common::ir_kind_t irkind() const;
  void set_irkind(::common::ir_kind_t value);

  // @@protoc_insertion_point(class_scope:message_decode_instr)
 private:
  void set_has_kind();
  void clear_has_kind();
  void set_has_irkind();
  void clear_has_irkind();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::message_decode_instr_instr_entry > instrs_;
  int kind_;
  int irkind_;
  friend struct  protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class message_decode_instr_reply_instr_entry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message_decode_instr_reply.instr_entry) */ {
 public:
  message_decode_instr_reply_instr_entry();
  virtual ~message_decode_instr_reply_instr_entry();

  message_decode_instr_reply_instr_entry(const message_decode_instr_reply_instr_entry& from);

  inline message_decode_instr_reply_instr_entry& operator=(const message_decode_instr_reply_instr_entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const message_decode_instr_reply_instr_entry& default_instance();

  enum InstrsCntCase {
    kDbaInstrs = 3,
    INSTRS_CNT_NOT_SET = 0,
  };

  static inline const message_decode_instr_reply_instr_entry* internal_default_instance() {
    return reinterpret_cast<const message_decode_instr_reply_instr_entry*>(
               &_message_decode_instr_reply_instr_entry_default_instance_);
  }

  void Swap(message_decode_instr_reply_instr_entry* other);

  // implements Message ----------------------------------------------

  inline message_decode_instr_reply_instr_entry* New() const PROTOBUF_FINAL { return New(NULL); }

  message_decode_instr_reply_instr_entry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const message_decode_instr_reply_instr_entry& from);
  void MergeFrom(const message_decode_instr_reply_instr_entry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(message_decode_instr_reply_instr_entry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string opcode = 1;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpcodeFieldNumber = 1;
  const ::std::string& opcode() const;
  void set_opcode(const ::std::string& value);
  #if LANG_CXX11
  void set_opcode(::std::string&& value);
  #endif
  void set_opcode(const char* value);
  void set_opcode(const char* value, size_t size);
  ::std::string* mutable_opcode();
  ::std::string* release_opcode();
  void set_allocated_opcode(::std::string* opcode);

  // required .common.ir_kind_t irkind = 2;
  bool has_irkind() const;
  void clear_irkind();
  static const int kIrkindFieldNumber = 2;
  ::common::ir_kind_t irkind() const;
  void set_irkind(::common::ir_kind_t value);

  // optional .dba.dba_list dba_instrs = 3;
  bool has_dba_instrs() const;
  void clear_dba_instrs();
  static const int kDbaInstrsFieldNumber = 3;
  const ::dba::dba_list& dba_instrs() const;
  ::dba::dba_list* mutable_dba_instrs();
  ::dba::dba_list* release_dba_instrs();
  void set_allocated_dba_instrs(::dba::dba_list* dba_instrs);

  InstrsCntCase instrs_cnt_case() const;
  // @@protoc_insertion_point(class_scope:message_decode_instr_reply.instr_entry)
 private:
  void set_has_opcode();
  void clear_has_opcode();
  void set_has_irkind();
  void clear_has_irkind();
  void set_has_dba_instrs();

  inline bool has_instrs_cnt() const;
  void clear_instrs_cnt();
  inline void clear_has_instrs_cnt();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr opcode_;
  int irkind_;
  union InstrsCntUnion {
    InstrsCntUnion() {}
    ::dba::dba_list* dba_instrs_;
  } instrs_cnt_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct  protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class message_decode_instr_reply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message_decode_instr_reply) */ {
 public:
  message_decode_instr_reply();
  virtual ~message_decode_instr_reply();

  message_decode_instr_reply(const message_decode_instr_reply& from);

  inline message_decode_instr_reply& operator=(const message_decode_instr_reply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const message_decode_instr_reply& default_instance();

  static inline const message_decode_instr_reply* internal_default_instance() {
    return reinterpret_cast<const message_decode_instr_reply*>(
               &_message_decode_instr_reply_default_instance_);
  }

  void Swap(message_decode_instr_reply* other);

  // implements Message ----------------------------------------------

  inline message_decode_instr_reply* New() const PROTOBUF_FINAL { return New(NULL); }

  message_decode_instr_reply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const message_decode_instr_reply& from);
  void MergeFrom(const message_decode_instr_reply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(message_decode_instr_reply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef message_decode_instr_reply_instr_entry instr_entry;

  // accessors -------------------------------------------------------

  // repeated .message_decode_instr_reply.instr_entry instrs = 1;
  int instrs_size() const;
  void clear_instrs();
  static const int kInstrsFieldNumber = 1;
  const ::message_decode_instr_reply_instr_entry& instrs(int index) const;
  ::message_decode_instr_reply_instr_entry* mutable_instrs(int index);
  ::message_decode_instr_reply_instr_entry* add_instrs();
  ::google::protobuf::RepeatedPtrField< ::message_decode_instr_reply_instr_entry >*
      mutable_instrs();
  const ::google::protobuf::RepeatedPtrField< ::message_decode_instr_reply_instr_entry >&
      instrs() const;

  // @@protoc_insertion_point(class_scope:message_decode_instr_reply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::message_decode_instr_reply_instr_entry > instrs_;
  friend struct  protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class message_start_symb_exec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message_start_symb_exec) */ {
 public:
  message_start_symb_exec();
  virtual ~message_start_symb_exec();

  message_start_symb_exec(const message_start_symb_exec& from);

  inline message_start_symb_exec& operator=(const message_start_symb_exec& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const message_start_symb_exec& default_instance();

  static inline const message_start_symb_exec* internal_default_instance() {
    return reinterpret_cast<const message_start_symb_exec*>(
               &_message_start_symb_exec_default_instance_);
  }

  void Swap(message_start_symb_exec* other);

  // implements Message ----------------------------------------------

  inline message_start_symb_exec* New() const PROTOBUF_FINAL { return New(NULL); }

  message_start_symb_exec* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const message_start_symb_exec& from);
  void MergeFrom(const message_start_symb_exec& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(message_start_symb_exec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef message_start_symb_exec_trace_kind trace_kind;
  static const trace_kind FILE =
    message_start_symb_exec_trace_kind_FILE;
  static const trace_kind STREAM =
    message_start_symb_exec_trace_kind_STREAM;
  static inline bool trace_kind_IsValid(int value) {
    return message_start_symb_exec_trace_kind_IsValid(value);
  }
  static const trace_kind trace_kind_MIN =
    message_start_symb_exec_trace_kind_trace_kind_MIN;
  static const trace_kind trace_kind_MAX =
    message_start_symb_exec_trace_kind_trace_kind_MAX;
  static const int trace_kind_ARRAYSIZE =
    message_start_symb_exec_trace_kind_trace_kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  trace_kind_descriptor() {
    return message_start_symb_exec_trace_kind_descriptor();
  }
  static inline const ::std::string& trace_kind_Name(trace_kind value) {
    return message_start_symb_exec_trace_kind_Name(value);
  }
  static inline bool trace_kind_Parse(const ::std::string& name,
      trace_kind* value) {
    return message_start_symb_exec_trace_kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string predicate = 11;
  bool has_predicate() const;
  void clear_predicate();
  static const int kPredicateFieldNumber = 11;
  const ::std::string& predicate() const;
  void set_predicate(const ::std::string& value);
  #if LANG_CXX11
  void set_predicate(::std::string&& value);
  #endif
  void set_predicate(const char* value);
  void set_predicate(const char* value, size_t size);
  ::std::string* mutable_predicate();
  ::std::string* release_predicate();
  void set_allocated_predicate(::std::string* predicate);

  // optional string trace_filename = 12;
  bool has_trace_filename() const;
  void clear_trace_filename();
  static const int kTraceFilenameFieldNumber = 12;
  const ::std::string& trace_filename() const;
  void set_trace_filename(const ::std::string& value);
  #if LANG_CXX11
  void set_trace_filename(::std::string&& value);
  #endif
  void set_trace_filename(const char* value);
  void set_trace_filename(const char* value, size_t size);
  ::std::string* mutable_trace_filename();
  ::std::string* release_trace_filename();
  void set_allocated_trace_filename(::std::string* trace_filename);

  // optional .configuration.configuration config = 4;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 4;
  const ::configuration::configuration& config() const;
  ::configuration::configuration* mutable_config();
  ::configuration::configuration* release_config();
  void set_allocated_config(::configuration::configuration* config);

  // optional bool formula_optim_cstfold = 6;
  bool has_formula_optim_cstfold() const;
  void clear_formula_optim_cstfold();
  static const int kFormulaOptimCstfoldFieldNumber = 6;
  bool formula_optim_cstfold() const;
  void set_formula_optim_cstfold(bool value);

  // optional bool formula_optim_rebase = 7;
  bool has_formula_optim_rebase() const;
  void clear_formula_optim_rebase();
  static const int kFormulaOptimRebaseFieldNumber = 7;
  bool formula_optim_rebase() const;
  void set_formula_optim_rebase(bool value);

  // optional bool formula_optim_row = 8;
  bool has_formula_optim_row() const;
  void clear_formula_optim_row();
  static const int kFormulaOptimRowFieldNumber = 8;
  bool formula_optim_row() const;
  void set_formula_optim_row(bool value);

  // required uint32 verbose = 9;
  bool has_verbose() const;
  void clear_verbose();
  static const int kVerboseFieldNumber = 9;
  ::google::protobuf::uint32 verbose() const;
  void set_verbose(::google::protobuf::uint32 value);

  // optional uint64 addr_predicate = 10;
  bool has_addr_predicate() const;
  void clear_addr_predicate();
  static const int kAddrPredicateFieldNumber = 10;
  ::google::protobuf::uint64 addr_predicate() const;
  void set_addr_predicate(::google::protobuf::uint64 value);

  // optional .common.ir_kind_t irkind = 5 [default = DBA];
  bool has_irkind() const;
  void clear_irkind();
  static const int kIrkindFieldNumber = 5;
  ::common::ir_kind_t irkind() const;
  void set_irkind(::common::ir_kind_t value);

  // required .message_start_symb_exec.trace_kind trace_type = 1;
  bool has_trace_type() const;
  void clear_trace_type();
  static const int kTraceTypeFieldNumber = 1;
  ::message_start_symb_exec_trace_kind trace_type() const;
  void set_trace_type(::message_start_symb_exec_trace_kind value);

  // optional .common.solver_t solver = 3 [default = Z3];
  bool has_solver() const;
  void clear_solver();
  static const int kSolverFieldNumber = 3;
  ::common::solver_t solver() const;
  void set_solver(::common::solver_t value);

  // @@protoc_insertion_point(class_scope:message_start_symb_exec)
 private:
  void set_has_trace_type();
  void clear_has_trace_type();
  void set_has_name();
  void clear_has_name();
  void set_has_solver();
  void clear_has_solver();
  void set_has_config();
  void clear_has_config();
  void set_has_irkind();
  void clear_has_irkind();
  void set_has_formula_optim_cstfold();
  void clear_has_formula_optim_cstfold();
  void set_has_formula_optim_rebase();
  void clear_has_formula_optim_rebase();
  void set_has_formula_optim_row();
  void clear_has_formula_optim_row();
  void set_has_verbose();
  void clear_has_verbose();
  void set_has_addr_predicate();
  void clear_has_addr_predicate();
  void set_has_predicate();
  void clear_has_predicate();
  void set_has_trace_filename();
  void clear_has_trace_filename();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr predicate_;
  ::google::protobuf::internal::ArenaStringPtr trace_filename_;
  ::configuration::configuration* config_;
  bool formula_optim_cstfold_;
  bool formula_optim_rebase_;
  bool formula_optim_row_;
  ::google::protobuf::uint32 verbose_;
  ::google::protobuf::uint64 addr_predicate_;
  int irkind_;
  int trace_type_;
  int solver_;
  friend struct  protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class message_output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message_output) */ {
 public:
  message_output();
  virtual ~message_output();

  message_output(const message_output& from);

  inline message_output& operator=(const message_output& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const message_output& default_instance();

  static inline const message_output* internal_default_instance() {
    return reinterpret_cast<const message_output*>(
               &_message_output_default_instance_);
  }

  void Swap(message_output* other);

  // implements Message ----------------------------------------------

  inline message_output* New() const PROTOBUF_FINAL { return New(NULL); }

  message_output* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const message_output& from);
  void MergeFrom(const message_output& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(message_output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef message_output_output_kind output_kind;
  static const output_kind SUCCESS =
    message_output_output_kind_SUCCESS;
  static const output_kind RESULT =
    message_output_output_kind_RESULT;
  static const output_kind DEBUG =
    message_output_output_kind_DEBUG;
  static const output_kind WARNING =
    message_output_output_kind_WARNING;
  static const output_kind ERROR =
    message_output_output_kind_ERROR;
  static const output_kind FAILURE =
    message_output_output_kind_FAILURE;
  static inline bool output_kind_IsValid(int value) {
    return message_output_output_kind_IsValid(value);
  }
  static const output_kind output_kind_MIN =
    message_output_output_kind_output_kind_MIN;
  static const output_kind output_kind_MAX =
    message_output_output_kind_output_kind_MAX;
  static const int output_kind_ARRAYSIZE =
    message_output_output_kind_output_kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  output_kind_descriptor() {
    return message_output_output_kind_descriptor();
  }
  static inline const ::std::string& output_kind_Name(output_kind value) {
    return message_output_output_kind_Name(value);
  }
  static inline bool output_kind_Parse(const ::std::string& name,
      output_kind* value) {
    return message_output_output_kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional uint32 ram_total = 3;
  bool has_ram_total() const;
  void clear_ram_total();
  static const int kRamTotalFieldNumber = 3;
  ::google::protobuf::uint32 ram_total() const;
  void set_ram_total(::google::protobuf::uint32 value);

  // optional uint32 ram_free = 4;
  bool has_ram_free() const;
  void clear_ram_free();
  static const int kRamFreeFieldNumber = 4;
  ::google::protobuf::uint32 ram_free() const;
  void set_ram_free(::google::protobuf::uint32 value);

  // optional uint32 ram_available = 5;
  bool has_ram_available() const;
  void clear_ram_available();
  static const int kRamAvailableFieldNumber = 5;
  ::google::protobuf::uint32 ram_available() const;
  void set_ram_available(::google::protobuf::uint32 value);

  // required .message_output.output_kind type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::message_output_output_kind type() const;
  void set_type(::message_output_output_kind value);

  // @@protoc_insertion_point(class_scope:message_output)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_message();
  void clear_has_message();
  void set_has_ram_total();
  void clear_has_ram_total();
  void set_has_ram_free();
  void clear_has_ram_free();
  void set_has_ram_available();
  void clear_has_ram_available();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint32 ram_total_;
  ::google::protobuf::uint32 ram_free_;
  ::google::protobuf::uint32 ram_available_;
  int type_;
  friend struct  protobuf_message_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// message_start_exec

// required uint64 start = 1;
inline bool message_start_exec::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_start_exec::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void message_start_exec::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void message_start_exec::clear_start() {
  start_ = GOOGLE_ULONGLONG(0);
  clear_has_start();
}
inline ::google::protobuf::uint64 message_start_exec::start() const {
  // @@protoc_insertion_point(field_get:message_start_exec.start)
  return start_;
}
inline void message_start_exec::set_start(::google::protobuf::uint64 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:message_start_exec.start)
}

// required uint64 stop = 2;
inline bool message_start_exec::has_stop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void message_start_exec::set_has_stop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void message_start_exec::clear_has_stop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void message_start_exec::clear_stop() {
  stop_ = GOOGLE_ULONGLONG(0);
  clear_has_stop();
}
inline ::google::protobuf::uint64 message_start_exec::stop() const {
  // @@protoc_insertion_point(field_get:message_start_exec.stop)
  return stop_;
}
inline void message_start_exec::set_stop(::google::protobuf::uint64 value) {
  set_has_stop();
  stop_ = value;
  // @@protoc_insertion_point(field_set:message_start_exec.stop)
}

// optional uint32 size_chunks = 3 [default = 1000];
inline bool message_start_exec::has_size_chunks() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void message_start_exec::set_has_size_chunks() {
  _has_bits_[0] |= 0x00000004u;
}
inline void message_start_exec::clear_has_size_chunks() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void message_start_exec::clear_size_chunks() {
  size_chunks_ = 1000u;
  clear_has_size_chunks();
}
inline ::google::protobuf::uint32 message_start_exec::size_chunks() const {
  // @@protoc_insertion_point(field_get:message_start_exec.size_chunks)
  return size_chunks_;
}
inline void message_start_exec::set_size_chunks(::google::protobuf::uint32 value) {
  set_has_size_chunks();
  size_chunks_ = value;
  // @@protoc_insertion_point(field_set:message_start_exec.size_chunks)
}

// repeated uint64 breakpoints = 4;
inline int message_start_exec::breakpoints_size() const {
  return breakpoints_.size();
}
inline void message_start_exec::clear_breakpoints() {
  breakpoints_.Clear();
}
inline ::google::protobuf::uint64 message_start_exec::breakpoints(int index) const {
  // @@protoc_insertion_point(field_get:message_start_exec.breakpoints)
  return breakpoints_.Get(index);
}
inline void message_start_exec::set_breakpoints(int index, ::google::protobuf::uint64 value) {
  breakpoints_.Set(index, value);
  // @@protoc_insertion_point(field_set:message_start_exec.breakpoints)
}
inline void message_start_exec::add_breakpoints(::google::protobuf::uint64 value) {
  breakpoints_.Add(value);
  // @@protoc_insertion_point(field_add:message_start_exec.breakpoints)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
message_start_exec::breakpoints() const {
  // @@protoc_insertion_point(field_list:message_start_exec.breakpoints)
  return breakpoints_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
message_start_exec::mutable_breakpoints() {
  // @@protoc_insertion_point(field_mutable_list:message_start_exec.breakpoints)
  return &breakpoints_;
}

// repeated .configuration.input_t inputs = 5;
inline int message_start_exec::inputs_size() const {
  return inputs_.size();
}
inline void message_start_exec::clear_inputs() {
  inputs_.Clear();
}
inline const ::configuration::input_t& message_start_exec::inputs(int index) const {
  // @@protoc_insertion_point(field_get:message_start_exec.inputs)
  return inputs_.Get(index);
}
inline ::configuration::input_t* message_start_exec::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:message_start_exec.inputs)
  return inputs_.Mutable(index);
}
inline ::configuration::input_t* message_start_exec::add_inputs() {
  // @@protoc_insertion_point(field_add:message_start_exec.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::configuration::input_t >*
message_start_exec::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:message_start_exec.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::configuration::input_t >&
message_start_exec::inputs() const {
  // @@protoc_insertion_point(field_list:message_start_exec.inputs)
  return inputs_;
}

// repeated uint64 skips = 6;
inline int message_start_exec::skips_size() const {
  return skips_.size();
}
inline void message_start_exec::clear_skips() {
  skips_.Clear();
}
inline ::google::protobuf::uint64 message_start_exec::skips(int index) const {
  // @@protoc_insertion_point(field_get:message_start_exec.skips)
  return skips_.Get(index);
}
inline void message_start_exec::set_skips(int index, ::google::protobuf::uint64 value) {
  skips_.Set(index, value);
  // @@protoc_insertion_point(field_set:message_start_exec.skips)
}
inline void message_start_exec::add_skips(::google::protobuf::uint64 value) {
  skips_.Add(value);
  // @@protoc_insertion_point(field_add:message_start_exec.skips)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
message_start_exec::skips() const {
  // @@protoc_insertion_point(field_list:message_start_exec.skips)
  return skips_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
message_start_exec::mutable_skips() {
  // @@protoc_insertion_point(field_mutable_list:message_start_exec.skips)
  return &skips_;
}

// -------------------------------------------------------------------

// message_bp_reached

// required uint64 addr = 1;
inline bool message_bp_reached::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_bp_reached::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void message_bp_reached::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void message_bp_reached::clear_addr() {
  addr_ = GOOGLE_ULONGLONG(0);
  clear_has_addr();
}
inline ::google::protobuf::uint64 message_bp_reached::addr() const {
  // @@protoc_insertion_point(field_get:message_bp_reached.addr)
  return addr_;
}
inline void message_bp_reached::set_addr(::google::protobuf::uint64 value) {
  set_has_addr();
  addr_ = value;
  // @@protoc_insertion_point(field_set:message_bp_reached.addr)
}

// -------------------------------------------------------------------

// message_patch

// repeated .configuration.input_t patch = 1;
inline int message_patch::patch_size() const {
  return patch_.size();
}
inline void message_patch::clear_patch() {
  patch_.Clear();
}
inline const ::configuration::input_t& message_patch::patch(int index) const {
  // @@protoc_insertion_point(field_get:message_patch.patch)
  return patch_.Get(index);
}
inline ::configuration::input_t* message_patch::mutable_patch(int index) {
  // @@protoc_insertion_point(field_mutable:message_patch.patch)
  return patch_.Mutable(index);
}
inline ::configuration::input_t* message_patch::add_patch() {
  // @@protoc_insertion_point(field_add:message_patch.patch)
  return patch_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::configuration::input_t >*
message_patch::mutable_patch() {
  // @@protoc_insertion_point(field_mutable_list:message_patch.patch)
  return &patch_;
}
inline const ::google::protobuf::RepeatedPtrField< ::configuration::input_t >&
message_patch::patch() const {
  // @@protoc_insertion_point(field_list:message_patch.patch)
  return patch_;
}

// -------------------------------------------------------------------

// message_infos

// required uint32 nb_workers = 1;
inline bool message_infos::has_nb_workers() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_infos::set_has_nb_workers() {
  _has_bits_[0] |= 0x00000001u;
}
inline void message_infos::clear_has_nb_workers() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void message_infos::clear_nb_workers() {
  nb_workers_ = 0u;
  clear_has_nb_workers();
}
inline ::google::protobuf::uint32 message_infos::nb_workers() const {
  // @@protoc_insertion_point(field_get:message_infos.nb_workers)
  return nb_workers_;
}
inline void message_infos::set_nb_workers(::google::protobuf::uint32 value) {
  set_has_nb_workers();
  nb_workers_ = value;
  // @@protoc_insertion_point(field_set:message_infos.nb_workers)
}

// repeated string analyses = 2;
inline int message_infos::analyses_size() const {
  return analyses_.size();
}
inline void message_infos::clear_analyses() {
  analyses_.Clear();
}
inline const ::std::string& message_infos::analyses(int index) const {
  // @@protoc_insertion_point(field_get:message_infos.analyses)
  return analyses_.Get(index);
}
inline ::std::string* message_infos::mutable_analyses(int index) {
  // @@protoc_insertion_point(field_mutable:message_infos.analyses)
  return analyses_.Mutable(index);
}
inline void message_infos::set_analyses(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:message_infos.analyses)
  analyses_.Mutable(index)->assign(value);
}
inline void message_infos::set_analyses(int index, const char* value) {
  analyses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:message_infos.analyses)
}
inline void message_infos::set_analyses(int index, const char* value, size_t size) {
  analyses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message_infos.analyses)
}
inline ::std::string* message_infos::add_analyses() {
  // @@protoc_insertion_point(field_add_mutable:message_infos.analyses)
  return analyses_.Add();
}
inline void message_infos::add_analyses(const ::std::string& value) {
  analyses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:message_infos.analyses)
}
inline void message_infos::add_analyses(const char* value) {
  analyses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:message_infos.analyses)
}
inline void message_infos::add_analyses(const char* value, size_t size) {
  analyses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:message_infos.analyses)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
message_infos::analyses() const {
  // @@protoc_insertion_point(field_list:message_infos.analyses)
  return analyses_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
message_infos::mutable_analyses() {
  // @@protoc_insertion_point(field_mutable_list:message_infos.analyses)
  return &analyses_;
}

// repeated string solvers = 3;
inline int message_infos::solvers_size() const {
  return solvers_.size();
}
inline void message_infos::clear_solvers() {
  solvers_.Clear();
}
inline const ::std::string& message_infos::solvers(int index) const {
  // @@protoc_insertion_point(field_get:message_infos.solvers)
  return solvers_.Get(index);
}
inline ::std::string* message_infos::mutable_solvers(int index) {
  // @@protoc_insertion_point(field_mutable:message_infos.solvers)
  return solvers_.Mutable(index);
}
inline void message_infos::set_solvers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:message_infos.solvers)
  solvers_.Mutable(index)->assign(value);
}
inline void message_infos::set_solvers(int index, const char* value) {
  solvers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:message_infos.solvers)
}
inline void message_infos::set_solvers(int index, const char* value, size_t size) {
  solvers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message_infos.solvers)
}
inline ::std::string* message_infos::add_solvers() {
  // @@protoc_insertion_point(field_add_mutable:message_infos.solvers)
  return solvers_.Add();
}
inline void message_infos::add_solvers(const ::std::string& value) {
  solvers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:message_infos.solvers)
}
inline void message_infos::add_solvers(const char* value) {
  solvers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:message_infos.solvers)
}
inline void message_infos::add_solvers(const char* value, size_t size) {
  solvers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:message_infos.solvers)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
message_infos::solvers() const {
  // @@protoc_insertion_point(field_list:message_infos.solvers)
  return solvers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
message_infos::mutable_solvers() {
  // @@protoc_insertion_point(field_mutable_list:message_infos.solvers)
  return &solvers_;
}

// -------------------------------------------------------------------

// message_decode_instr_instr_entry

// required string instr = 1;
inline bool message_decode_instr_instr_entry::has_instr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_decode_instr_instr_entry::set_has_instr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void message_decode_instr_instr_entry::clear_has_instr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void message_decode_instr_instr_entry::clear_instr() {
  instr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_instr();
}
inline const ::std::string& message_decode_instr_instr_entry::instr() const {
  // @@protoc_insertion_point(field_get:message_decode_instr.instr_entry.instr)
  return instr_.GetNoArena();
}
inline void message_decode_instr_instr_entry::set_instr(const ::std::string& value) {
  set_has_instr();
  instr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message_decode_instr.instr_entry.instr)
}
#if LANG_CXX11
inline void message_decode_instr_instr_entry::set_instr(::std::string&& value) {
  set_has_instr();
  instr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message_decode_instr.instr_entry.instr)
}
#endif
inline void message_decode_instr_instr_entry::set_instr(const char* value) {
  set_has_instr();
  instr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message_decode_instr.instr_entry.instr)
}
inline void message_decode_instr_instr_entry::set_instr(const char* value, size_t size) {
  set_has_instr();
  instr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message_decode_instr.instr_entry.instr)
}
inline ::std::string* message_decode_instr_instr_entry::mutable_instr() {
  set_has_instr();
  // @@protoc_insertion_point(field_mutable:message_decode_instr.instr_entry.instr)
  return instr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* message_decode_instr_instr_entry::release_instr() {
  // @@protoc_insertion_point(field_release:message_decode_instr.instr_entry.instr)
  clear_has_instr();
  return instr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void message_decode_instr_instr_entry::set_allocated_instr(::std::string* instr) {
  if (instr != NULL) {
    set_has_instr();
  } else {
    clear_has_instr();
  }
  instr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), instr);
  // @@protoc_insertion_point(field_set_allocated:message_decode_instr.instr_entry.instr)
}

// optional uint64 base_addr = 2 [default = 0];
inline bool message_decode_instr_instr_entry::has_base_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void message_decode_instr_instr_entry::set_has_base_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void message_decode_instr_instr_entry::clear_has_base_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void message_decode_instr_instr_entry::clear_base_addr() {
  base_addr_ = GOOGLE_ULONGLONG(0);
  clear_has_base_addr();
}
inline ::google::protobuf::uint64 message_decode_instr_instr_entry::base_addr() const {
  // @@protoc_insertion_point(field_get:message_decode_instr.instr_entry.base_addr)
  return base_addr_;
}
inline void message_decode_instr_instr_entry::set_base_addr(::google::protobuf::uint64 value) {
  set_has_base_addr();
  base_addr_ = value;
  // @@protoc_insertion_point(field_set:message_decode_instr.instr_entry.base_addr)
}

// -------------------------------------------------------------------

// message_decode_instr

// repeated .message_decode_instr.instr_entry instrs = 1;
inline int message_decode_instr::instrs_size() const {
  return instrs_.size();
}
inline void message_decode_instr::clear_instrs() {
  instrs_.Clear();
}
inline const ::message_decode_instr_instr_entry& message_decode_instr::instrs(int index) const {
  // @@protoc_insertion_point(field_get:message_decode_instr.instrs)
  return instrs_.Get(index);
}
inline ::message_decode_instr_instr_entry* message_decode_instr::mutable_instrs(int index) {
  // @@protoc_insertion_point(field_mutable:message_decode_instr.instrs)
  return instrs_.Mutable(index);
}
inline ::message_decode_instr_instr_entry* message_decode_instr::add_instrs() {
  // @@protoc_insertion_point(field_add:message_decode_instr.instrs)
  return instrs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::message_decode_instr_instr_entry >*
message_decode_instr::mutable_instrs() {
  // @@protoc_insertion_point(field_mutable_list:message_decode_instr.instrs)
  return &instrs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::message_decode_instr_instr_entry >&
message_decode_instr::instrs() const {
  // @@protoc_insertion_point(field_list:message_decode_instr.instrs)
  return instrs_;
}

// optional .message_decode_instr.bin_kind kind = 2 [default = BIN];
inline bool message_decode_instr::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_decode_instr::set_has_kind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void message_decode_instr::clear_has_kind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void message_decode_instr::clear_kind() {
  kind_ = 2;
  clear_has_kind();
}
inline ::message_decode_instr_bin_kind message_decode_instr::kind() const {
  // @@protoc_insertion_point(field_get:message_decode_instr.kind)
  return static_cast< ::message_decode_instr_bin_kind >(kind_);
}
inline void message_decode_instr::set_kind(::message_decode_instr_bin_kind value) {
  assert(::message_decode_instr_bin_kind_IsValid(value));
  set_has_kind();
  kind_ = value;
  // @@protoc_insertion_point(field_set:message_decode_instr.kind)
}

// optional .common.ir_kind_t irkind = 3 [default = DBA];
inline bool message_decode_instr::has_irkind() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void message_decode_instr::set_has_irkind() {
  _has_bits_[0] |= 0x00000002u;
}
inline void message_decode_instr::clear_has_irkind() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void message_decode_instr::clear_irkind() {
  irkind_ = 1;
  clear_has_irkind();
}
inline ::common::ir_kind_t message_decode_instr::irkind() const {
  // @@protoc_insertion_point(field_get:message_decode_instr.irkind)
  return static_cast< ::common::ir_kind_t >(irkind_);
}
inline void message_decode_instr::set_irkind(::common::ir_kind_t value) {
  assert(::common::ir_kind_t_IsValid(value));
  set_has_irkind();
  irkind_ = value;
  // @@protoc_insertion_point(field_set:message_decode_instr.irkind)
}

// -------------------------------------------------------------------

// message_decode_instr_reply_instr_entry

// required string opcode = 1;
inline bool message_decode_instr_reply_instr_entry::has_opcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_decode_instr_reply_instr_entry::set_has_opcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void message_decode_instr_reply_instr_entry::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void message_decode_instr_reply_instr_entry::clear_opcode() {
  opcode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_opcode();
}
inline const ::std::string& message_decode_instr_reply_instr_entry::opcode() const {
  // @@protoc_insertion_point(field_get:message_decode_instr_reply.instr_entry.opcode)
  return opcode_.GetNoArena();
}
inline void message_decode_instr_reply_instr_entry::set_opcode(const ::std::string& value) {
  set_has_opcode();
  opcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message_decode_instr_reply.instr_entry.opcode)
}
#if LANG_CXX11
inline void message_decode_instr_reply_instr_entry::set_opcode(::std::string&& value) {
  set_has_opcode();
  opcode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message_decode_instr_reply.instr_entry.opcode)
}
#endif
inline void message_decode_instr_reply_instr_entry::set_opcode(const char* value) {
  set_has_opcode();
  opcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message_decode_instr_reply.instr_entry.opcode)
}
inline void message_decode_instr_reply_instr_entry::set_opcode(const char* value, size_t size) {
  set_has_opcode();
  opcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message_decode_instr_reply.instr_entry.opcode)
}
inline ::std::string* message_decode_instr_reply_instr_entry::mutable_opcode() {
  set_has_opcode();
  // @@protoc_insertion_point(field_mutable:message_decode_instr_reply.instr_entry.opcode)
  return opcode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* message_decode_instr_reply_instr_entry::release_opcode() {
  // @@protoc_insertion_point(field_release:message_decode_instr_reply.instr_entry.opcode)
  clear_has_opcode();
  return opcode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void message_decode_instr_reply_instr_entry::set_allocated_opcode(::std::string* opcode) {
  if (opcode != NULL) {
    set_has_opcode();
  } else {
    clear_has_opcode();
  }
  opcode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), opcode);
  // @@protoc_insertion_point(field_set_allocated:message_decode_instr_reply.instr_entry.opcode)
}

// required .common.ir_kind_t irkind = 2;
inline bool message_decode_instr_reply_instr_entry::has_irkind() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void message_decode_instr_reply_instr_entry::set_has_irkind() {
  _has_bits_[0] |= 0x00000002u;
}
inline void message_decode_instr_reply_instr_entry::clear_has_irkind() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void message_decode_instr_reply_instr_entry::clear_irkind() {
  irkind_ = 1;
  clear_has_irkind();
}
inline ::common::ir_kind_t message_decode_instr_reply_instr_entry::irkind() const {
  // @@protoc_insertion_point(field_get:message_decode_instr_reply.instr_entry.irkind)
  return static_cast< ::common::ir_kind_t >(irkind_);
}
inline void message_decode_instr_reply_instr_entry::set_irkind(::common::ir_kind_t value) {
  assert(::common::ir_kind_t_IsValid(value));
  set_has_irkind();
  irkind_ = value;
  // @@protoc_insertion_point(field_set:message_decode_instr_reply.instr_entry.irkind)
}

// optional .dba.dba_list dba_instrs = 3;
inline bool message_decode_instr_reply_instr_entry::has_dba_instrs() const {
  return instrs_cnt_case() == kDbaInstrs;
}
inline void message_decode_instr_reply_instr_entry::set_has_dba_instrs() {
  _oneof_case_[0] = kDbaInstrs;
}
inline void message_decode_instr_reply_instr_entry::clear_dba_instrs() {
  if (has_dba_instrs()) {
    delete instrs_cnt_.dba_instrs_;
    clear_has_instrs_cnt();
  }
}
inline  const ::dba::dba_list& message_decode_instr_reply_instr_entry::dba_instrs() const {
  // @@protoc_insertion_point(field_get:message_decode_instr_reply.instr_entry.dba_instrs)
  return has_dba_instrs()
      ? *instrs_cnt_.dba_instrs_
      : ::dba::dba_list::default_instance();
}
inline ::dba::dba_list* message_decode_instr_reply_instr_entry::mutable_dba_instrs() {
  if (!has_dba_instrs()) {
    clear_instrs_cnt();
    set_has_dba_instrs();
    instrs_cnt_.dba_instrs_ = new ::dba::dba_list;
  }
  // @@protoc_insertion_point(field_mutable:message_decode_instr_reply.instr_entry.dba_instrs)
  return instrs_cnt_.dba_instrs_;
}
inline ::dba::dba_list* message_decode_instr_reply_instr_entry::release_dba_instrs() {
  // @@protoc_insertion_point(field_release:message_decode_instr_reply.instr_entry.dba_instrs)
  if (has_dba_instrs()) {
    clear_has_instrs_cnt();
    ::dba::dba_list* temp = instrs_cnt_.dba_instrs_;
    instrs_cnt_.dba_instrs_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void message_decode_instr_reply_instr_entry::set_allocated_dba_instrs(::dba::dba_list* dba_instrs) {
  clear_instrs_cnt();
  if (dba_instrs) {
    set_has_dba_instrs();
    instrs_cnt_.dba_instrs_ = dba_instrs;
  }
  // @@protoc_insertion_point(field_set_allocated:message_decode_instr_reply.instr_entry.dba_instrs)
}

inline bool message_decode_instr_reply_instr_entry::has_instrs_cnt() const {
  return instrs_cnt_case() != INSTRS_CNT_NOT_SET;
}
inline void message_decode_instr_reply_instr_entry::clear_has_instrs_cnt() {
  _oneof_case_[0] = INSTRS_CNT_NOT_SET;
}
inline message_decode_instr_reply_instr_entry::InstrsCntCase message_decode_instr_reply_instr_entry::instrs_cnt_case() const {
  return message_decode_instr_reply_instr_entry::InstrsCntCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// message_decode_instr_reply

// repeated .message_decode_instr_reply.instr_entry instrs = 1;
inline int message_decode_instr_reply::instrs_size() const {
  return instrs_.size();
}
inline void message_decode_instr_reply::clear_instrs() {
  instrs_.Clear();
}
inline const ::message_decode_instr_reply_instr_entry& message_decode_instr_reply::instrs(int index) const {
  // @@protoc_insertion_point(field_get:message_decode_instr_reply.instrs)
  return instrs_.Get(index);
}
inline ::message_decode_instr_reply_instr_entry* message_decode_instr_reply::mutable_instrs(int index) {
  // @@protoc_insertion_point(field_mutable:message_decode_instr_reply.instrs)
  return instrs_.Mutable(index);
}
inline ::message_decode_instr_reply_instr_entry* message_decode_instr_reply::add_instrs() {
  // @@protoc_insertion_point(field_add:message_decode_instr_reply.instrs)
  return instrs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::message_decode_instr_reply_instr_entry >*
message_decode_instr_reply::mutable_instrs() {
  // @@protoc_insertion_point(field_mutable_list:message_decode_instr_reply.instrs)
  return &instrs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::message_decode_instr_reply_instr_entry >&
message_decode_instr_reply::instrs() const {
  // @@protoc_insertion_point(field_list:message_decode_instr_reply.instrs)
  return instrs_;
}

// -------------------------------------------------------------------

// message_start_symb_exec

// required .message_start_symb_exec.trace_kind trace_type = 1;
inline bool message_start_symb_exec::has_trace_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void message_start_symb_exec::set_has_trace_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void message_start_symb_exec::clear_has_trace_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void message_start_symb_exec::clear_trace_type() {
  trace_type_ = 1;
  clear_has_trace_type();
}
inline ::message_start_symb_exec_trace_kind message_start_symb_exec::trace_type() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.trace_type)
  return static_cast< ::message_start_symb_exec_trace_kind >(trace_type_);
}
inline void message_start_symb_exec::set_trace_type(::message_start_symb_exec_trace_kind value) {
  assert(::message_start_symb_exec_trace_kind_IsValid(value));
  set_has_trace_type();
  trace_type_ = value;
  // @@protoc_insertion_point(field_set:message_start_symb_exec.trace_type)
}

// required string name = 2;
inline bool message_start_symb_exec::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_start_symb_exec::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void message_start_symb_exec::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void message_start_symb_exec::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& message_start_symb_exec::name() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.name)
  return name_.GetNoArena();
}
inline void message_start_symb_exec::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message_start_symb_exec.name)
}
#if LANG_CXX11
inline void message_start_symb_exec::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message_start_symb_exec.name)
}
#endif
inline void message_start_symb_exec::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message_start_symb_exec.name)
}
inline void message_start_symb_exec::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message_start_symb_exec.name)
}
inline ::std::string* message_start_symb_exec::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:message_start_symb_exec.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* message_start_symb_exec::release_name() {
  // @@protoc_insertion_point(field_release:message_start_symb_exec.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void message_start_symb_exec::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:message_start_symb_exec.name)
}

// optional .common.solver_t solver = 3 [default = Z3];
inline bool message_start_symb_exec::has_solver() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void message_start_symb_exec::set_has_solver() {
  _has_bits_[0] |= 0x00000800u;
}
inline void message_start_symb_exec::clear_has_solver() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void message_start_symb_exec::clear_solver() {
  solver_ = 1;
  clear_has_solver();
}
inline ::common::solver_t message_start_symb_exec::solver() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.solver)
  return static_cast< ::common::solver_t >(solver_);
}
inline void message_start_symb_exec::set_solver(::common::solver_t value) {
  assert(::common::solver_t_IsValid(value));
  set_has_solver();
  solver_ = value;
  // @@protoc_insertion_point(field_set:message_start_symb_exec.solver)
}

// optional .configuration.configuration config = 4;
inline bool message_start_symb_exec::has_config() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void message_start_symb_exec::set_has_config() {
  _has_bits_[0] |= 0x00000008u;
}
inline void message_start_symb_exec::clear_has_config() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void message_start_symb_exec::clear_config() {
  if (config_ != NULL) config_->::configuration::configuration::Clear();
  clear_has_config();
}
inline const ::configuration::configuration& message_start_symb_exec::config() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.config)
  return config_ != NULL ? *config_
                         : *::configuration::configuration::internal_default_instance();
}
inline ::configuration::configuration* message_start_symb_exec::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::configuration::configuration;
  }
  // @@protoc_insertion_point(field_mutable:message_start_symb_exec.config)
  return config_;
}
inline ::configuration::configuration* message_start_symb_exec::release_config() {
  // @@protoc_insertion_point(field_release:message_start_symb_exec.config)
  clear_has_config();
  ::configuration::configuration* temp = config_;
  config_ = NULL;
  return temp;
}
inline void message_start_symb_exec::set_allocated_config(::configuration::configuration* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:message_start_symb_exec.config)
}

// optional .common.ir_kind_t irkind = 5 [default = DBA];
inline bool message_start_symb_exec::has_irkind() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void message_start_symb_exec::set_has_irkind() {
  _has_bits_[0] |= 0x00000200u;
}
inline void message_start_symb_exec::clear_has_irkind() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void message_start_symb_exec::clear_irkind() {
  irkind_ = 1;
  clear_has_irkind();
}
inline ::common::ir_kind_t message_start_symb_exec::irkind() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.irkind)
  return static_cast< ::common::ir_kind_t >(irkind_);
}
inline void message_start_symb_exec::set_irkind(::common::ir_kind_t value) {
  assert(::common::ir_kind_t_IsValid(value));
  set_has_irkind();
  irkind_ = value;
  // @@protoc_insertion_point(field_set:message_start_symb_exec.irkind)
}

// optional bool formula_optim_cstfold = 6;
inline bool message_start_symb_exec::has_formula_optim_cstfold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void message_start_symb_exec::set_has_formula_optim_cstfold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void message_start_symb_exec::clear_has_formula_optim_cstfold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void message_start_symb_exec::clear_formula_optim_cstfold() {
  formula_optim_cstfold_ = false;
  clear_has_formula_optim_cstfold();
}
inline bool message_start_symb_exec::formula_optim_cstfold() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.formula_optim_cstfold)
  return formula_optim_cstfold_;
}
inline void message_start_symb_exec::set_formula_optim_cstfold(bool value) {
  set_has_formula_optim_cstfold();
  formula_optim_cstfold_ = value;
  // @@protoc_insertion_point(field_set:message_start_symb_exec.formula_optim_cstfold)
}

// optional bool formula_optim_rebase = 7;
inline bool message_start_symb_exec::has_formula_optim_rebase() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void message_start_symb_exec::set_has_formula_optim_rebase() {
  _has_bits_[0] |= 0x00000020u;
}
inline void message_start_symb_exec::clear_has_formula_optim_rebase() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void message_start_symb_exec::clear_formula_optim_rebase() {
  formula_optim_rebase_ = false;
  clear_has_formula_optim_rebase();
}
inline bool message_start_symb_exec::formula_optim_rebase() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.formula_optim_rebase)
  return formula_optim_rebase_;
}
inline void message_start_symb_exec::set_formula_optim_rebase(bool value) {
  set_has_formula_optim_rebase();
  formula_optim_rebase_ = value;
  // @@protoc_insertion_point(field_set:message_start_symb_exec.formula_optim_rebase)
}

// optional bool formula_optim_row = 8;
inline bool message_start_symb_exec::has_formula_optim_row() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void message_start_symb_exec::set_has_formula_optim_row() {
  _has_bits_[0] |= 0x00000040u;
}
inline void message_start_symb_exec::clear_has_formula_optim_row() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void message_start_symb_exec::clear_formula_optim_row() {
  formula_optim_row_ = false;
  clear_has_formula_optim_row();
}
inline bool message_start_symb_exec::formula_optim_row() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.formula_optim_row)
  return formula_optim_row_;
}
inline void message_start_symb_exec::set_formula_optim_row(bool value) {
  set_has_formula_optim_row();
  formula_optim_row_ = value;
  // @@protoc_insertion_point(field_set:message_start_symb_exec.formula_optim_row)
}

// required uint32 verbose = 9;
inline bool message_start_symb_exec::has_verbose() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void message_start_symb_exec::set_has_verbose() {
  _has_bits_[0] |= 0x00000080u;
}
inline void message_start_symb_exec::clear_has_verbose() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void message_start_symb_exec::clear_verbose() {
  verbose_ = 0u;
  clear_has_verbose();
}
inline ::google::protobuf::uint32 message_start_symb_exec::verbose() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.verbose)
  return verbose_;
}
inline void message_start_symb_exec::set_verbose(::google::protobuf::uint32 value) {
  set_has_verbose();
  verbose_ = value;
  // @@protoc_insertion_point(field_set:message_start_symb_exec.verbose)
}

// optional uint64 addr_predicate = 10;
inline bool message_start_symb_exec::has_addr_predicate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void message_start_symb_exec::set_has_addr_predicate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void message_start_symb_exec::clear_has_addr_predicate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void message_start_symb_exec::clear_addr_predicate() {
  addr_predicate_ = GOOGLE_ULONGLONG(0);
  clear_has_addr_predicate();
}
inline ::google::protobuf::uint64 message_start_symb_exec::addr_predicate() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.addr_predicate)
  return addr_predicate_;
}
inline void message_start_symb_exec::set_addr_predicate(::google::protobuf::uint64 value) {
  set_has_addr_predicate();
  addr_predicate_ = value;
  // @@protoc_insertion_point(field_set:message_start_symb_exec.addr_predicate)
}

// optional string predicate = 11;
inline bool message_start_symb_exec::has_predicate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void message_start_symb_exec::set_has_predicate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void message_start_symb_exec::clear_has_predicate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void message_start_symb_exec::clear_predicate() {
  predicate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_predicate();
}
inline const ::std::string& message_start_symb_exec::predicate() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.predicate)
  return predicate_.GetNoArena();
}
inline void message_start_symb_exec::set_predicate(const ::std::string& value) {
  set_has_predicate();
  predicate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message_start_symb_exec.predicate)
}
#if LANG_CXX11
inline void message_start_symb_exec::set_predicate(::std::string&& value) {
  set_has_predicate();
  predicate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message_start_symb_exec.predicate)
}
#endif
inline void message_start_symb_exec::set_predicate(const char* value) {
  set_has_predicate();
  predicate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message_start_symb_exec.predicate)
}
inline void message_start_symb_exec::set_predicate(const char* value, size_t size) {
  set_has_predicate();
  predicate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message_start_symb_exec.predicate)
}
inline ::std::string* message_start_symb_exec::mutable_predicate() {
  set_has_predicate();
  // @@protoc_insertion_point(field_mutable:message_start_symb_exec.predicate)
  return predicate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* message_start_symb_exec::release_predicate() {
  // @@protoc_insertion_point(field_release:message_start_symb_exec.predicate)
  clear_has_predicate();
  return predicate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void message_start_symb_exec::set_allocated_predicate(::std::string* predicate) {
  if (predicate != NULL) {
    set_has_predicate();
  } else {
    clear_has_predicate();
  }
  predicate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), predicate);
  // @@protoc_insertion_point(field_set_allocated:message_start_symb_exec.predicate)
}

// optional string trace_filename = 12;
inline bool message_start_symb_exec::has_trace_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void message_start_symb_exec::set_has_trace_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void message_start_symb_exec::clear_has_trace_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void message_start_symb_exec::clear_trace_filename() {
  trace_filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_trace_filename();
}
inline const ::std::string& message_start_symb_exec::trace_filename() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.trace_filename)
  return trace_filename_.GetNoArena();
}
inline void message_start_symb_exec::set_trace_filename(const ::std::string& value) {
  set_has_trace_filename();
  trace_filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message_start_symb_exec.trace_filename)
}
#if LANG_CXX11
inline void message_start_symb_exec::set_trace_filename(::std::string&& value) {
  set_has_trace_filename();
  trace_filename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message_start_symb_exec.trace_filename)
}
#endif
inline void message_start_symb_exec::set_trace_filename(const char* value) {
  set_has_trace_filename();
  trace_filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message_start_symb_exec.trace_filename)
}
inline void message_start_symb_exec::set_trace_filename(const char* value, size_t size) {
  set_has_trace_filename();
  trace_filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message_start_symb_exec.trace_filename)
}
inline ::std::string* message_start_symb_exec::mutable_trace_filename() {
  set_has_trace_filename();
  // @@protoc_insertion_point(field_mutable:message_start_symb_exec.trace_filename)
  return trace_filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* message_start_symb_exec::release_trace_filename() {
  // @@protoc_insertion_point(field_release:message_start_symb_exec.trace_filename)
  clear_has_trace_filename();
  return trace_filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void message_start_symb_exec::set_allocated_trace_filename(::std::string* trace_filename) {
  if (trace_filename != NULL) {
    set_has_trace_filename();
  } else {
    clear_has_trace_filename();
  }
  trace_filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trace_filename);
  // @@protoc_insertion_point(field_set_allocated:message_start_symb_exec.trace_filename)
}

// -------------------------------------------------------------------

// message_output

// required .message_output.output_kind type = 1;
inline bool message_output::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void message_output::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void message_output::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void message_output::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::message_output_output_kind message_output::type() const {
  // @@protoc_insertion_point(field_get:message_output.type)
  return static_cast< ::message_output_output_kind >(type_);
}
inline void message_output::set_type(::message_output_output_kind value) {
  assert(::message_output_output_kind_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:message_output.type)
}

// required string message = 2;
inline bool message_output::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_output::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void message_output::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void message_output::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& message_output::message() const {
  // @@protoc_insertion_point(field_get:message_output.message)
  return message_.GetNoArena();
}
inline void message_output::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message_output.message)
}
#if LANG_CXX11
inline void message_output::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message_output.message)
}
#endif
inline void message_output::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message_output.message)
}
inline void message_output::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message_output.message)
}
inline ::std::string* message_output::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:message_output.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* message_output::release_message() {
  // @@protoc_insertion_point(field_release:message_output.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void message_output::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:message_output.message)
}

// optional uint32 ram_total = 3;
inline bool message_output::has_ram_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void message_output::set_has_ram_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void message_output::clear_has_ram_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void message_output::clear_ram_total() {
  ram_total_ = 0u;
  clear_has_ram_total();
}
inline ::google::protobuf::uint32 message_output::ram_total() const {
  // @@protoc_insertion_point(field_get:message_output.ram_total)
  return ram_total_;
}
inline void message_output::set_ram_total(::google::protobuf::uint32 value) {
  set_has_ram_total();
  ram_total_ = value;
  // @@protoc_insertion_point(field_set:message_output.ram_total)
}

// optional uint32 ram_free = 4;
inline bool message_output::has_ram_free() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void message_output::set_has_ram_free() {
  _has_bits_[0] |= 0x00000004u;
}
inline void message_output::clear_has_ram_free() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void message_output::clear_ram_free() {
  ram_free_ = 0u;
  clear_has_ram_free();
}
inline ::google::protobuf::uint32 message_output::ram_free() const {
  // @@protoc_insertion_point(field_get:message_output.ram_free)
  return ram_free_;
}
inline void message_output::set_ram_free(::google::protobuf::uint32 value) {
  set_has_ram_free();
  ram_free_ = value;
  // @@protoc_insertion_point(field_set:message_output.ram_free)
}

// optional uint32 ram_available = 5;
inline bool message_output::has_ram_available() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void message_output::set_has_ram_available() {
  _has_bits_[0] |= 0x00000008u;
}
inline void message_output::clear_has_ram_available() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void message_output::clear_ram_available() {
  ram_available_ = 0u;
  clear_has_ram_available();
}
inline ::google::protobuf::uint32 message_output::ram_available() const {
  // @@protoc_insertion_point(field_get:message_output.ram_available)
  return ram_available_;
}
inline void message_output::set_ram_available(::google::protobuf::uint32 value) {
  set_has_ram_available();
  ram_available_ = value;
  // @@protoc_insertion_point(field_set:message_output.ram_available)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::message_decode_instr_bin_kind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message_decode_instr_bin_kind>() {
  return ::message_decode_instr_bin_kind_descriptor();
}
template <> struct is_proto_enum< ::message_start_symb_exec_trace_kind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message_start_symb_exec_trace_kind>() {
  return ::message_start_symb_exec_trace_kind_descriptor();
}
template <> struct is_proto_enum< ::message_output_output_kind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message_output_output_kind>() {
  return ::message_output_output_kind_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
