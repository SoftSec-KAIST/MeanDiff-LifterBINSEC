// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: libcall.proto

#ifndef PROTOBUF_libcall_2eproto__INCLUDED
#define PROTOBUF_libcall_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
namespace common {
class indirect_register_t;
class indirect_register_tDefaultTypeInternal;
extern indirect_register_tDefaultTypeInternal _indirect_register_t_default_instance_;
class memory_pol;
class memory_polDefaultTypeInternal;
extern memory_polDefaultTypeInternal _memory_pol_default_instance_;
class memory_t;
class memory_tDefaultTypeInternal;
extern memory_tDefaultTypeInternal _memory_t_default_instance_;
class register_t;
class register_tDefaultTypeInternal;
extern register_tDefaultTypeInternal _register_t_default_instance_;
class register_value_t;
class register_value_tDefaultTypeInternal;
extern register_value_tDefaultTypeInternal _register_value_t_default_instance_;
}  // namespace common
namespace libcall_types {
class atoi_pol;
class atoi_polDefaultTypeInternal;
extern atoi_polDefaultTypeInternal _atoi_pol_default_instance_;
class atoi_t;
class atoi_tDefaultTypeInternal;
extern atoi_tDefaultTypeInternal _atoi_t_default_instance_;
class bsearch_pol;
class bsearch_polDefaultTypeInternal;
extern bsearch_polDefaultTypeInternal _bsearch_pol_default_instance_;
class bsearch_t;
class bsearch_tDefaultTypeInternal;
extern bsearch_tDefaultTypeInternal _bsearch_t_default_instance_;
class ctype_b_loc_pol;
class ctype_b_loc_polDefaultTypeInternal;
extern ctype_b_loc_polDefaultTypeInternal _ctype_b_loc_pol_default_instance_;
class ctype_b_loc_t;
class ctype_b_loc_tDefaultTypeInternal;
extern ctype_b_loc_tDefaultTypeInternal _ctype_b_loc_t_default_instance_;
class exit_pol;
class exit_polDefaultTypeInternal;
extern exit_polDefaultTypeInternal _exit_pol_default_instance_;
class exit_t;
class exit_tDefaultTypeInternal;
extern exit_tDefaultTypeInternal _exit_t_default_instance_;
class fgetc_pol;
class fgetc_polDefaultTypeInternal;
extern fgetc_polDefaultTypeInternal _fgetc_pol_default_instance_;
class fgetc_t;
class fgetc_tDefaultTypeInternal;
extern fgetc_tDefaultTypeInternal _fgetc_t_default_instance_;
class fread_pol;
class fread_polDefaultTypeInternal;
extern fread_polDefaultTypeInternal _fread_pol_default_instance_;
class fread_t;
class fread_tDefaultTypeInternal;
extern fread_tDefaultTypeInternal _fread_t_default_instance_;
class free_pol;
class free_polDefaultTypeInternal;
extern free_polDefaultTypeInternal _free_pol_default_instance_;
class free_t;
class free_tDefaultTypeInternal;
extern free_tDefaultTypeInternal _free_t_default_instance_;
class fscanf_elem_t;
class fscanf_elem_tDefaultTypeInternal;
extern fscanf_elem_tDefaultTypeInternal _fscanf_elem_t_default_instance_;
class fscanf_pol;
class fscanf_polDefaultTypeInternal;
extern fscanf_polDefaultTypeInternal _fscanf_pol_default_instance_;
class fscanf_t;
class fscanf_tDefaultTypeInternal;
extern fscanf_tDefaultTypeInternal _fscanf_t_default_instance_;
class fstat_pol;
class fstat_polDefaultTypeInternal;
extern fstat_polDefaultTypeInternal _fstat_pol_default_instance_;
class fstat_t;
class fstat_tDefaultTypeInternal;
extern fstat_tDefaultTypeInternal _fstat_t_default_instance_;
class fxstat64_pol;
class fxstat64_polDefaultTypeInternal;
extern fxstat64_polDefaultTypeInternal _fxstat64_pol_default_instance_;
class fxstat64_t;
class fxstat64_tDefaultTypeInternal;
extern fxstat64_tDefaultTypeInternal _fxstat64_t_default_instance_;
class generic_pol;
class generic_polDefaultTypeInternal;
extern generic_polDefaultTypeInternal _generic_pol_default_instance_;
class generic_t;
class generic_tDefaultTypeInternal;
extern generic_tDefaultTypeInternal _generic_t_default_instance_;
class gethostname_pol;
class gethostname_polDefaultTypeInternal;
extern gethostname_polDefaultTypeInternal _gethostname_pol_default_instance_;
class gethostname_t;
class gethostname_tDefaultTypeInternal;
extern gethostname_tDefaultTypeInternal _gethostname_t_default_instance_;
class getmainargs_pol;
class getmainargs_polDefaultTypeInternal;
extern getmainargs_polDefaultTypeInternal _getmainargs_pol_default_instance_;
class getmainargs_t;
class getmainargs_tDefaultTypeInternal;
extern getmainargs_tDefaultTypeInternal _getmainargs_t_default_instance_;
class getmodulehandle_pol;
class getmodulehandle_polDefaultTypeInternal;
extern getmodulehandle_polDefaultTypeInternal _getmodulehandle_pol_default_instance_;
class getmodulehandle_t;
class getmodulehandle_tDefaultTypeInternal;
extern getmodulehandle_tDefaultTypeInternal _getmodulehandle_t_default_instance_;
class getprocaddress_pol;
class getprocaddress_polDefaultTypeInternal;
extern getprocaddress_polDefaultTypeInternal _getprocaddress_pol_default_instance_;
class getprocaddress_t;
class getprocaddress_tDefaultTypeInternal;
extern getprocaddress_tDefaultTypeInternal _getprocaddress_t_default_instance_;
class libcall_pol;
class libcall_polDefaultTypeInternal;
extern libcall_polDefaultTypeInternal _libcall_pol_default_instance_;
class libcall_t;
class libcall_tDefaultTypeInternal;
extern libcall_tDefaultTypeInternal _libcall_t_default_instance_;
class lseek_pol;
class lseek_polDefaultTypeInternal;
extern lseek_polDefaultTypeInternal _lseek_pol_default_instance_;
class lseek_t;
class lseek_tDefaultTypeInternal;
extern lseek_tDefaultTypeInternal _lseek_t_default_instance_;
class malloc_pol;
class malloc_polDefaultTypeInternal;
extern malloc_polDefaultTypeInternal _malloc_pol_default_instance_;
class malloc_t;
class malloc_tDefaultTypeInternal;
extern malloc_tDefaultTypeInternal _malloc_t_default_instance_;
class memcmp_pol;
class memcmp_polDefaultTypeInternal;
extern memcmp_polDefaultTypeInternal _memcmp_pol_default_instance_;
class memcmp_t;
class memcmp_tDefaultTypeInternal;
extern memcmp_tDefaultTypeInternal _memcmp_t_default_instance_;
class memcpy_pol;
class memcpy_polDefaultTypeInternal;
extern memcpy_polDefaultTypeInternal _memcpy_pol_default_instance_;
class memcpy_t;
class memcpy_tDefaultTypeInternal;
extern memcpy_tDefaultTypeInternal _memcpy_t_default_instance_;
class memset_pol;
class memset_polDefaultTypeInternal;
extern memset_polDefaultTypeInternal _memset_pol_default_instance_;
class memset_t;
class memset_tDefaultTypeInternal;
extern memset_tDefaultTypeInternal _memset_t_default_instance_;
class mmap_pol;
class mmap_polDefaultTypeInternal;
extern mmap_polDefaultTypeInternal _mmap_pol_default_instance_;
class mmap_t;
class mmap_tDefaultTypeInternal;
extern mmap_tDefaultTypeInternal _mmap_t_default_instance_;
class open_pol;
class open_polDefaultTypeInternal;
extern open_polDefaultTypeInternal _open_pol_default_instance_;
class open_t;
class open_tDefaultTypeInternal;
extern open_tDefaultTypeInternal _open_t_default_instance_;
class printf_pol;
class printf_polDefaultTypeInternal;
extern printf_polDefaultTypeInternal _printf_pol_default_instance_;
class printf_t;
class printf_tDefaultTypeInternal;
extern printf_tDefaultTypeInternal _printf_t_default_instance_;
class qsort_pol;
class qsort_polDefaultTypeInternal;
extern qsort_polDefaultTypeInternal _qsort_pol_default_instance_;
class qsort_t;
class qsort_tDefaultTypeInternal;
extern qsort_tDefaultTypeInternal _qsort_t_default_instance_;
class read_pol;
class read_polDefaultTypeInternal;
extern read_polDefaultTypeInternal _read_pol_default_instance_;
class read_t;
class read_tDefaultTypeInternal;
extern read_tDefaultTypeInternal _read_t_default_instance_;
class realloc_pol;
class realloc_polDefaultTypeInternal;
extern realloc_polDefaultTypeInternal _realloc_pol_default_instance_;
class realloc_t;
class realloc_tDefaultTypeInternal;
extern realloc_tDefaultTypeInternal _realloc_t_default_instance_;
class strchr_pol;
class strchr_polDefaultTypeInternal;
extern strchr_polDefaultTypeInternal _strchr_pol_default_instance_;
class strchr_t;
class strchr_tDefaultTypeInternal;
extern strchr_tDefaultTypeInternal _strchr_t_default_instance_;
class strcmp_pol;
class strcmp_polDefaultTypeInternal;
extern strcmp_polDefaultTypeInternal _strcmp_pol_default_instance_;
class strcmp_t;
class strcmp_tDefaultTypeInternal;
extern strcmp_tDefaultTypeInternal _strcmp_t_default_instance_;
class strcpy_pol;
class strcpy_polDefaultTypeInternal;
extern strcpy_polDefaultTypeInternal _strcpy_pol_default_instance_;
class strcpy_t;
class strcpy_tDefaultTypeInternal;
extern strcpy_tDefaultTypeInternal _strcpy_t_default_instance_;
class strncmp_pol;
class strncmp_polDefaultTypeInternal;
extern strncmp_polDefaultTypeInternal _strncmp_pol_default_instance_;
class strncmp_t;
class strncmp_tDefaultTypeInternal;
extern strncmp_tDefaultTypeInternal _strncmp_t_default_instance_;
class strncpy_pol;
class strncpy_polDefaultTypeInternal;
extern strncpy_polDefaultTypeInternal _strncpy_pol_default_instance_;
class strncpy_t;
class strncpy_tDefaultTypeInternal;
extern strncpy_tDefaultTypeInternal _strncpy_t_default_instance_;
}  // namespace libcall_types

namespace libcall_types {

namespace protobuf_libcall_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_libcall_2eproto

enum lib_ident {
  INVALID = 0,
  PRINTF = 1,
  STRCPY = 2,
  ATOI = 3,
  MALLOC = 4,
  FREE = 5,
  MEMCPY = 6,
  MEMSET = 7,
  FGETC = 8,
  READ = 9,
  STRCHR = 10,
  EXIT = 11,
  STRCMP = 12,
  CTYPE_B_LOC = 13,
  FSCANF = 14,
  STRRCHR = 15,
  STRNCPY = 16,
  FSTAT = 17,
  REALLOC = 18,
  MMAP = 19,
  QSORT = 20,
  BSEARCH = 21,
  OPEN_STUB = 22,
  LSEEK = 23,
  FREAD = 24,
  STRNCMP = 25,
  MEMCMP = 26,
  FXSTAT64 = 27,
  GETMODULEHANDLE = 100,
  GETPROCADDRESS = 101,
  GETMAINARGS = 102,
  GETHOSTNAME = 103,
  GENERIC = 255
};
bool lib_ident_IsValid(int value);
const lib_ident lib_ident_MIN = INVALID;
const lib_ident lib_ident_MAX = GENERIC;
const int lib_ident_ARRAYSIZE = lib_ident_MAX + 1;

const ::google::protobuf::EnumDescriptor* lib_ident_descriptor();
inline const ::std::string& lib_ident_Name(lib_ident value) {
  return ::google::protobuf::internal::NameOfEnum(
    lib_ident_descriptor(), value);
}
inline bool lib_ident_Parse(
    const ::std::string& name, lib_ident* value) {
  return ::google::protobuf::internal::ParseNamedEnum<lib_ident>(
    lib_ident_descriptor(), name, value);
}
enum fscanf_enum {
  d = 0,
  dd = 1,
  i = 2,
  o = 3,
  u = 4,
  x = 5,
  xx = 6,
  f = 7,
  e = 8,
  g = 9,
  ee = 10,
  a = 11,
  s = 12,
  c = 13,
  sb = 14,
  p = 15,
  n = 16
};
bool fscanf_enum_IsValid(int value);
const fscanf_enum fscanf_enum_MIN = d;
const fscanf_enum fscanf_enum_MAX = n;
const int fscanf_enum_ARRAYSIZE = fscanf_enum_MAX + 1;

const ::google::protobuf::EnumDescriptor* fscanf_enum_descriptor();
inline const ::std::string& fscanf_enum_Name(fscanf_enum value) {
  return ::google::protobuf::internal::NameOfEnum(
    fscanf_enum_descriptor(), value);
}
inline bool fscanf_enum_Parse(
    const ::std::string& name, fscanf_enum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<fscanf_enum>(
    fscanf_enum_descriptor(), name, value);
}
// ===================================================================

class libcall_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.libcall_pol) */ {
 public:
  libcall_pol();
  virtual ~libcall_pol();

  libcall_pol(const libcall_pol& from);

  inline libcall_pol& operator=(const libcall_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const libcall_pol& default_instance();

  enum LibcallCntCase {
    kStrcpy = 5,
    kPrintf = 6,
    kAtoi = 7,
    kMalloc = 8,
    kGetmodulehandle = 9,
    kGetprocaddress = 10,
    kGetmainargs = 11,
    kGethostname = 12,
    kFree = 13,
    kMemcpy = 14,
    kMemset = 15,
    kFgetc = 16,
    kRead = 17,
    kStrchr = 18,
    kExit = 19,
    kStrcmp = 20,
    kCtypeBLoc = 22,
    kFscanf = 23,
    kStrncpy = 24,
    kFstat = 25,
    kRealloc = 26,
    kMmap = 27,
    kQsort = 28,
    kBsearch = 29,
    kOpenStub = 30,
    kLseek = 31,
    kFread = 32,
    kStrncmp = 33,
    kMemcmp = 34,
    kFxstat64 = 35,
    kGeneric = 50,
    LIBCALL_CNT_NOT_SET = 0,
  };

  static inline const libcall_pol* internal_default_instance() {
    return reinterpret_cast<const libcall_pol*>(
               &_libcall_pol_default_instance_);
  }

  void Swap(libcall_pol* other);

  // implements Message ----------------------------------------------

  inline libcall_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  libcall_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const libcall_pol& from);
  void MergeFrom(const libcall_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(libcall_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 restrict_addresses = 4;
  int restrict_addresses_size() const;
  void clear_restrict_addresses();
  static const int kRestrictAddressesFieldNumber = 4;
  ::google::protobuf::uint64 restrict_addresses(int index) const;
  void set_restrict_addresses(int index, ::google::protobuf::uint64 value);
  void add_restrict_addresses(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      restrict_addresses() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_restrict_addresses();

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .common.tracing_action action = 3 [default = SKIP];
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 3;
  ::common::tracing_action action() const;
  void set_action(::common::tracing_action value);

  // optional .libcall_types.lib_ident ident = 2 [default = GENERIC];
  bool has_ident() const;
  void clear_ident();
  static const int kIdentFieldNumber = 2;
  ::libcall_types::lib_ident ident() const;
  void set_ident(::libcall_types::lib_ident value);

  // optional .libcall_types.strcpy_pol strcpy = 5;
  bool has_strcpy() const;
  void clear_strcpy();
  static const int kStrcpyFieldNumber = 5;
  const ::libcall_types::strcpy_pol& strcpy() const;
  ::libcall_types::strcpy_pol* mutable_strcpy();
  ::libcall_types::strcpy_pol* release_strcpy();
  void set_allocated_strcpy(::libcall_types::strcpy_pol* strcpy);

  // optional .libcall_types.printf_pol printf = 6;
  bool has_printf() const;
  void clear_printf();
  static const int kPrintfFieldNumber = 6;
  const ::libcall_types::printf_pol& printf() const;
  ::libcall_types::printf_pol* mutable_printf();
  ::libcall_types::printf_pol* release_printf();
  void set_allocated_printf(::libcall_types::printf_pol* printf);

  // optional .libcall_types.atoi_pol atoi = 7;
  bool has_atoi() const;
  void clear_atoi();
  static const int kAtoiFieldNumber = 7;
  const ::libcall_types::atoi_pol& atoi() const;
  ::libcall_types::atoi_pol* mutable_atoi();
  ::libcall_types::atoi_pol* release_atoi();
  void set_allocated_atoi(::libcall_types::atoi_pol* atoi);

  // optional .libcall_types.malloc_pol malloc = 8;
  bool has_malloc() const;
  void clear_malloc();
  static const int kMallocFieldNumber = 8;
  const ::libcall_types::malloc_pol& malloc() const;
  ::libcall_types::malloc_pol* mutable_malloc();
  ::libcall_types::malloc_pol* release_malloc();
  void set_allocated_malloc(::libcall_types::malloc_pol* malloc);

  // optional .libcall_types.getmodulehandle_pol getmodulehandle = 9;
  bool has_getmodulehandle() const;
  void clear_getmodulehandle();
  static const int kGetmodulehandleFieldNumber = 9;
  const ::libcall_types::getmodulehandle_pol& getmodulehandle() const;
  ::libcall_types::getmodulehandle_pol* mutable_getmodulehandle();
  ::libcall_types::getmodulehandle_pol* release_getmodulehandle();
  void set_allocated_getmodulehandle(::libcall_types::getmodulehandle_pol* getmodulehandle);

  // optional .libcall_types.getprocaddress_pol getprocaddress = 10;
  bool has_getprocaddress() const;
  void clear_getprocaddress();
  static const int kGetprocaddressFieldNumber = 10;
  const ::libcall_types::getprocaddress_pol& getprocaddress() const;
  ::libcall_types::getprocaddress_pol* mutable_getprocaddress();
  ::libcall_types::getprocaddress_pol* release_getprocaddress();
  void set_allocated_getprocaddress(::libcall_types::getprocaddress_pol* getprocaddress);

  // optional .libcall_types.getmainargs_pol getmainargs = 11;
  bool has_getmainargs() const;
  void clear_getmainargs();
  static const int kGetmainargsFieldNumber = 11;
  const ::libcall_types::getmainargs_pol& getmainargs() const;
  ::libcall_types::getmainargs_pol* mutable_getmainargs();
  ::libcall_types::getmainargs_pol* release_getmainargs();
  void set_allocated_getmainargs(::libcall_types::getmainargs_pol* getmainargs);

  // optional .libcall_types.gethostname_pol gethostname = 12;
  bool has_gethostname() const;
  void clear_gethostname();
  static const int kGethostnameFieldNumber = 12;
  const ::libcall_types::gethostname_pol& gethostname() const;
  ::libcall_types::gethostname_pol* mutable_gethostname();
  ::libcall_types::gethostname_pol* release_gethostname();
  void set_allocated_gethostname(::libcall_types::gethostname_pol* gethostname);

  // optional .libcall_types.free_pol free = 13;
  bool has_free() const;
  void clear_free();
  static const int kFreeFieldNumber = 13;
  const ::libcall_types::free_pol& free() const;
  ::libcall_types::free_pol* mutable_free();
  ::libcall_types::free_pol* release_free();
  void set_allocated_free(::libcall_types::free_pol* free);

  // optional .libcall_types.memcpy_pol memcpy = 14;
  bool has_memcpy() const;
  void clear_memcpy();
  static const int kMemcpyFieldNumber = 14;
  const ::libcall_types::memcpy_pol& memcpy() const;
  ::libcall_types::memcpy_pol* mutable_memcpy();
  ::libcall_types::memcpy_pol* release_memcpy();
  void set_allocated_memcpy(::libcall_types::memcpy_pol* memcpy);

  // optional .libcall_types.memset_pol memset = 15;
  bool has_memset() const;
  void clear_memset();
  static const int kMemsetFieldNumber = 15;
  const ::libcall_types::memset_pol& memset() const;
  ::libcall_types::memset_pol* mutable_memset();
  ::libcall_types::memset_pol* release_memset();
  void set_allocated_memset(::libcall_types::memset_pol* memset);

  // optional .libcall_types.fgetc_pol fgetc = 16;
  bool has_fgetc() const;
  void clear_fgetc();
  static const int kFgetcFieldNumber = 16;
  const ::libcall_types::fgetc_pol& fgetc() const;
  ::libcall_types::fgetc_pol* mutable_fgetc();
  ::libcall_types::fgetc_pol* release_fgetc();
  void set_allocated_fgetc(::libcall_types::fgetc_pol* fgetc);

  // optional .libcall_types.read_pol read = 17;
  bool has_read() const;
  void clear_read();
  static const int kReadFieldNumber = 17;
  const ::libcall_types::read_pol& read() const;
  ::libcall_types::read_pol* mutable_read();
  ::libcall_types::read_pol* release_read();
  void set_allocated_read(::libcall_types::read_pol* read);

  // optional .libcall_types.strchr_pol strchr = 18;
  bool has_strchr() const;
  void clear_strchr();
  static const int kStrchrFieldNumber = 18;
  const ::libcall_types::strchr_pol& strchr() const;
  ::libcall_types::strchr_pol* mutable_strchr();
  ::libcall_types::strchr_pol* release_strchr();
  void set_allocated_strchr(::libcall_types::strchr_pol* strchr);

  // optional .libcall_types.exit_pol exit = 19;
  bool has_exit() const;
  void clear_exit();
  static const int kExitFieldNumber = 19;
  const ::libcall_types::exit_pol& exit() const;
  ::libcall_types::exit_pol* mutable_exit();
  ::libcall_types::exit_pol* release_exit();
  void set_allocated_exit(::libcall_types::exit_pol* exit);

  // optional .libcall_types.strcmp_pol strcmp = 20;
  bool has_strcmp() const;
  void clear_strcmp();
  static const int kStrcmpFieldNumber = 20;
  const ::libcall_types::strcmp_pol& strcmp() const;
  ::libcall_types::strcmp_pol* mutable_strcmp();
  ::libcall_types::strcmp_pol* release_strcmp();
  void set_allocated_strcmp(::libcall_types::strcmp_pol* strcmp);

  // optional .libcall_types.ctype_b_loc_pol ctype_b_loc = 22;
  bool has_ctype_b_loc() const;
  void clear_ctype_b_loc();
  static const int kCtypeBLocFieldNumber = 22;
  const ::libcall_types::ctype_b_loc_pol& ctype_b_loc() const;
  ::libcall_types::ctype_b_loc_pol* mutable_ctype_b_loc();
  ::libcall_types::ctype_b_loc_pol* release_ctype_b_loc();
  void set_allocated_ctype_b_loc(::libcall_types::ctype_b_loc_pol* ctype_b_loc);

  // optional .libcall_types.fscanf_pol fscanf = 23;
  bool has_fscanf() const;
  void clear_fscanf();
  static const int kFscanfFieldNumber = 23;
  const ::libcall_types::fscanf_pol& fscanf() const;
  ::libcall_types::fscanf_pol* mutable_fscanf();
  ::libcall_types::fscanf_pol* release_fscanf();
  void set_allocated_fscanf(::libcall_types::fscanf_pol* fscanf);

  // optional .libcall_types.strncpy_pol strncpy = 24;
  bool has_strncpy() const;
  void clear_strncpy();
  static const int kStrncpyFieldNumber = 24;
  const ::libcall_types::strncpy_pol& strncpy() const;
  ::libcall_types::strncpy_pol* mutable_strncpy();
  ::libcall_types::strncpy_pol* release_strncpy();
  void set_allocated_strncpy(::libcall_types::strncpy_pol* strncpy);

  // optional .libcall_types.fstat_pol fstat = 25;
  bool has_fstat() const;
  void clear_fstat();
  static const int kFstatFieldNumber = 25;
  const ::libcall_types::fstat_pol& fstat() const;
  ::libcall_types::fstat_pol* mutable_fstat();
  ::libcall_types::fstat_pol* release_fstat();
  void set_allocated_fstat(::libcall_types::fstat_pol* fstat);

  // optional .libcall_types.realloc_pol realloc = 26;
  bool has_realloc() const;
  void clear_realloc();
  static const int kReallocFieldNumber = 26;
  const ::libcall_types::realloc_pol& realloc() const;
  ::libcall_types::realloc_pol* mutable_realloc();
  ::libcall_types::realloc_pol* release_realloc();
  void set_allocated_realloc(::libcall_types::realloc_pol* realloc);

  // optional .libcall_types.mmap_pol mmap = 27;
  bool has_mmap() const;
  void clear_mmap();
  static const int kMmapFieldNumber = 27;
  const ::libcall_types::mmap_pol& mmap() const;
  ::libcall_types::mmap_pol* mutable_mmap();
  ::libcall_types::mmap_pol* release_mmap();
  void set_allocated_mmap(::libcall_types::mmap_pol* mmap);

  // optional .libcall_types.qsort_pol qsort = 28;
  bool has_qsort() const;
  void clear_qsort();
  static const int kQsortFieldNumber = 28;
  const ::libcall_types::qsort_pol& qsort() const;
  ::libcall_types::qsort_pol* mutable_qsort();
  ::libcall_types::qsort_pol* release_qsort();
  void set_allocated_qsort(::libcall_types::qsort_pol* qsort);

  // optional .libcall_types.bsearch_pol bsearch = 29;
  bool has_bsearch() const;
  void clear_bsearch();
  static const int kBsearchFieldNumber = 29;
  const ::libcall_types::bsearch_pol& bsearch() const;
  ::libcall_types::bsearch_pol* mutable_bsearch();
  ::libcall_types::bsearch_pol* release_bsearch();
  void set_allocated_bsearch(::libcall_types::bsearch_pol* bsearch);

  // optional .libcall_types.open_pol open_stub = 30;
  bool has_open_stub() const;
  void clear_open_stub();
  static const int kOpenStubFieldNumber = 30;
  const ::libcall_types::open_pol& open_stub() const;
  ::libcall_types::open_pol* mutable_open_stub();
  ::libcall_types::open_pol* release_open_stub();
  void set_allocated_open_stub(::libcall_types::open_pol* open_stub);

  // optional .libcall_types.lseek_pol lseek = 31;
  bool has_lseek() const;
  void clear_lseek();
  static const int kLseekFieldNumber = 31;
  const ::libcall_types::lseek_pol& lseek() const;
  ::libcall_types::lseek_pol* mutable_lseek();
  ::libcall_types::lseek_pol* release_lseek();
  void set_allocated_lseek(::libcall_types::lseek_pol* lseek);

  // optional .libcall_types.fread_pol fread = 32;
  bool has_fread() const;
  void clear_fread();
  static const int kFreadFieldNumber = 32;
  const ::libcall_types::fread_pol& fread() const;
  ::libcall_types::fread_pol* mutable_fread();
  ::libcall_types::fread_pol* release_fread();
  void set_allocated_fread(::libcall_types::fread_pol* fread);

  // optional .libcall_types.strncmp_pol strncmp = 33;
  bool has_strncmp() const;
  void clear_strncmp();
  static const int kStrncmpFieldNumber = 33;
  const ::libcall_types::strncmp_pol& strncmp() const;
  ::libcall_types::strncmp_pol* mutable_strncmp();
  ::libcall_types::strncmp_pol* release_strncmp();
  void set_allocated_strncmp(::libcall_types::strncmp_pol* strncmp);

  // optional .libcall_types.memcmp_pol memcmp = 34;
  bool has_memcmp() const;
  void clear_memcmp();
  static const int kMemcmpFieldNumber = 34;
  const ::libcall_types::memcmp_pol& memcmp() const;
  ::libcall_types::memcmp_pol* mutable_memcmp();
  ::libcall_types::memcmp_pol* release_memcmp();
  void set_allocated_memcmp(::libcall_types::memcmp_pol* memcmp);

  // optional .libcall_types.fxstat64_pol fxstat64 = 35;
  bool has_fxstat64() const;
  void clear_fxstat64();
  static const int kFxstat64FieldNumber = 35;
  const ::libcall_types::fxstat64_pol& fxstat64() const;
  ::libcall_types::fxstat64_pol* mutable_fxstat64();
  ::libcall_types::fxstat64_pol* release_fxstat64();
  void set_allocated_fxstat64(::libcall_types::fxstat64_pol* fxstat64);

  // optional .libcall_types.generic_pol generic = 50;
  bool has_generic() const;
  void clear_generic();
  static const int kGenericFieldNumber = 50;
  const ::libcall_types::generic_pol& generic() const;
  ::libcall_types::generic_pol* mutable_generic();
  ::libcall_types::generic_pol* release_generic();
  void set_allocated_generic(::libcall_types::generic_pol* generic);

  LibcallCntCase libcall_cnt_case() const;
  // @@protoc_insertion_point(class_scope:libcall_types.libcall_pol)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_ident();
  void clear_has_ident();
  void set_has_action();
  void clear_has_action();
  void set_has_strcpy();
  void set_has_printf();
  void set_has_atoi();
  void set_has_malloc();
  void set_has_getmodulehandle();
  void set_has_getprocaddress();
  void set_has_getmainargs();
  void set_has_gethostname();
  void set_has_free();
  void set_has_memcpy();
  void set_has_memset();
  void set_has_fgetc();
  void set_has_read();
  void set_has_strchr();
  void set_has_exit();
  void set_has_strcmp();
  void set_has_ctype_b_loc();
  void set_has_fscanf();
  void set_has_strncpy();
  void set_has_fstat();
  void set_has_realloc();
  void set_has_mmap();
  void set_has_qsort();
  void set_has_bsearch();
  void set_has_open_stub();
  void set_has_lseek();
  void set_has_fread();
  void set_has_strncmp();
  void set_has_memcmp();
  void set_has_fxstat64();
  void set_has_generic();

  inline bool has_libcall_cnt() const;
  void clear_libcall_cnt();
  inline void clear_has_libcall_cnt();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > restrict_addresses_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int action_;
  int ident_;
  union LibcallCntUnion {
    LibcallCntUnion() {}
    ::libcall_types::strcpy_pol* strcpy_;
    ::libcall_types::printf_pol* printf_;
    ::libcall_types::atoi_pol* atoi_;
    ::libcall_types::malloc_pol* malloc_;
    ::libcall_types::getmodulehandle_pol* getmodulehandle_;
    ::libcall_types::getprocaddress_pol* getprocaddress_;
    ::libcall_types::getmainargs_pol* getmainargs_;
    ::libcall_types::gethostname_pol* gethostname_;
    ::libcall_types::free_pol* free_;
    ::libcall_types::memcpy_pol* memcpy_;
    ::libcall_types::memset_pol* memset_;
    ::libcall_types::fgetc_pol* fgetc_;
    ::libcall_types::read_pol* read_;
    ::libcall_types::strchr_pol* strchr_;
    ::libcall_types::exit_pol* exit_;
    ::libcall_types::strcmp_pol* strcmp_;
    ::libcall_types::ctype_b_loc_pol* ctype_b_loc_;
    ::libcall_types::fscanf_pol* fscanf_;
    ::libcall_types::strncpy_pol* strncpy_;
    ::libcall_types::fstat_pol* fstat_;
    ::libcall_types::realloc_pol* realloc_;
    ::libcall_types::mmap_pol* mmap_;
    ::libcall_types::qsort_pol* qsort_;
    ::libcall_types::bsearch_pol* bsearch_;
    ::libcall_types::open_pol* open_stub_;
    ::libcall_types::lseek_pol* lseek_;
    ::libcall_types::fread_pol* fread_;
    ::libcall_types::strncmp_pol* strncmp_;
    ::libcall_types::memcmp_pol* memcmp_;
    ::libcall_types::fxstat64_pol* fxstat64_;
    ::libcall_types::generic_pol* generic_;
  } libcall_cnt_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class libcall_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.libcall_t) */ {
 public:
  libcall_t();
  virtual ~libcall_t();

  libcall_t(const libcall_t& from);

  inline libcall_t& operator=(const libcall_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const libcall_t& default_instance();

  enum LibcallCntCase {
    kStrcpy = 5,
    kPrintf = 6,
    kAtoi = 7,
    kMalloc = 8,
    kGetmodulehandle = 9,
    kGetprocaddress = 10,
    kGetmainargs = 11,
    kGethostname = 12,
    kFree = 13,
    kMemcpy = 14,
    kMemset = 15,
    kFgetc = 16,
    kGeneric = 17,
    kRead = 18,
    kStrchr = 19,
    kExit = 20,
    kStrcmp = 21,
    kCtypeBLoc = 23,
    kFscanf = 24,
    kStrncpy = 25,
    kFstat = 26,
    kRealloc = 27,
    kMmap = 28,
    kQsort = 29,
    kBsearch = 30,
    kOpenStub = 31,
    kLseek = 32,
    kFread = 33,
    kStrncmp = 34,
    kMemcmp = 35,
    kFxstat64 = 36,
    LIBCALL_CNT_NOT_SET = 0,
  };

  static inline const libcall_t* internal_default_instance() {
    return reinterpret_cast<const libcall_t*>(
               &_libcall_t_default_instance_);
  }

  void Swap(libcall_t* other);

  // implements Message ----------------------------------------------

  inline libcall_t* New() const PROTOBUF_FINAL { return New(NULL); }

  libcall_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const libcall_t& from);
  void MergeFrom(const libcall_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(libcall_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string func_name = 2;
  bool has_func_name() const;
  void clear_func_name();
  static const int kFuncNameFieldNumber = 2;
  const ::std::string& func_name() const;
  void set_func_name(const ::std::string& value);
  #if LANG_CXX11
  void set_func_name(::std::string&& value);
  #endif
  void set_func_name(const char* value);
  void set_func_name(const char* value, size_t size);
  ::std::string* mutable_func_name();
  ::std::string* release_func_name();
  void set_allocated_func_name(::std::string* func_name);

  // required uint64 func_addr = 1;
  bool has_func_addr() const;
  void clear_func_addr();
  static const int kFuncAddrFieldNumber = 1;
  ::google::protobuf::uint64 func_addr() const;
  void set_func_addr(::google::protobuf::uint64 value);

  // required bool is_traced = 3;
  bool has_is_traced() const;
  void clear_is_traced();
  static const int kIsTracedFieldNumber = 3;
  bool is_traced() const;
  void set_is_traced(bool value);

  // required .libcall_types.lib_ident ident = 4;
  bool has_ident() const;
  void clear_ident();
  static const int kIdentFieldNumber = 4;
  ::libcall_types::lib_ident ident() const;
  void set_ident(::libcall_types::lib_ident value);

  // optional .libcall_types.strcpy_t strcpy = 5;
  bool has_strcpy() const;
  void clear_strcpy();
  static const int kStrcpyFieldNumber = 5;
  const ::libcall_types::strcpy_t& strcpy() const;
  ::libcall_types::strcpy_t* mutable_strcpy();
  ::libcall_types::strcpy_t* release_strcpy();
  void set_allocated_strcpy(::libcall_types::strcpy_t* strcpy);

  // optional .libcall_types.printf_t printf = 6;
  bool has_printf() const;
  void clear_printf();
  static const int kPrintfFieldNumber = 6;
  const ::libcall_types::printf_t& printf() const;
  ::libcall_types::printf_t* mutable_printf();
  ::libcall_types::printf_t* release_printf();
  void set_allocated_printf(::libcall_types::printf_t* printf);

  // optional .libcall_types.atoi_t atoi = 7;
  bool has_atoi() const;
  void clear_atoi();
  static const int kAtoiFieldNumber = 7;
  const ::libcall_types::atoi_t& atoi() const;
  ::libcall_types::atoi_t* mutable_atoi();
  ::libcall_types::atoi_t* release_atoi();
  void set_allocated_atoi(::libcall_types::atoi_t* atoi);

  // optional .libcall_types.malloc_t malloc = 8;
  bool has_malloc() const;
  void clear_malloc();
  static const int kMallocFieldNumber = 8;
  const ::libcall_types::malloc_t& malloc() const;
  ::libcall_types::malloc_t* mutable_malloc();
  ::libcall_types::malloc_t* release_malloc();
  void set_allocated_malloc(::libcall_types::malloc_t* malloc);

  // optional .libcall_types.getmodulehandle_t getmodulehandle = 9;
  bool has_getmodulehandle() const;
  void clear_getmodulehandle();
  static const int kGetmodulehandleFieldNumber = 9;
  const ::libcall_types::getmodulehandle_t& getmodulehandle() const;
  ::libcall_types::getmodulehandle_t* mutable_getmodulehandle();
  ::libcall_types::getmodulehandle_t* release_getmodulehandle();
  void set_allocated_getmodulehandle(::libcall_types::getmodulehandle_t* getmodulehandle);

  // optional .libcall_types.getprocaddress_t getprocaddress = 10;
  bool has_getprocaddress() const;
  void clear_getprocaddress();
  static const int kGetprocaddressFieldNumber = 10;
  const ::libcall_types::getprocaddress_t& getprocaddress() const;
  ::libcall_types::getprocaddress_t* mutable_getprocaddress();
  ::libcall_types::getprocaddress_t* release_getprocaddress();
  void set_allocated_getprocaddress(::libcall_types::getprocaddress_t* getprocaddress);

  // optional .libcall_types.getmainargs_t getmainargs = 11;
  bool has_getmainargs() const;
  void clear_getmainargs();
  static const int kGetmainargsFieldNumber = 11;
  const ::libcall_types::getmainargs_t& getmainargs() const;
  ::libcall_types::getmainargs_t* mutable_getmainargs();
  ::libcall_types::getmainargs_t* release_getmainargs();
  void set_allocated_getmainargs(::libcall_types::getmainargs_t* getmainargs);

  // optional .libcall_types.gethostname_t gethostname = 12;
  bool has_gethostname() const;
  void clear_gethostname();
  static const int kGethostnameFieldNumber = 12;
  const ::libcall_types::gethostname_t& gethostname() const;
  ::libcall_types::gethostname_t* mutable_gethostname();
  ::libcall_types::gethostname_t* release_gethostname();
  void set_allocated_gethostname(::libcall_types::gethostname_t* gethostname);

  // optional .libcall_types.free_t free = 13;
  bool has_free() const;
  void clear_free();
  static const int kFreeFieldNumber = 13;
  const ::libcall_types::free_t& free() const;
  ::libcall_types::free_t* mutable_free();
  ::libcall_types::free_t* release_free();
  void set_allocated_free(::libcall_types::free_t* free);

  // optional .libcall_types.memcpy_t memcpy = 14;
  bool has_memcpy() const;
  void clear_memcpy();
  static const int kMemcpyFieldNumber = 14;
  const ::libcall_types::memcpy_t& memcpy() const;
  ::libcall_types::memcpy_t* mutable_memcpy();
  ::libcall_types::memcpy_t* release_memcpy();
  void set_allocated_memcpy(::libcall_types::memcpy_t* memcpy);

  // optional .libcall_types.memset_t memset = 15;
  bool has_memset() const;
  void clear_memset();
  static const int kMemsetFieldNumber = 15;
  const ::libcall_types::memset_t& memset() const;
  ::libcall_types::memset_t* mutable_memset();
  ::libcall_types::memset_t* release_memset();
  void set_allocated_memset(::libcall_types::memset_t* memset);

  // optional .libcall_types.fgetc_t fgetc = 16;
  bool has_fgetc() const;
  void clear_fgetc();
  static const int kFgetcFieldNumber = 16;
  const ::libcall_types::fgetc_t& fgetc() const;
  ::libcall_types::fgetc_t* mutable_fgetc();
  ::libcall_types::fgetc_t* release_fgetc();
  void set_allocated_fgetc(::libcall_types::fgetc_t* fgetc);

  // optional .libcall_types.generic_t generic = 17;
  bool has_generic() const;
  void clear_generic();
  static const int kGenericFieldNumber = 17;
  const ::libcall_types::generic_t& generic() const;
  ::libcall_types::generic_t* mutable_generic();
  ::libcall_types::generic_t* release_generic();
  void set_allocated_generic(::libcall_types::generic_t* generic);

  // optional .libcall_types.read_t read = 18;
  bool has_read() const;
  void clear_read();
  static const int kReadFieldNumber = 18;
  const ::libcall_types::read_t& read() const;
  ::libcall_types::read_t* mutable_read();
  ::libcall_types::read_t* release_read();
  void set_allocated_read(::libcall_types::read_t* read);

  // optional .libcall_types.strchr_t strchr = 19;
  bool has_strchr() const;
  void clear_strchr();
  static const int kStrchrFieldNumber = 19;
  const ::libcall_types::strchr_t& strchr() const;
  ::libcall_types::strchr_t* mutable_strchr();
  ::libcall_types::strchr_t* release_strchr();
  void set_allocated_strchr(::libcall_types::strchr_t* strchr);

  // optional .libcall_types.exit_t exit = 20;
  bool has_exit() const;
  void clear_exit();
  static const int kExitFieldNumber = 20;
  const ::libcall_types::exit_t& exit() const;
  ::libcall_types::exit_t* mutable_exit();
  ::libcall_types::exit_t* release_exit();
  void set_allocated_exit(::libcall_types::exit_t* exit);

  // optional .libcall_types.strcmp_t strcmp = 21;
  bool has_strcmp() const;
  void clear_strcmp();
  static const int kStrcmpFieldNumber = 21;
  const ::libcall_types::strcmp_t& strcmp() const;
  ::libcall_types::strcmp_t* mutable_strcmp();
  ::libcall_types::strcmp_t* release_strcmp();
  void set_allocated_strcmp(::libcall_types::strcmp_t* strcmp);

  // optional .libcall_types.ctype_b_loc_t ctype_b_loc = 23;
  bool has_ctype_b_loc() const;
  void clear_ctype_b_loc();
  static const int kCtypeBLocFieldNumber = 23;
  const ::libcall_types::ctype_b_loc_t& ctype_b_loc() const;
  ::libcall_types::ctype_b_loc_t* mutable_ctype_b_loc();
  ::libcall_types::ctype_b_loc_t* release_ctype_b_loc();
  void set_allocated_ctype_b_loc(::libcall_types::ctype_b_loc_t* ctype_b_loc);

  // optional .libcall_types.fscanf_t fscanf = 24;
  bool has_fscanf() const;
  void clear_fscanf();
  static const int kFscanfFieldNumber = 24;
  const ::libcall_types::fscanf_t& fscanf() const;
  ::libcall_types::fscanf_t* mutable_fscanf();
  ::libcall_types::fscanf_t* release_fscanf();
  void set_allocated_fscanf(::libcall_types::fscanf_t* fscanf);

  // optional .libcall_types.strncpy_t strncpy = 25;
  bool has_strncpy() const;
  void clear_strncpy();
  static const int kStrncpyFieldNumber = 25;
  const ::libcall_types::strncpy_t& strncpy() const;
  ::libcall_types::strncpy_t* mutable_strncpy();
  ::libcall_types::strncpy_t* release_strncpy();
  void set_allocated_strncpy(::libcall_types::strncpy_t* strncpy);

  // optional .libcall_types.fstat_t fstat = 26;
  bool has_fstat() const;
  void clear_fstat();
  static const int kFstatFieldNumber = 26;
  const ::libcall_types::fstat_t& fstat() const;
  ::libcall_types::fstat_t* mutable_fstat();
  ::libcall_types::fstat_t* release_fstat();
  void set_allocated_fstat(::libcall_types::fstat_t* fstat);

  // optional .libcall_types.realloc_t realloc = 27;
  bool has_realloc() const;
  void clear_realloc();
  static const int kReallocFieldNumber = 27;
  const ::libcall_types::realloc_t& realloc() const;
  ::libcall_types::realloc_t* mutable_realloc();
  ::libcall_types::realloc_t* release_realloc();
  void set_allocated_realloc(::libcall_types::realloc_t* realloc);

  // optional .libcall_types.mmap_t mmap = 28;
  bool has_mmap() const;
  void clear_mmap();
  static const int kMmapFieldNumber = 28;
  const ::libcall_types::mmap_t& mmap() const;
  ::libcall_types::mmap_t* mutable_mmap();
  ::libcall_types::mmap_t* release_mmap();
  void set_allocated_mmap(::libcall_types::mmap_t* mmap);

  // optional .libcall_types.qsort_t qsort = 29;
  bool has_qsort() const;
  void clear_qsort();
  static const int kQsortFieldNumber = 29;
  const ::libcall_types::qsort_t& qsort() const;
  ::libcall_types::qsort_t* mutable_qsort();
  ::libcall_types::qsort_t* release_qsort();
  void set_allocated_qsort(::libcall_types::qsort_t* qsort);

  // optional .libcall_types.bsearch_t bsearch = 30;
  bool has_bsearch() const;
  void clear_bsearch();
  static const int kBsearchFieldNumber = 30;
  const ::libcall_types::bsearch_t& bsearch() const;
  ::libcall_types::bsearch_t* mutable_bsearch();
  ::libcall_types::bsearch_t* release_bsearch();
  void set_allocated_bsearch(::libcall_types::bsearch_t* bsearch);

  // optional .libcall_types.open_t open_stub = 31;
  bool has_open_stub() const;
  void clear_open_stub();
  static const int kOpenStubFieldNumber = 31;
  const ::libcall_types::open_t& open_stub() const;
  ::libcall_types::open_t* mutable_open_stub();
  ::libcall_types::open_t* release_open_stub();
  void set_allocated_open_stub(::libcall_types::open_t* open_stub);

  // optional .libcall_types.lseek_t lseek = 32;
  bool has_lseek() const;
  void clear_lseek();
  static const int kLseekFieldNumber = 32;
  const ::libcall_types::lseek_t& lseek() const;
  ::libcall_types::lseek_t* mutable_lseek();
  ::libcall_types::lseek_t* release_lseek();
  void set_allocated_lseek(::libcall_types::lseek_t* lseek);

  // optional .libcall_types.fread_t fread = 33;
  bool has_fread() const;
  void clear_fread();
  static const int kFreadFieldNumber = 33;
  const ::libcall_types::fread_t& fread() const;
  ::libcall_types::fread_t* mutable_fread();
  ::libcall_types::fread_t* release_fread();
  void set_allocated_fread(::libcall_types::fread_t* fread);

  // optional .libcall_types.strncmp_t strncmp = 34;
  bool has_strncmp() const;
  void clear_strncmp();
  static const int kStrncmpFieldNumber = 34;
  const ::libcall_types::strncmp_t& strncmp() const;
  ::libcall_types::strncmp_t* mutable_strncmp();
  ::libcall_types::strncmp_t* release_strncmp();
  void set_allocated_strncmp(::libcall_types::strncmp_t* strncmp);

  // optional .libcall_types.memcmp_t memcmp = 35;
  bool has_memcmp() const;
  void clear_memcmp();
  static const int kMemcmpFieldNumber = 35;
  const ::libcall_types::memcmp_t& memcmp() const;
  ::libcall_types::memcmp_t* mutable_memcmp();
  ::libcall_types::memcmp_t* release_memcmp();
  void set_allocated_memcmp(::libcall_types::memcmp_t* memcmp);

  // optional .libcall_types.fxstat64_t fxstat64 = 36;
  bool has_fxstat64() const;
  void clear_fxstat64();
  static const int kFxstat64FieldNumber = 36;
  const ::libcall_types::fxstat64_t& fxstat64() const;
  ::libcall_types::fxstat64_t* mutable_fxstat64();
  ::libcall_types::fxstat64_t* release_fxstat64();
  void set_allocated_fxstat64(::libcall_types::fxstat64_t* fxstat64);

  LibcallCntCase libcall_cnt_case() const;
  // @@protoc_insertion_point(class_scope:libcall_types.libcall_t)
 private:
  void set_has_func_addr();
  void clear_has_func_addr();
  void set_has_func_name();
  void clear_has_func_name();
  void set_has_is_traced();
  void clear_has_is_traced();
  void set_has_ident();
  void clear_has_ident();
  void set_has_strcpy();
  void set_has_printf();
  void set_has_atoi();
  void set_has_malloc();
  void set_has_getmodulehandle();
  void set_has_getprocaddress();
  void set_has_getmainargs();
  void set_has_gethostname();
  void set_has_free();
  void set_has_memcpy();
  void set_has_memset();
  void set_has_fgetc();
  void set_has_generic();
  void set_has_read();
  void set_has_strchr();
  void set_has_exit();
  void set_has_strcmp();
  void set_has_ctype_b_loc();
  void set_has_fscanf();
  void set_has_strncpy();
  void set_has_fstat();
  void set_has_realloc();
  void set_has_mmap();
  void set_has_qsort();
  void set_has_bsearch();
  void set_has_open_stub();
  void set_has_lseek();
  void set_has_fread();
  void set_has_strncmp();
  void set_has_memcmp();
  void set_has_fxstat64();

  inline bool has_libcall_cnt() const;
  void clear_libcall_cnt();
  inline void clear_has_libcall_cnt();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr func_name_;
  ::google::protobuf::uint64 func_addr_;
  bool is_traced_;
  int ident_;
  union LibcallCntUnion {
    LibcallCntUnion() {}
    ::libcall_types::strcpy_t* strcpy_;
    ::libcall_types::printf_t* printf_;
    ::libcall_types::atoi_t* atoi_;
    ::libcall_types::malloc_t* malloc_;
    ::libcall_types::getmodulehandle_t* getmodulehandle_;
    ::libcall_types::getprocaddress_t* getprocaddress_;
    ::libcall_types::getmainargs_t* getmainargs_;
    ::libcall_types::gethostname_t* gethostname_;
    ::libcall_types::free_t* free_;
    ::libcall_types::memcpy_t* memcpy_;
    ::libcall_types::memset_t* memset_;
    ::libcall_types::fgetc_t* fgetc_;
    ::libcall_types::generic_t* generic_;
    ::libcall_types::read_t* read_;
    ::libcall_types::strchr_t* strchr_;
    ::libcall_types::exit_t* exit_;
    ::libcall_types::strcmp_t* strcmp_;
    ::libcall_types::ctype_b_loc_t* ctype_b_loc_;
    ::libcall_types::fscanf_t* fscanf_;
    ::libcall_types::strncpy_t* strncpy_;
    ::libcall_types::fstat_t* fstat_;
    ::libcall_types::realloc_t* realloc_;
    ::libcall_types::mmap_t* mmap_;
    ::libcall_types::qsort_t* qsort_;
    ::libcall_types::bsearch_t* bsearch_;
    ::libcall_types::open_t* open_stub_;
    ::libcall_types::lseek_t* lseek_;
    ::libcall_types::fread_t* fread_;
    ::libcall_types::strncmp_t* strncmp_;
    ::libcall_types::memcmp_t* memcmp_;
    ::libcall_types::fxstat64_t* fxstat64_;
  } libcall_cnt_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class generic_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.generic_pol) */ {
 public:
  generic_pol();
  virtual ~generic_pol();

  generic_pol(const generic_pol& from);

  inline generic_pol& operator=(const generic_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const generic_pol& default_instance();

  static inline const generic_pol* internal_default_instance() {
    return reinterpret_cast<const generic_pol*>(
               &_generic_pol_default_instance_);
  }

  void Swap(generic_pol* other);

  // implements Message ----------------------------------------------

  inline generic_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  generic_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const generic_pol& from);
  void MergeFrom(const generic_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(generic_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.action ret = 1;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 1;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.generic_pol)
 private:
  void set_has_ret();
  void clear_has_ret();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ctype_b_loc_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.ctype_b_loc_pol) */ {
 public:
  ctype_b_loc_pol();
  virtual ~ctype_b_loc_pol();

  ctype_b_loc_pol(const ctype_b_loc_pol& from);

  inline ctype_b_loc_pol& operator=(const ctype_b_loc_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ctype_b_loc_pol& default_instance();

  static inline const ctype_b_loc_pol* internal_default_instance() {
    return reinterpret_cast<const ctype_b_loc_pol*>(
               &_ctype_b_loc_pol_default_instance_);
  }

  void Swap(ctype_b_loc_pol* other);

  // implements Message ----------------------------------------------

  inline ctype_b_loc_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  ctype_b_loc_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ctype_b_loc_pol& from);
  void MergeFrom(const ctype_b_loc_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ctype_b_loc_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol table = 1;
  bool has_table() const;
  void clear_table();
  static const int kTableFieldNumber = 1;
  const ::common::memory_pol& table() const;
  ::common::memory_pol* mutable_table();
  ::common::memory_pol* release_table();
  void set_allocated_table(::common::memory_pol* table);

  // required .common.action ret = 2;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 2;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.ctype_b_loc_pol)
 private:
  void set_has_table();
  void clear_has_table();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* table_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class exit_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.exit_pol) */ {
 public:
  exit_pol();
  virtual ~exit_pol();

  exit_pol(const exit_pol& from);

  inline exit_pol& operator=(const exit_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const exit_pol& default_instance();

  static inline const exit_pol* internal_default_instance() {
    return reinterpret_cast<const exit_pol*>(
               &_exit_pol_default_instance_);
  }

  void Swap(exit_pol* other);

  // implements Message ----------------------------------------------

  inline exit_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  exit_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const exit_pol& from);
  void MergeFrom(const exit_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(exit_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:libcall_types.exit_pol)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class fscanf_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.fscanf_pol) */ {
 public:
  fscanf_pol();
  virtual ~fscanf_pol();

  fscanf_pol(const fscanf_pol& from);

  inline fscanf_pol& operator=(const fscanf_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fscanf_pol& default_instance();

  static inline const fscanf_pol* internal_default_instance() {
    return reinterpret_cast<const fscanf_pol*>(
               &_fscanf_pol_default_instance_);
  }

  void Swap(fscanf_pol* other);

  // implements Message ----------------------------------------------

  inline fscanf_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  fscanf_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const fscanf_pol& from);
  void MergeFrom(const fscanf_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(fscanf_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.action stream = 1;
  bool has_stream() const;
  void clear_stream();
  static const int kStreamFieldNumber = 1;
  ::common::action stream() const;
  void set_stream(::common::action value);

  // required .common.action elems = 2;
  bool has_elems() const;
  void clear_elems();
  static const int kElemsFieldNumber = 2;
  ::common::action elems() const;
  void set_elems(::common::action value);

  // required .common.action ret = 3;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 3;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.fscanf_pol)
 private:
  void set_has_stream();
  void clear_has_stream();
  void set_has_elems();
  void clear_has_elems();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int stream_;
  int elems_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class read_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.read_pol) */ {
 public:
  read_pol();
  virtual ~read_pol();

  read_pol(const read_pol& from);

  inline read_pol& operator=(const read_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const read_pol& default_instance();

  static inline const read_pol* internal_default_instance() {
    return reinterpret_cast<const read_pol*>(
               &_read_pol_default_instance_);
  }

  void Swap(read_pol* other);

  // implements Message ----------------------------------------------

  inline read_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  read_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const read_pol& from);
  void MergeFrom(const read_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(read_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol buf = 2;
  bool has_buf() const;
  void clear_buf();
  static const int kBufFieldNumber = 2;
  const ::common::memory_pol& buf() const;
  ::common::memory_pol* mutable_buf();
  ::common::memory_pol* release_buf();
  void set_allocated_buf(::common::memory_pol* buf);

  // required .common.action fd = 1;
  bool has_fd() const;
  void clear_fd();
  static const int kFdFieldNumber = 1;
  ::common::action fd() const;
  void set_fd(::common::action value);

  // required .common.action count = 3;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::common::action count() const;
  void set_count(::common::action value);

  // required .common.action ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.read_pol)
 private:
  void set_has_fd();
  void clear_has_fd();
  void set_has_buf();
  void clear_has_buf();
  void set_has_count();
  void clear_has_count();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* buf_;
  int fd_;
  int count_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class fread_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.fread_pol) */ {
 public:
  fread_pol();
  virtual ~fread_pol();

  fread_pol(const fread_pol& from);

  inline fread_pol& operator=(const fread_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fread_pol& default_instance();

  static inline const fread_pol* internal_default_instance() {
    return reinterpret_cast<const fread_pol*>(
               &_fread_pol_default_instance_);
  }

  void Swap(fread_pol* other);

  // implements Message ----------------------------------------------

  inline fread_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  fread_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const fread_pol& from);
  void MergeFrom(const fread_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(fread_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol ptr = 1;
  bool has_ptr() const;
  void clear_ptr();
  static const int kPtrFieldNumber = 1;
  const ::common::memory_pol& ptr() const;
  ::common::memory_pol* mutable_ptr();
  ::common::memory_pol* release_ptr();
  void set_allocated_ptr(::common::memory_pol* ptr);

  // required .common.action size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::common::action size() const;
  void set_size(::common::action value);

  // required .common.action nmemb = 3;
  bool has_nmemb() const;
  void clear_nmemb();
  static const int kNmembFieldNumber = 3;
  ::common::action nmemb() const;
  void set_nmemb(::common::action value);

  // required .common.action stream = 4;
  bool has_stream() const;
  void clear_stream();
  static const int kStreamFieldNumber = 4;
  ::common::action stream() const;
  void set_stream(::common::action value);

  // required .common.action ret = 5;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 5;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.fread_pol)
 private:
  void set_has_ptr();
  void clear_has_ptr();
  void set_has_size();
  void clear_has_size();
  void set_has_nmemb();
  void clear_has_nmemb();
  void set_has_stream();
  void clear_has_stream();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* ptr_;
  int size_;
  int nmemb_;
  int stream_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class strcmp_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.strcmp_pol) */ {
 public:
  strcmp_pol();
  virtual ~strcmp_pol();

  strcmp_pol(const strcmp_pol& from);

  inline strcmp_pol& operator=(const strcmp_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const strcmp_pol& default_instance();

  static inline const strcmp_pol* internal_default_instance() {
    return reinterpret_cast<const strcmp_pol*>(
               &_strcmp_pol_default_instance_);
  }

  void Swap(strcmp_pol* other);

  // implements Message ----------------------------------------------

  inline strcmp_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  strcmp_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const strcmp_pol& from);
  void MergeFrom(const strcmp_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(strcmp_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol src = 1;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  const ::common::memory_pol& src() const;
  ::common::memory_pol* mutable_src();
  ::common::memory_pol* release_src();
  void set_allocated_src(::common::memory_pol* src);

  // required .common.memory_pol dst = 2;
  bool has_dst() const;
  void clear_dst();
  static const int kDstFieldNumber = 2;
  const ::common::memory_pol& dst() const;
  ::common::memory_pol* mutable_dst();
  ::common::memory_pol* release_dst();
  void set_allocated_dst(::common::memory_pol* dst);

  // required .common.action ret = 3;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 3;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.strcmp_pol)
 private:
  void set_has_src();
  void clear_has_src();
  void set_has_dst();
  void clear_has_dst();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* src_;
  ::common::memory_pol* dst_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class strncmp_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.strncmp_pol) */ {
 public:
  strncmp_pol();
  virtual ~strncmp_pol();

  strncmp_pol(const strncmp_pol& from);

  inline strncmp_pol& operator=(const strncmp_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const strncmp_pol& default_instance();

  static inline const strncmp_pol* internal_default_instance() {
    return reinterpret_cast<const strncmp_pol*>(
               &_strncmp_pol_default_instance_);
  }

  void Swap(strncmp_pol* other);

  // implements Message ----------------------------------------------

  inline strncmp_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  strncmp_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const strncmp_pol& from);
  void MergeFrom(const strncmp_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(strncmp_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.action s1 = 1;
  bool has_s1() const;
  void clear_s1();
  static const int kS1FieldNumber = 1;
  ::common::action s1() const;
  void set_s1(::common::action value);

  // required .common.action s2 = 2;
  bool has_s2() const;
  void clear_s2();
  static const int kS2FieldNumber = 2;
  ::common::action s2() const;
  void set_s2(::common::action value);

  // required .common.action n = 3;
  bool has_n() const;
  void clear_n();
  static const int kNFieldNumber = 3;
  ::common::action n() const;
  void set_n(::common::action value);

  // required .common.action ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.strncmp_pol)
 private:
  void set_has_s1();
  void clear_has_s1();
  void set_has_s2();
  void clear_has_s2();
  void set_has_n();
  void clear_has_n();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int s1_;
  int s2_;
  int n_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class memcmp_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.memcmp_pol) */ {
 public:
  memcmp_pol();
  virtual ~memcmp_pol();

  memcmp_pol(const memcmp_pol& from);

  inline memcmp_pol& operator=(const memcmp_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const memcmp_pol& default_instance();

  static inline const memcmp_pol* internal_default_instance() {
    return reinterpret_cast<const memcmp_pol*>(
               &_memcmp_pol_default_instance_);
  }

  void Swap(memcmp_pol* other);

  // implements Message ----------------------------------------------

  inline memcmp_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  memcmp_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const memcmp_pol& from);
  void MergeFrom(const memcmp_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(memcmp_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.action s1 = 1;
  bool has_s1() const;
  void clear_s1();
  static const int kS1FieldNumber = 1;
  ::common::action s1() const;
  void set_s1(::common::action value);

  // required .common.action s2 = 2;
  bool has_s2() const;
  void clear_s2();
  static const int kS2FieldNumber = 2;
  ::common::action s2() const;
  void set_s2(::common::action value);

  // required .common.action n = 3;
  bool has_n() const;
  void clear_n();
  static const int kNFieldNumber = 3;
  ::common::action n() const;
  void set_n(::common::action value);

  // required .common.action ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.memcmp_pol)
 private:
  void set_has_s1();
  void clear_has_s1();
  void set_has_s2();
  void clear_has_s2();
  void set_has_n();
  void clear_has_n();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int s1_;
  int s2_;
  int n_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class strchr_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.strchr_pol) */ {
 public:
  strchr_pol();
  virtual ~strchr_pol();

  strchr_pol(const strchr_pol& from);

  inline strchr_pol& operator=(const strchr_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const strchr_pol& default_instance();

  static inline const strchr_pol* internal_default_instance() {
    return reinterpret_cast<const strchr_pol*>(
               &_strchr_pol_default_instance_);
  }

  void Swap(strchr_pol* other);

  // implements Message ----------------------------------------------

  inline strchr_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  strchr_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const strchr_pol& from);
  void MergeFrom(const strchr_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(strchr_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol sc = 1;
  bool has_sc() const;
  void clear_sc();
  static const int kScFieldNumber = 1;
  const ::common::memory_pol& sc() const;
  ::common::memory_pol* mutable_sc();
  ::common::memory_pol* release_sc();
  void set_allocated_sc(::common::memory_pol* sc);

  // required .common.memory_pol c = 2;
  bool has_c() const;
  void clear_c();
  static const int kCFieldNumber = 2;
  const ::common::memory_pol& c() const;
  ::common::memory_pol* mutable_c();
  ::common::memory_pol* release_c();
  void set_allocated_c(::common::memory_pol* c);

  // required .common.action ret = 3;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 3;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.strchr_pol)
 private:
  void set_has_sc();
  void clear_has_sc();
  void set_has_c();
  void clear_has_c();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* sc_;
  ::common::memory_pol* c_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class strncpy_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.strncpy_pol) */ {
 public:
  strncpy_pol();
  virtual ~strncpy_pol();

  strncpy_pol(const strncpy_pol& from);

  inline strncpy_pol& operator=(const strncpy_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const strncpy_pol& default_instance();

  static inline const strncpy_pol* internal_default_instance() {
    return reinterpret_cast<const strncpy_pol*>(
               &_strncpy_pol_default_instance_);
  }

  void Swap(strncpy_pol* other);

  // implements Message ----------------------------------------------

  inline strncpy_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  strncpy_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const strncpy_pol& from);
  void MergeFrom(const strncpy_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(strncpy_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.action dst = 1;
  bool has_dst() const;
  void clear_dst();
  static const int kDstFieldNumber = 1;
  ::common::action dst() const;
  void set_dst(::common::action value);

  // required .common.action src = 2;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 2;
  ::common::action src() const;
  void set_src(::common::action value);

  // required .common.action n = 3;
  bool has_n() const;
  void clear_n();
  static const int kNFieldNumber = 3;
  ::common::action n() const;
  void set_n(::common::action value);

  // required .common.action ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.strncpy_pol)
 private:
  void set_has_dst();
  void clear_has_dst();
  void set_has_src();
  void clear_has_src();
  void set_has_n();
  void clear_has_n();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int dst_;
  int src_;
  int n_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class fstat_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.fstat_pol) */ {
 public:
  fstat_pol();
  virtual ~fstat_pol();

  fstat_pol(const fstat_pol& from);

  inline fstat_pol& operator=(const fstat_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fstat_pol& default_instance();

  static inline const fstat_pol* internal_default_instance() {
    return reinterpret_cast<const fstat_pol*>(
               &_fstat_pol_default_instance_);
  }

  void Swap(fstat_pol* other);

  // implements Message ----------------------------------------------

  inline fstat_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  fstat_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const fstat_pol& from);
  void MergeFrom(const fstat_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(fstat_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:libcall_types.fstat_pol)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class fxstat64_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.fxstat64_pol) */ {
 public:
  fxstat64_pol();
  virtual ~fxstat64_pol();

  fxstat64_pol(const fxstat64_pol& from);

  inline fxstat64_pol& operator=(const fxstat64_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fxstat64_pol& default_instance();

  static inline const fxstat64_pol* internal_default_instance() {
    return reinterpret_cast<const fxstat64_pol*>(
               &_fxstat64_pol_default_instance_);
  }

  void Swap(fxstat64_pol* other);

  // implements Message ----------------------------------------------

  inline fxstat64_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  fxstat64_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const fxstat64_pol& from);
  void MergeFrom(const fxstat64_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(fxstat64_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:libcall_types.fxstat64_pol)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class realloc_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.realloc_pol) */ {
 public:
  realloc_pol();
  virtual ~realloc_pol();

  realloc_pol(const realloc_pol& from);

  inline realloc_pol& operator=(const realloc_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const realloc_pol& default_instance();

  static inline const realloc_pol* internal_default_instance() {
    return reinterpret_cast<const realloc_pol*>(
               &_realloc_pol_default_instance_);
  }

  void Swap(realloc_pol* other);

  // implements Message ----------------------------------------------

  inline realloc_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  realloc_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const realloc_pol& from);
  void MergeFrom(const realloc_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(realloc_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.action ptr = 1;
  bool has_ptr() const;
  void clear_ptr();
  static const int kPtrFieldNumber = 1;
  ::common::action ptr() const;
  void set_ptr(::common::action value);

  // required .common.action size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::common::action size() const;
  void set_size(::common::action value);

  // required .common.action ret = 3;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 3;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.realloc_pol)
 private:
  void set_has_ptr();
  void clear_has_ptr();
  void set_has_size();
  void clear_has_size();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int ptr_;
  int size_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class mmap_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.mmap_pol) */ {
 public:
  mmap_pol();
  virtual ~mmap_pol();

  mmap_pol(const mmap_pol& from);

  inline mmap_pol& operator=(const mmap_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mmap_pol& default_instance();

  static inline const mmap_pol* internal_default_instance() {
    return reinterpret_cast<const mmap_pol*>(
               &_mmap_pol_default_instance_);
  }

  void Swap(mmap_pol* other);

  // implements Message ----------------------------------------------

  inline mmap_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  mmap_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const mmap_pol& from);
  void MergeFrom(const mmap_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(mmap_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol ret = 7;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 7;
  const ::common::memory_pol& ret() const;
  ::common::memory_pol* mutable_ret();
  ::common::memory_pol* release_ret();
  void set_allocated_ret(::common::memory_pol* ret);

  // required .common.action addr = 1;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  ::common::action addr() const;
  void set_addr(::common::action value);

  // required .common.action length = 2;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::common::action length() const;
  void set_length(::common::action value);

  // required .common.action prot = 3;
  bool has_prot() const;
  void clear_prot();
  static const int kProtFieldNumber = 3;
  ::common::action prot() const;
  void set_prot(::common::action value);

  // required .common.action flags = 4;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 4;
  ::common::action flags() const;
  void set_flags(::common::action value);

  // required .common.action fd = 5;
  bool has_fd() const;
  void clear_fd();
  static const int kFdFieldNumber = 5;
  ::common::action fd() const;
  void set_fd(::common::action value);

  // required .common.action offset = 6;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 6;
  ::common::action offset() const;
  void set_offset(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.mmap_pol)
 private:
  void set_has_addr();
  void clear_has_addr();
  void set_has_length();
  void clear_has_length();
  void set_has_prot();
  void clear_has_prot();
  void set_has_flags();
  void clear_has_flags();
  void set_has_fd();
  void clear_has_fd();
  void set_has_offset();
  void clear_has_offset();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* ret_;
  int addr_;
  int length_;
  int prot_;
  int flags_;
  int fd_;
  int offset_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class qsort_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.qsort_pol) */ {
 public:
  qsort_pol();
  virtual ~qsort_pol();

  qsort_pol(const qsort_pol& from);

  inline qsort_pol& operator=(const qsort_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const qsort_pol& default_instance();

  static inline const qsort_pol* internal_default_instance() {
    return reinterpret_cast<const qsort_pol*>(
               &_qsort_pol_default_instance_);
  }

  void Swap(qsort_pol* other);

  // implements Message ----------------------------------------------

  inline qsort_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  qsort_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const qsort_pol& from);
  void MergeFrom(const qsort_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(qsort_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol base = 1;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 1;
  const ::common::memory_pol& base() const;
  ::common::memory_pol* mutable_base();
  ::common::memory_pol* release_base();
  void set_allocated_base(::common::memory_pol* base);

  // required .common.action nmemb = 2;
  bool has_nmemb() const;
  void clear_nmemb();
  static const int kNmembFieldNumber = 2;
  ::common::action nmemb() const;
  void set_nmemb(::common::action value);

  // required .common.action size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::common::action size() const;
  void set_size(::common::action value);

  // required .common.action compare = 4;
  bool has_compare() const;
  void clear_compare();
  static const int kCompareFieldNumber = 4;
  ::common::action compare() const;
  void set_compare(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.qsort_pol)
 private:
  void set_has_base();
  void clear_has_base();
  void set_has_nmemb();
  void clear_has_nmemb();
  void set_has_size();
  void clear_has_size();
  void set_has_compare();
  void clear_has_compare();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* base_;
  int nmemb_;
  int size_;
  int compare_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class bsearch_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.bsearch_pol) */ {
 public:
  bsearch_pol();
  virtual ~bsearch_pol();

  bsearch_pol(const bsearch_pol& from);

  inline bsearch_pol& operator=(const bsearch_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const bsearch_pol& default_instance();

  static inline const bsearch_pol* internal_default_instance() {
    return reinterpret_cast<const bsearch_pol*>(
               &_bsearch_pol_default_instance_);
  }

  void Swap(bsearch_pol* other);

  // implements Message ----------------------------------------------

  inline bsearch_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  bsearch_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const bsearch_pol& from);
  void MergeFrom(const bsearch_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(bsearch_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::common::memory_pol& key() const;
  ::common::memory_pol* mutable_key();
  ::common::memory_pol* release_key();
  void set_allocated_key(::common::memory_pol* key);

  // required .common.memory_pol base = 2;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 2;
  const ::common::memory_pol& base() const;
  ::common::memory_pol* mutable_base();
  ::common::memory_pol* release_base();
  void set_allocated_base(::common::memory_pol* base);

  // required .common.memory_pol ret = 6;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 6;
  const ::common::memory_pol& ret() const;
  ::common::memory_pol* mutable_ret();
  ::common::memory_pol* release_ret();
  void set_allocated_ret(::common::memory_pol* ret);

  // required .common.action nmemb = 3;
  bool has_nmemb() const;
  void clear_nmemb();
  static const int kNmembFieldNumber = 3;
  ::common::action nmemb() const;
  void set_nmemb(::common::action value);

  // required .common.action size = 4;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::common::action size() const;
  void set_size(::common::action value);

  // required .common.action compare = 5;
  bool has_compare() const;
  void clear_compare();
  static const int kCompareFieldNumber = 5;
  ::common::action compare() const;
  void set_compare(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.bsearch_pol)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_base();
  void clear_has_base();
  void set_has_nmemb();
  void clear_has_nmemb();
  void set_has_size();
  void clear_has_size();
  void set_has_compare();
  void clear_has_compare();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* key_;
  ::common::memory_pol* base_;
  ::common::memory_pol* ret_;
  int nmemb_;
  int size_;
  int compare_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class open_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.open_pol) */ {
 public:
  open_pol();
  virtual ~open_pol();

  open_pol(const open_pol& from);

  inline open_pol& operator=(const open_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const open_pol& default_instance();

  static inline const open_pol* internal_default_instance() {
    return reinterpret_cast<const open_pol*>(
               &_open_pol_default_instance_);
  }

  void Swap(open_pol* other);

  // implements Message ----------------------------------------------

  inline open_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  open_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const open_pol& from);
  void MergeFrom(const open_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(open_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol pathname = 1;
  bool has_pathname() const;
  void clear_pathname();
  static const int kPathnameFieldNumber = 1;
  const ::common::memory_pol& pathname() const;
  ::common::memory_pol* mutable_pathname();
  ::common::memory_pol* release_pathname();
  void set_allocated_pathname(::common::memory_pol* pathname);

  // required .common.action flags = 2;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 2;
  ::common::action flags() const;
  void set_flags(::common::action value);

  // required .common.action mode = 3;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 3;
  ::common::action mode() const;
  void set_mode(::common::action value);

  // required .common.action ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.open_pol)
 private:
  void set_has_pathname();
  void clear_has_pathname();
  void set_has_flags();
  void clear_has_flags();
  void set_has_mode();
  void clear_has_mode();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* pathname_;
  int flags_;
  int mode_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class strcpy_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.strcpy_pol) */ {
 public:
  strcpy_pol();
  virtual ~strcpy_pol();

  strcpy_pol(const strcpy_pol& from);

  inline strcpy_pol& operator=(const strcpy_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const strcpy_pol& default_instance();

  static inline const strcpy_pol* internal_default_instance() {
    return reinterpret_cast<const strcpy_pol*>(
               &_strcpy_pol_default_instance_);
  }

  void Swap(strcpy_pol* other);

  // implements Message ----------------------------------------------

  inline strcpy_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  strcpy_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const strcpy_pol& from);
  void MergeFrom(const strcpy_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(strcpy_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol src = 1;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  const ::common::memory_pol& src() const;
  ::common::memory_pol* mutable_src();
  ::common::memory_pol* release_src();
  void set_allocated_src(::common::memory_pol* src);

  // required .common.memory_pol dst = 2;
  bool has_dst() const;
  void clear_dst();
  static const int kDstFieldNumber = 2;
  const ::common::memory_pol& dst() const;
  ::common::memory_pol* mutable_dst();
  ::common::memory_pol* release_dst();
  void set_allocated_dst(::common::memory_pol* dst);

  // required .common.action ret = 3;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 3;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.strcpy_pol)
 private:
  void set_has_src();
  void clear_has_src();
  void set_has_dst();
  void clear_has_dst();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* src_;
  ::common::memory_pol* dst_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class printf_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.printf_pol) */ {
 public:
  printf_pol();
  virtual ~printf_pol();

  printf_pol(const printf_pol& from);

  inline printf_pol& operator=(const printf_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const printf_pol& default_instance();

  static inline const printf_pol* internal_default_instance() {
    return reinterpret_cast<const printf_pol*>(
               &_printf_pol_default_instance_);
  }

  void Swap(printf_pol* other);

  // implements Message ----------------------------------------------

  inline printf_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  printf_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const printf_pol& from);
  void MergeFrom(const printf_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(printf_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol format = 1;
  bool has_format() const;
  void clear_format();
  static const int kFormatFieldNumber = 1;
  const ::common::memory_pol& format() const;
  ::common::memory_pol* mutable_format();
  ::common::memory_pol* release_format();
  void set_allocated_format(::common::memory_pol* format);

  // required .common.action ret = 2;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 2;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.printf_pol)
 private:
  void set_has_format();
  void clear_has_format();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* format_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class atoi_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.atoi_pol) */ {
 public:
  atoi_pol();
  virtual ~atoi_pol();

  atoi_pol(const atoi_pol& from);

  inline atoi_pol& operator=(const atoi_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const atoi_pol& default_instance();

  static inline const atoi_pol* internal_default_instance() {
    return reinterpret_cast<const atoi_pol*>(
               &_atoi_pol_default_instance_);
  }

  void Swap(atoi_pol* other);

  // implements Message ----------------------------------------------

  inline atoi_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  atoi_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const atoi_pol& from);
  void MergeFrom(const atoi_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(atoi_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol src = 1;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  const ::common::memory_pol& src() const;
  ::common::memory_pol* mutable_src();
  ::common::memory_pol* release_src();
  void set_allocated_src(::common::memory_pol* src);

  // required .common.action ret = 3;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 3;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.atoi_pol)
 private:
  void set_has_src();
  void clear_has_src();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* src_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class malloc_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.malloc_pol) */ {
 public:
  malloc_pol();
  virtual ~malloc_pol();

  malloc_pol(const malloc_pol& from);

  inline malloc_pol& operator=(const malloc_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const malloc_pol& default_instance();

  static inline const malloc_pol* internal_default_instance() {
    return reinterpret_cast<const malloc_pol*>(
               &_malloc_pol_default_instance_);
  }

  void Swap(malloc_pol* other);

  // implements Message ----------------------------------------------

  inline malloc_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  malloc_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const malloc_pol& from);
  void MergeFrom(const malloc_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(malloc_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.action size = 1;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 1;
  ::common::action size() const;
  void set_size(::common::action value);

  // required .common.action ret = 2;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 2;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.malloc_pol)
 private:
  void set_has_size();
  void clear_has_size();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int size_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class getmodulehandle_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.getmodulehandle_pol) */ {
 public:
  getmodulehandle_pol();
  virtual ~getmodulehandle_pol();

  getmodulehandle_pol(const getmodulehandle_pol& from);

  inline getmodulehandle_pol& operator=(const getmodulehandle_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const getmodulehandle_pol& default_instance();

  static inline const getmodulehandle_pol* internal_default_instance() {
    return reinterpret_cast<const getmodulehandle_pol*>(
               &_getmodulehandle_pol_default_instance_);
  }

  void Swap(getmodulehandle_pol* other);

  // implements Message ----------------------------------------------

  inline getmodulehandle_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  getmodulehandle_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const getmodulehandle_pol& from);
  void MergeFrom(const getmodulehandle_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(getmodulehandle_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol module_name = 1;
  bool has_module_name() const;
  void clear_module_name();
  static const int kModuleNameFieldNumber = 1;
  const ::common::memory_pol& module_name() const;
  ::common::memory_pol* mutable_module_name();
  ::common::memory_pol* release_module_name();
  void set_allocated_module_name(::common::memory_pol* module_name);

  // required .common.action ret = 2;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 2;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.getmodulehandle_pol)
 private:
  void set_has_module_name();
  void clear_has_module_name();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* module_name_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class getprocaddress_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.getprocaddress_pol) */ {
 public:
  getprocaddress_pol();
  virtual ~getprocaddress_pol();

  getprocaddress_pol(const getprocaddress_pol& from);

  inline getprocaddress_pol& operator=(const getprocaddress_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const getprocaddress_pol& default_instance();

  static inline const getprocaddress_pol* internal_default_instance() {
    return reinterpret_cast<const getprocaddress_pol*>(
               &_getprocaddress_pol_default_instance_);
  }

  void Swap(getprocaddress_pol* other);

  // implements Message ----------------------------------------------

  inline getprocaddress_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  getprocaddress_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const getprocaddress_pol& from);
  void MergeFrom(const getprocaddress_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(getprocaddress_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol proc_name = 2;
  bool has_proc_name() const;
  void clear_proc_name();
  static const int kProcNameFieldNumber = 2;
  const ::common::memory_pol& proc_name() const;
  ::common::memory_pol* mutable_proc_name();
  ::common::memory_pol* release_proc_name();
  void set_allocated_proc_name(::common::memory_pol* proc_name);

  // required .common.action hmodule = 1;
  bool has_hmodule() const;
  void clear_hmodule();
  static const int kHmoduleFieldNumber = 1;
  ::common::action hmodule() const;
  void set_hmodule(::common::action value);

  // required .common.action ret = 3;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 3;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.getprocaddress_pol)
 private:
  void set_has_hmodule();
  void clear_has_hmodule();
  void set_has_proc_name();
  void clear_has_proc_name();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* proc_name_;
  int hmodule_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class getmainargs_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.getmainargs_pol) */ {
 public:
  getmainargs_pol();
  virtual ~getmainargs_pol();

  getmainargs_pol(const getmainargs_pol& from);

  inline getmainargs_pol& operator=(const getmainargs_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const getmainargs_pol& default_instance();

  static inline const getmainargs_pol* internal_default_instance() {
    return reinterpret_cast<const getmainargs_pol*>(
               &_getmainargs_pol_default_instance_);
  }

  void Swap(getmainargs_pol* other);

  // implements Message ----------------------------------------------

  inline getmainargs_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  getmainargs_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const getmainargs_pol& from);
  void MergeFrom(const getmainargs_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(getmainargs_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol argc = 1;
  bool has_argc() const;
  void clear_argc();
  static const int kArgcFieldNumber = 1;
  const ::common::memory_pol& argc() const;
  ::common::memory_pol* mutable_argc();
  ::common::memory_pol* release_argc();
  void set_allocated_argc(::common::memory_pol* argc);

  // required .common.memory_pol argv = 2;
  bool has_argv() const;
  void clear_argv();
  static const int kArgvFieldNumber = 2;
  const ::common::memory_pol& argv() const;
  ::common::memory_pol* mutable_argv();
  ::common::memory_pol* release_argv();
  void set_allocated_argv(::common::memory_pol* argv);

  // required .common.memory_pol env = 3;
  bool has_env() const;
  void clear_env();
  static const int kEnvFieldNumber = 3;
  const ::common::memory_pol& env() const;
  ::common::memory_pol* mutable_env();
  ::common::memory_pol* release_env();
  void set_allocated_env(::common::memory_pol* env);

  // required .common.memory_pol startinfo = 5;
  bool has_startinfo() const;
  void clear_startinfo();
  static const int kStartinfoFieldNumber = 5;
  const ::common::memory_pol& startinfo() const;
  ::common::memory_pol* mutable_startinfo();
  ::common::memory_pol* release_startinfo();
  void set_allocated_startinfo(::common::memory_pol* startinfo);

  // required .common.action dowildcard = 4;
  bool has_dowildcard() const;
  void clear_dowildcard();
  static const int kDowildcardFieldNumber = 4;
  ::common::action dowildcard() const;
  void set_dowildcard(::common::action value);

  // required .common.action ret = 6;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 6;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.getmainargs_pol)
 private:
  void set_has_argc();
  void clear_has_argc();
  void set_has_argv();
  void clear_has_argv();
  void set_has_env();
  void clear_has_env();
  void set_has_dowildcard();
  void clear_has_dowildcard();
  void set_has_startinfo();
  void clear_has_startinfo();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* argc_;
  ::common::memory_pol* argv_;
  ::common::memory_pol* env_;
  ::common::memory_pol* startinfo_;
  int dowildcard_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class gethostname_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.gethostname_pol) */ {
 public:
  gethostname_pol();
  virtual ~gethostname_pol();

  gethostname_pol(const gethostname_pol& from);

  inline gethostname_pol& operator=(const gethostname_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gethostname_pol& default_instance();

  static inline const gethostname_pol* internal_default_instance() {
    return reinterpret_cast<const gethostname_pol*>(
               &_gethostname_pol_default_instance_);
  }

  void Swap(gethostname_pol* other);

  // implements Message ----------------------------------------------

  inline gethostname_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  gethostname_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const gethostname_pol& from);
  void MergeFrom(const gethostname_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(gethostname_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::common::memory_pol& name() const;
  ::common::memory_pol* mutable_name();
  ::common::memory_pol* release_name();
  void set_allocated_name(::common::memory_pol* name);

  // required .common.action namelen = 2;
  bool has_namelen() const;
  void clear_namelen();
  static const int kNamelenFieldNumber = 2;
  ::common::action namelen() const;
  void set_namelen(::common::action value);

  // required .common.action ret = 3;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 3;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.gethostname_pol)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_namelen();
  void clear_has_namelen();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* name_;
  int namelen_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class free_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.free_pol) */ {
 public:
  free_pol();
  virtual ~free_pol();

  free_pol(const free_pol& from);

  inline free_pol& operator=(const free_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const free_pol& default_instance();

  static inline const free_pol* internal_default_instance() {
    return reinterpret_cast<const free_pol*>(
               &_free_pol_default_instance_);
  }

  void Swap(free_pol* other);

  // implements Message ----------------------------------------------

  inline free_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  free_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const free_pol& from);
  void MergeFrom(const free_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(free_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.action ptr = 1;
  bool has_ptr() const;
  void clear_ptr();
  static const int kPtrFieldNumber = 1;
  ::common::action ptr() const;
  void set_ptr(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.free_pol)
 private:
  void set_has_ptr();
  void clear_has_ptr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int ptr_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class memcpy_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.memcpy_pol) */ {
 public:
  memcpy_pol();
  virtual ~memcpy_pol();

  memcpy_pol(const memcpy_pol& from);

  inline memcpy_pol& operator=(const memcpy_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const memcpy_pol& default_instance();

  static inline const memcpy_pol* internal_default_instance() {
    return reinterpret_cast<const memcpy_pol*>(
               &_memcpy_pol_default_instance_);
  }

  void Swap(memcpy_pol* other);

  // implements Message ----------------------------------------------

  inline memcpy_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  memcpy_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const memcpy_pol& from);
  void MergeFrom(const memcpy_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(memcpy_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol dest = 1;
  bool has_dest() const;
  void clear_dest();
  static const int kDestFieldNumber = 1;
  const ::common::memory_pol& dest() const;
  ::common::memory_pol* mutable_dest();
  ::common::memory_pol* release_dest();
  void set_allocated_dest(::common::memory_pol* dest);

  // required .common.memory_pol src = 2;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 2;
  const ::common::memory_pol& src() const;
  ::common::memory_pol* mutable_src();
  ::common::memory_pol* release_src();
  void set_allocated_src(::common::memory_pol* src);

  // required .common.action size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::common::action size() const;
  void set_size(::common::action value);

  // required .common.action ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.memcpy_pol)
 private:
  void set_has_dest();
  void clear_has_dest();
  void set_has_src();
  void clear_has_src();
  void set_has_size();
  void clear_has_size();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* dest_;
  ::common::memory_pol* src_;
  int size_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class memset_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.memset_pol) */ {
 public:
  memset_pol();
  virtual ~memset_pol();

  memset_pol(const memset_pol& from);

  inline memset_pol& operator=(const memset_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const memset_pol& default_instance();

  static inline const memset_pol* internal_default_instance() {
    return reinterpret_cast<const memset_pol*>(
               &_memset_pol_default_instance_);
  }

  void Swap(memset_pol* other);

  // implements Message ----------------------------------------------

  inline memset_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  memset_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const memset_pol& from);
  void MergeFrom(const memset_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(memset_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_pol s = 1;
  bool has_s() const;
  void clear_s();
  static const int kSFieldNumber = 1;
  const ::common::memory_pol& s() const;
  ::common::memory_pol* mutable_s();
  ::common::memory_pol* release_s();
  void set_allocated_s(::common::memory_pol* s);

  // required .common.action c = 2;
  bool has_c() const;
  void clear_c();
  static const int kCFieldNumber = 2;
  ::common::action c() const;
  void set_c(::common::action value);

  // required .common.action size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::common::action size() const;
  void set_size(::common::action value);

  // required .common.action ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.memset_pol)
 private:
  void set_has_s();
  void clear_has_s();
  void set_has_c();
  void clear_has_c();
  void set_has_size();
  void clear_has_size();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_pol* s_;
  int c_;
  int size_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class fgetc_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.fgetc_pol) */ {
 public:
  fgetc_pol();
  virtual ~fgetc_pol();

  fgetc_pol(const fgetc_pol& from);

  inline fgetc_pol& operator=(const fgetc_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fgetc_pol& default_instance();

  static inline const fgetc_pol* internal_default_instance() {
    return reinterpret_cast<const fgetc_pol*>(
               &_fgetc_pol_default_instance_);
  }

  void Swap(fgetc_pol* other);

  // implements Message ----------------------------------------------

  inline fgetc_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  fgetc_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const fgetc_pol& from);
  void MergeFrom(const fgetc_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(fgetc_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.action stream = 1;
  bool has_stream() const;
  void clear_stream();
  static const int kStreamFieldNumber = 1;
  ::common::action stream() const;
  void set_stream(::common::action value);

  // required .common.action ret = 2;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 2;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.fgetc_pol)
 private:
  void set_has_stream();
  void clear_has_stream();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int stream_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class lseek_pol : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.lseek_pol) */ {
 public:
  lseek_pol();
  virtual ~lseek_pol();

  lseek_pol(const lseek_pol& from);

  inline lseek_pol& operator=(const lseek_pol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lseek_pol& default_instance();

  static inline const lseek_pol* internal_default_instance() {
    return reinterpret_cast<const lseek_pol*>(
               &_lseek_pol_default_instance_);
  }

  void Swap(lseek_pol* other);

  // implements Message ----------------------------------------------

  inline lseek_pol* New() const PROTOBUF_FINAL { return New(NULL); }

  lseek_pol* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const lseek_pol& from);
  void MergeFrom(const lseek_pol& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(lseek_pol* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.action fd = 1;
  bool has_fd() const;
  void clear_fd();
  static const int kFdFieldNumber = 1;
  ::common::action fd() const;
  void set_fd(::common::action value);

  // required .common.action offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::common::action offset() const;
  void set_offset(::common::action value);

  // required .common.action whence = 3;
  bool has_whence() const;
  void clear_whence();
  static const int kWhenceFieldNumber = 3;
  ::common::action whence() const;
  void set_whence(::common::action value);

  // required .common.action ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.lseek_pol)
 private:
  void set_has_fd();
  void clear_has_fd();
  void set_has_offset();
  void clear_has_offset();
  void set_has_whence();
  void clear_has_whence();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int fd_;
  int offset_;
  int whence_;
  int ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class exit_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.exit_t) */ {
 public:
  exit_t();
  virtual ~exit_t();

  exit_t(const exit_t& from);

  inline exit_t& operator=(const exit_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const exit_t& default_instance();

  static inline const exit_t* internal_default_instance() {
    return reinterpret_cast<const exit_t*>(
               &_exit_t_default_instance_);
  }

  void Swap(exit_t* other);

  // implements Message ----------------------------------------------

  inline exit_t* New() const PROTOBUF_FINAL { return New(NULL); }

  exit_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const exit_t& from);
  void MergeFrom(const exit_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(exit_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:libcall_types.exit_t)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class generic_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.generic_t) */ {
 public:
  generic_t();
  virtual ~generic_t();

  generic_t(const generic_t& from);

  inline generic_t& operator=(const generic_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const generic_t& default_instance();

  static inline const generic_t* internal_default_instance() {
    return reinterpret_cast<const generic_t*>(
               &_generic_t_default_instance_);
  }

  void Swap(generic_t* other);

  // implements Message ----------------------------------------------

  inline generic_t* New() const PROTOBUF_FINAL { return New(NULL); }

  generic_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const generic_t& from);
  void MergeFrom(const generic_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(generic_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 ret = 1;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 1;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.generic_t)
 private:
  void set_has_ret();
  void clear_has_ret();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class fscanf_elem_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.fscanf_elem_t) */ {
 public:
  fscanf_elem_t();
  virtual ~fscanf_elem_t();

  fscanf_elem_t(const fscanf_elem_t& from);

  inline fscanf_elem_t& operator=(const fscanf_elem_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fscanf_elem_t& default_instance();

  enum FscanfCntCase {
    kValueDec = 3,
    kValueString = 4,
    FSCANF_CNT_NOT_SET = 0,
  };

  static inline const fscanf_elem_t* internal_default_instance() {
    return reinterpret_cast<const fscanf_elem_t*>(
               &_fscanf_elem_t_default_instance_);
  }

  void Swap(fscanf_elem_t* other);

  // implements Message ----------------------------------------------

  inline fscanf_elem_t* New() const PROTOBUF_FINAL { return New(NULL); }

  fscanf_elem_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const fscanf_elem_t& from);
  void MergeFrom(const fscanf_elem_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(fscanf_elem_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 addr = 2;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 2;
  ::google::protobuf::uint64 addr() const;
  void set_addr(::google::protobuf::uint64 value);

  // required .libcall_types.fscanf_enum type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::libcall_types::fscanf_enum type() const;
  void set_type(::libcall_types::fscanf_enum value);

  // optional uint64 value_dec = 3;
  bool has_value_dec() const;
  void clear_value_dec();
  static const int kValueDecFieldNumber = 3;
  ::google::protobuf::uint64 value_dec() const;
  void set_value_dec(::google::protobuf::uint64 value);

  // optional string value_string = 4;
  bool has_value_string() const;
  void clear_value_string();
  static const int kValueStringFieldNumber = 4;
  const ::std::string& value_string() const;
  void set_value_string(const ::std::string& value);
  #if LANG_CXX11
  void set_value_string(::std::string&& value);
  #endif
  void set_value_string(const char* value);
  void set_value_string(const char* value, size_t size);
  ::std::string* mutable_value_string();
  ::std::string* release_value_string();
  void set_allocated_value_string(::std::string* value_string);

  FscanfCntCase fscanf_cnt_case() const;
  // @@protoc_insertion_point(class_scope:libcall_types.fscanf_elem_t)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_addr();
  void clear_has_addr();
  void set_has_value_dec();
  void set_has_value_string();

  inline bool has_fscanf_cnt() const;
  void clear_fscanf_cnt();
  inline void clear_has_fscanf_cnt();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 addr_;
  int type_;
  union FscanfCntUnion {
    FscanfCntUnion() {}
    ::google::protobuf::uint64 value_dec_;
    ::google::protobuf::internal::ArenaStringPtr value_string_;
  } fscanf_cnt_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class fscanf_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.fscanf_t) */ {
 public:
  fscanf_t();
  virtual ~fscanf_t();

  fscanf_t(const fscanf_t& from);

  inline fscanf_t& operator=(const fscanf_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fscanf_t& default_instance();

  static inline const fscanf_t* internal_default_instance() {
    return reinterpret_cast<const fscanf_t*>(
               &_fscanf_t_default_instance_);
  }

  void Swap(fscanf_t* other);

  // implements Message ----------------------------------------------

  inline fscanf_t* New() const PROTOBUF_FINAL { return New(NULL); }

  fscanf_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const fscanf_t& from);
  void MergeFrom(const fscanf_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(fscanf_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .libcall_types.fscanf_elem_t elems = 2;
  int elems_size() const;
  void clear_elems();
  static const int kElemsFieldNumber = 2;
  const ::libcall_types::fscanf_elem_t& elems(int index) const;
  ::libcall_types::fscanf_elem_t* mutable_elems(int index);
  ::libcall_types::fscanf_elem_t* add_elems();
  ::google::protobuf::RepeatedPtrField< ::libcall_types::fscanf_elem_t >*
      mutable_elems();
  const ::google::protobuf::RepeatedPtrField< ::libcall_types::fscanf_elem_t >&
      elems() const;

  // required uint64 stream = 1;
  bool has_stream() const;
  void clear_stream();
  static const int kStreamFieldNumber = 1;
  ::google::protobuf::uint64 stream() const;
  void set_stream(::google::protobuf::uint64 value);

  // required uint64 ret = 3;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 3;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.fscanf_t)
 private:
  void set_has_stream();
  void clear_has_stream();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::libcall_types::fscanf_elem_t > elems_;
  ::google::protobuf::uint64 stream_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ctype_b_loc_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.ctype_b_loc_t) */ {
 public:
  ctype_b_loc_t();
  virtual ~ctype_b_loc_t();

  ctype_b_loc_t(const ctype_b_loc_t& from);

  inline ctype_b_loc_t& operator=(const ctype_b_loc_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ctype_b_loc_t& default_instance();

  static inline const ctype_b_loc_t* internal_default_instance() {
    return reinterpret_cast<const ctype_b_loc_t*>(
               &_ctype_b_loc_t_default_instance_);
  }

  void Swap(ctype_b_loc_t* other);

  // implements Message ----------------------------------------------

  inline ctype_b_loc_t* New() const PROTOBUF_FINAL { return New(NULL); }

  ctype_b_loc_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ctype_b_loc_t& from);
  void MergeFrom(const ctype_b_loc_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ctype_b_loc_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t table = 1;
  bool has_table() const;
  void clear_table();
  static const int kTableFieldNumber = 1;
  const ::common::memory_t& table() const;
  ::common::memory_t* mutable_table();
  ::common::memory_t* release_table();
  void set_allocated_table(::common::memory_t* table);

  // required uint64 ret = 2;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 2;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.ctype_b_loc_t)
 private:
  void set_has_table();
  void clear_has_table();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* table_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class read_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.read_t) */ {
 public:
  read_t();
  virtual ~read_t();

  read_t(const read_t& from);

  inline read_t& operator=(const read_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const read_t& default_instance();

  static inline const read_t* internal_default_instance() {
    return reinterpret_cast<const read_t*>(
               &_read_t_default_instance_);
  }

  void Swap(read_t* other);

  // implements Message ----------------------------------------------

  inline read_t* New() const PROTOBUF_FINAL { return New(NULL); }

  read_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const read_t& from);
  void MergeFrom(const read_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(read_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t buf = 2;
  bool has_buf() const;
  void clear_buf();
  static const int kBufFieldNumber = 2;
  const ::common::memory_t& buf() const;
  ::common::memory_t* mutable_buf();
  ::common::memory_t* release_buf();
  void set_allocated_buf(::common::memory_t* buf);

  // required uint64 fd = 1;
  bool has_fd() const;
  void clear_fd();
  static const int kFdFieldNumber = 1;
  ::google::protobuf::uint64 fd() const;
  void set_fd(::google::protobuf::uint64 value);

  // required uint64 count = 3;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::uint64 count() const;
  void set_count(::google::protobuf::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.read_t)
 private:
  void set_has_fd();
  void clear_has_fd();
  void set_has_buf();
  void clear_has_buf();
  void set_has_count();
  void clear_has_count();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* buf_;
  ::google::protobuf::uint64 fd_;
  ::google::protobuf::uint64 count_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class fread_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.fread_t) */ {
 public:
  fread_t();
  virtual ~fread_t();

  fread_t(const fread_t& from);

  inline fread_t& operator=(const fread_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fread_t& default_instance();

  static inline const fread_t* internal_default_instance() {
    return reinterpret_cast<const fread_t*>(
               &_fread_t_default_instance_);
  }

  void Swap(fread_t* other);

  // implements Message ----------------------------------------------

  inline fread_t* New() const PROTOBUF_FINAL { return New(NULL); }

  fread_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const fread_t& from);
  void MergeFrom(const fread_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(fread_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t ptr = 1;
  bool has_ptr() const;
  void clear_ptr();
  static const int kPtrFieldNumber = 1;
  const ::common::memory_t& ptr() const;
  ::common::memory_t* mutable_ptr();
  ::common::memory_t* release_ptr();
  void set_allocated_ptr(::common::memory_t* ptr);

  // required uint64 size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required uint64 nmemb = 3;
  bool has_nmemb() const;
  void clear_nmemb();
  static const int kNmembFieldNumber = 3;
  ::google::protobuf::uint64 nmemb() const;
  void set_nmemb(::google::protobuf::uint64 value);

  // required uint64 stream = 4;
  bool has_stream() const;
  void clear_stream();
  static const int kStreamFieldNumber = 4;
  ::google::protobuf::uint64 stream() const;
  void set_stream(::google::protobuf::uint64 value);

  // required uint64 ret = 5;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 5;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.fread_t)
 private:
  void set_has_ptr();
  void clear_has_ptr();
  void set_has_size();
  void clear_has_size();
  void set_has_nmemb();
  void clear_has_nmemb();
  void set_has_stream();
  void clear_has_stream();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* ptr_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint64 nmemb_;
  ::google::protobuf::uint64 stream_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class strchr_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.strchr_t) */ {
 public:
  strchr_t();
  virtual ~strchr_t();

  strchr_t(const strchr_t& from);

  inline strchr_t& operator=(const strchr_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const strchr_t& default_instance();

  static inline const strchr_t* internal_default_instance() {
    return reinterpret_cast<const strchr_t*>(
               &_strchr_t_default_instance_);
  }

  void Swap(strchr_t* other);

  // implements Message ----------------------------------------------

  inline strchr_t* New() const PROTOBUF_FINAL { return New(NULL); }

  strchr_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const strchr_t& from);
  void MergeFrom(const strchr_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(strchr_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 s = 1;
  bool has_s() const;
  void clear_s();
  static const int kSFieldNumber = 1;
  ::google::protobuf::uint64 s() const;
  void set_s(::google::protobuf::uint64 value);

  // required uint64 c = 2;
  bool has_c() const;
  void clear_c();
  static const int kCFieldNumber = 2;
  ::google::protobuf::uint64 c() const;
  void set_c(::google::protobuf::uint64 value);

  // required uint64 size_max = 3;
  bool has_size_max() const;
  void clear_size_max();
  static const int kSizeMaxFieldNumber = 3;
  ::google::protobuf::uint64 size_max() const;
  void set_size_max(::google::protobuf::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.strchr_t)
 private:
  void set_has_s();
  void clear_has_s();
  void set_has_c();
  void clear_has_c();
  void set_has_size_max();
  void clear_has_size_max();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 s_;
  ::google::protobuf::uint64 c_;
  ::google::protobuf::uint64 size_max_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class strncpy_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.strncpy_t) */ {
 public:
  strncpy_t();
  virtual ~strncpy_t();

  strncpy_t(const strncpy_t& from);

  inline strncpy_t& operator=(const strncpy_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const strncpy_t& default_instance();

  static inline const strncpy_t* internal_default_instance() {
    return reinterpret_cast<const strncpy_t*>(
               &_strncpy_t_default_instance_);
  }

  void Swap(strncpy_t* other);

  // implements Message ----------------------------------------------

  inline strncpy_t* New() const PROTOBUF_FINAL { return New(NULL); }

  strncpy_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const strncpy_t& from);
  void MergeFrom(const strncpy_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(strncpy_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 dst = 1;
  bool has_dst() const;
  void clear_dst();
  static const int kDstFieldNumber = 1;
  ::google::protobuf::uint64 dst() const;
  void set_dst(::google::protobuf::uint64 value);

  // required uint64 src = 2;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 2;
  ::google::protobuf::uint64 src() const;
  void set_src(::google::protobuf::uint64 value);

  // required uint64 n = 3;
  bool has_n() const;
  void clear_n();
  static const int kNFieldNumber = 3;
  ::google::protobuf::uint64 n() const;
  void set_n(::google::protobuf::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.strncpy_t)
 private:
  void set_has_dst();
  void clear_has_dst();
  void set_has_src();
  void clear_has_src();
  void set_has_n();
  void clear_has_n();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 dst_;
  ::google::protobuf::uint64 src_;
  ::google::protobuf::uint64 n_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class fstat_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.fstat_t) */ {
 public:
  fstat_t();
  virtual ~fstat_t();

  fstat_t(const fstat_t& from);

  inline fstat_t& operator=(const fstat_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fstat_t& default_instance();

  static inline const fstat_t* internal_default_instance() {
    return reinterpret_cast<const fstat_t*>(
               &_fstat_t_default_instance_);
  }

  void Swap(fstat_t* other);

  // implements Message ----------------------------------------------

  inline fstat_t* New() const PROTOBUF_FINAL { return New(NULL); }

  fstat_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const fstat_t& from);
  void MergeFrom(const fstat_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(fstat_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t buf = 2;
  bool has_buf() const;
  void clear_buf();
  static const int kBufFieldNumber = 2;
  const ::common::memory_t& buf() const;
  ::common::memory_t* mutable_buf();
  ::common::memory_t* release_buf();
  void set_allocated_buf(::common::memory_t* buf);

  // required uint64 fd = 1;
  bool has_fd() const;
  void clear_fd();
  static const int kFdFieldNumber = 1;
  ::google::protobuf::uint64 fd() const;
  void set_fd(::google::protobuf::uint64 value);

  // required uint64 ret = 3;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 3;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.fstat_t)
 private:
  void set_has_fd();
  void clear_has_fd();
  void set_has_buf();
  void clear_has_buf();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* buf_;
  ::google::protobuf::uint64 fd_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class fxstat64_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.fxstat64_t) */ {
 public:
  fxstat64_t();
  virtual ~fxstat64_t();

  fxstat64_t(const fxstat64_t& from);

  inline fxstat64_t& operator=(const fxstat64_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fxstat64_t& default_instance();

  static inline const fxstat64_t* internal_default_instance() {
    return reinterpret_cast<const fxstat64_t*>(
               &_fxstat64_t_default_instance_);
  }

  void Swap(fxstat64_t* other);

  // implements Message ----------------------------------------------

  inline fxstat64_t* New() const PROTOBUF_FINAL { return New(NULL); }

  fxstat64_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const fxstat64_t& from);
  void MergeFrom(const fxstat64_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(fxstat64_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t buf = 3;
  bool has_buf() const;
  void clear_buf();
  static const int kBufFieldNumber = 3;
  const ::common::memory_t& buf() const;
  ::common::memory_t* mutable_buf();
  ::common::memory_t* release_buf();
  void set_allocated_buf(::common::memory_t* buf);

  // required uint64 vers = 1;
  bool has_vers() const;
  void clear_vers();
  static const int kVersFieldNumber = 1;
  ::google::protobuf::uint64 vers() const;
  void set_vers(::google::protobuf::uint64 value);

  // required uint64 fd = 2;
  bool has_fd() const;
  void clear_fd();
  static const int kFdFieldNumber = 2;
  ::google::protobuf::uint64 fd() const;
  void set_fd(::google::protobuf::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.fxstat64_t)
 private:
  void set_has_vers();
  void clear_has_vers();
  void set_has_fd();
  void clear_has_fd();
  void set_has_buf();
  void clear_has_buf();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* buf_;
  ::google::protobuf::uint64 vers_;
  ::google::protobuf::uint64 fd_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class realloc_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.realloc_t) */ {
 public:
  realloc_t();
  virtual ~realloc_t();

  realloc_t(const realloc_t& from);

  inline realloc_t& operator=(const realloc_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const realloc_t& default_instance();

  static inline const realloc_t* internal_default_instance() {
    return reinterpret_cast<const realloc_t*>(
               &_realloc_t_default_instance_);
  }

  void Swap(realloc_t* other);

  // implements Message ----------------------------------------------

  inline realloc_t* New() const PROTOBUF_FINAL { return New(NULL); }

  realloc_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const realloc_t& from);
  void MergeFrom(const realloc_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(realloc_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 ptr = 1;
  bool has_ptr() const;
  void clear_ptr();
  static const int kPtrFieldNumber = 1;
  ::google::protobuf::uint64 ptr() const;
  void set_ptr(::google::protobuf::uint64 value);

  // required uint64 size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required uint64 ret = 3;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 3;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.realloc_t)
 private:
  void set_has_ptr();
  void clear_has_ptr();
  void set_has_size();
  void clear_has_size();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 ptr_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class mmap_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.mmap_t) */ {
 public:
  mmap_t();
  virtual ~mmap_t();

  mmap_t(const mmap_t& from);

  inline mmap_t& operator=(const mmap_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mmap_t& default_instance();

  static inline const mmap_t* internal_default_instance() {
    return reinterpret_cast<const mmap_t*>(
               &_mmap_t_default_instance_);
  }

  void Swap(mmap_t* other);

  // implements Message ----------------------------------------------

  inline mmap_t* New() const PROTOBUF_FINAL { return New(NULL); }

  mmap_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const mmap_t& from);
  void MergeFrom(const mmap_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(mmap_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t ret = 7;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 7;
  const ::common::memory_t& ret() const;
  ::common::memory_t* mutable_ret();
  ::common::memory_t* release_ret();
  void set_allocated_ret(::common::memory_t* ret);

  // required uint64 addr = 1;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  ::google::protobuf::uint64 addr() const;
  void set_addr(::google::protobuf::uint64 value);

  // required uint64 length = 2;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::uint64 length() const;
  void set_length(::google::protobuf::uint64 value);

  // required uint64 prot = 3;
  bool has_prot() const;
  void clear_prot();
  static const int kProtFieldNumber = 3;
  ::google::protobuf::uint64 prot() const;
  void set_prot(::google::protobuf::uint64 value);

  // required uint64 flags = 4;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 4;
  ::google::protobuf::uint64 flags() const;
  void set_flags(::google::protobuf::uint64 value);

  // required uint64 fd = 5;
  bool has_fd() const;
  void clear_fd();
  static const int kFdFieldNumber = 5;
  ::google::protobuf::uint64 fd() const;
  void set_fd(::google::protobuf::uint64 value);

  // required uint64 offset = 6;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 6;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.mmap_t)
 private:
  void set_has_addr();
  void clear_has_addr();
  void set_has_length();
  void clear_has_length();
  void set_has_prot();
  void clear_has_prot();
  void set_has_flags();
  void clear_has_flags();
  void set_has_fd();
  void clear_has_fd();
  void set_has_offset();
  void clear_has_offset();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* ret_;
  ::google::protobuf::uint64 addr_;
  ::google::protobuf::uint64 length_;
  ::google::protobuf::uint64 prot_;
  ::google::protobuf::uint64 flags_;
  ::google::protobuf::uint64 fd_;
  ::google::protobuf::uint64 offset_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class qsort_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.qsort_t) */ {
 public:
  qsort_t();
  virtual ~qsort_t();

  qsort_t(const qsort_t& from);

  inline qsort_t& operator=(const qsort_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const qsort_t& default_instance();

  static inline const qsort_t* internal_default_instance() {
    return reinterpret_cast<const qsort_t*>(
               &_qsort_t_default_instance_);
  }

  void Swap(qsort_t* other);

  // implements Message ----------------------------------------------

  inline qsort_t* New() const PROTOBUF_FINAL { return New(NULL); }

  qsort_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const qsort_t& from);
  void MergeFrom(const qsort_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(qsort_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t base = 1;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 1;
  const ::common::memory_t& base() const;
  ::common::memory_t* mutable_base();
  ::common::memory_t* release_base();
  void set_allocated_base(::common::memory_t* base);

  // required uint64 nmemb = 2;
  bool has_nmemb() const;
  void clear_nmemb();
  static const int kNmembFieldNumber = 2;
  ::google::protobuf::uint64 nmemb() const;
  void set_nmemb(::google::protobuf::uint64 value);

  // required uint64 size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required uint64 compare = 4;
  bool has_compare() const;
  void clear_compare();
  static const int kCompareFieldNumber = 4;
  ::google::protobuf::uint64 compare() const;
  void set_compare(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.qsort_t)
 private:
  void set_has_base();
  void clear_has_base();
  void set_has_nmemb();
  void clear_has_nmemb();
  void set_has_size();
  void clear_has_size();
  void set_has_compare();
  void clear_has_compare();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* base_;
  ::google::protobuf::uint64 nmemb_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint64 compare_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class bsearch_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.bsearch_t) */ {
 public:
  bsearch_t();
  virtual ~bsearch_t();

  bsearch_t(const bsearch_t& from);

  inline bsearch_t& operator=(const bsearch_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const bsearch_t& default_instance();

  static inline const bsearch_t* internal_default_instance() {
    return reinterpret_cast<const bsearch_t*>(
               &_bsearch_t_default_instance_);
  }

  void Swap(bsearch_t* other);

  // implements Message ----------------------------------------------

  inline bsearch_t* New() const PROTOBUF_FINAL { return New(NULL); }

  bsearch_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const bsearch_t& from);
  void MergeFrom(const bsearch_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(bsearch_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::common::memory_t& key() const;
  ::common::memory_t* mutable_key();
  ::common::memory_t* release_key();
  void set_allocated_key(::common::memory_t* key);

  // required .common.memory_t base = 2;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 2;
  const ::common::memory_t& base() const;
  ::common::memory_t* mutable_base();
  ::common::memory_t* release_base();
  void set_allocated_base(::common::memory_t* base);

  // required .common.memory_t ret = 6;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 6;
  const ::common::memory_t& ret() const;
  ::common::memory_t* mutable_ret();
  ::common::memory_t* release_ret();
  void set_allocated_ret(::common::memory_t* ret);

  // required uint64 nmemb = 3;
  bool has_nmemb() const;
  void clear_nmemb();
  static const int kNmembFieldNumber = 3;
  ::google::protobuf::uint64 nmemb() const;
  void set_nmemb(::google::protobuf::uint64 value);

  // required uint64 size = 4;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required uint64 compare = 5;
  bool has_compare() const;
  void clear_compare();
  static const int kCompareFieldNumber = 5;
  ::google::protobuf::uint64 compare() const;
  void set_compare(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.bsearch_t)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_base();
  void clear_has_base();
  void set_has_nmemb();
  void clear_has_nmemb();
  void set_has_size();
  void clear_has_size();
  void set_has_compare();
  void clear_has_compare();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* key_;
  ::common::memory_t* base_;
  ::common::memory_t* ret_;
  ::google::protobuf::uint64 nmemb_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint64 compare_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class open_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.open_t) */ {
 public:
  open_t();
  virtual ~open_t();

  open_t(const open_t& from);

  inline open_t& operator=(const open_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const open_t& default_instance();

  static inline const open_t* internal_default_instance() {
    return reinterpret_cast<const open_t*>(
               &_open_t_default_instance_);
  }

  void Swap(open_t* other);

  // implements Message ----------------------------------------------

  inline open_t* New() const PROTOBUF_FINAL { return New(NULL); }

  open_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const open_t& from);
  void MergeFrom(const open_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(open_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t pathname = 1;
  bool has_pathname() const;
  void clear_pathname();
  static const int kPathnameFieldNumber = 1;
  const ::common::memory_t& pathname() const;
  ::common::memory_t* mutable_pathname();
  ::common::memory_t* release_pathname();
  void set_allocated_pathname(::common::memory_t* pathname);

  // required uint64 flags = 3;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 3;
  ::google::protobuf::uint64 flags() const;
  void set_flags(::google::protobuf::uint64 value);

  // required uint64 mode = 4;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::google::protobuf::uint64 mode() const;
  void set_mode(::google::protobuf::uint64 value);

  // required uint64 ret = 5;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 5;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.open_t)
 private:
  void set_has_pathname();
  void clear_has_pathname();
  void set_has_flags();
  void clear_has_flags();
  void set_has_mode();
  void clear_has_mode();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* pathname_;
  ::google::protobuf::uint64 flags_;
  ::google::protobuf::uint64 mode_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class strcpy_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.strcpy_t) */ {
 public:
  strcpy_t();
  virtual ~strcpy_t();

  strcpy_t(const strcpy_t& from);

  inline strcpy_t& operator=(const strcpy_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const strcpy_t& default_instance();

  static inline const strcpy_t* internal_default_instance() {
    return reinterpret_cast<const strcpy_t*>(
               &_strcpy_t_default_instance_);
  }

  void Swap(strcpy_t* other);

  // implements Message ----------------------------------------------

  inline strcpy_t* New() const PROTOBUF_FINAL { return New(NULL); }

  strcpy_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const strcpy_t& from);
  void MergeFrom(const strcpy_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(strcpy_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t src = 1;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  const ::common::memory_t& src() const;
  ::common::memory_t* mutable_src();
  ::common::memory_t* release_src();
  void set_allocated_src(::common::memory_t* src);

  // required .common.memory_t dst = 2;
  bool has_dst() const;
  void clear_dst();
  static const int kDstFieldNumber = 2;
  const ::common::memory_t& dst() const;
  ::common::memory_t* mutable_dst();
  ::common::memory_t* release_dst();
  void set_allocated_dst(::common::memory_t* dst);

  // required uint64 ret = 3;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 3;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.strcpy_t)
 private:
  void set_has_src();
  void clear_has_src();
  void set_has_dst();
  void clear_has_dst();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* src_;
  ::common::memory_t* dst_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class strcmp_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.strcmp_t) */ {
 public:
  strcmp_t();
  virtual ~strcmp_t();

  strcmp_t(const strcmp_t& from);

  inline strcmp_t& operator=(const strcmp_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const strcmp_t& default_instance();

  static inline const strcmp_t* internal_default_instance() {
    return reinterpret_cast<const strcmp_t*>(
               &_strcmp_t_default_instance_);
  }

  void Swap(strcmp_t* other);

  // implements Message ----------------------------------------------

  inline strcmp_t* New() const PROTOBUF_FINAL { return New(NULL); }

  strcmp_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const strcmp_t& from);
  void MergeFrom(const strcmp_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(strcmp_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 s1 = 1;
  bool has_s1() const;
  void clear_s1();
  static const int kS1FieldNumber = 1;
  ::google::protobuf::uint64 s1() const;
  void set_s1(::google::protobuf::uint64 value);

  // required uint64 s2 = 2;
  bool has_s2() const;
  void clear_s2();
  static const int kS2FieldNumber = 2;
  ::google::protobuf::uint64 s2() const;
  void set_s2(::google::protobuf::uint64 value);

  // required uint64 size_max_s1 = 3;
  bool has_size_max_s1() const;
  void clear_size_max_s1();
  static const int kSizeMaxS1FieldNumber = 3;
  ::google::protobuf::uint64 size_max_s1() const;
  void set_size_max_s1(::google::protobuf::uint64 value);

  // required uint64 size_max_s2 = 4;
  bool has_size_max_s2() const;
  void clear_size_max_s2();
  static const int kSizeMaxS2FieldNumber = 4;
  ::google::protobuf::uint64 size_max_s2() const;
  void set_size_max_s2(::google::protobuf::uint64 value);

  // required uint64 ret = 5;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 5;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.strcmp_t)
 private:
  void set_has_s1();
  void clear_has_s1();
  void set_has_s2();
  void clear_has_s2();
  void set_has_size_max_s1();
  void clear_has_size_max_s1();
  void set_has_size_max_s2();
  void clear_has_size_max_s2();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 s1_;
  ::google::protobuf::uint64 s2_;
  ::google::protobuf::uint64 size_max_s1_;
  ::google::protobuf::uint64 size_max_s2_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class strncmp_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.strncmp_t) */ {
 public:
  strncmp_t();
  virtual ~strncmp_t();

  strncmp_t(const strncmp_t& from);

  inline strncmp_t& operator=(const strncmp_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const strncmp_t& default_instance();

  static inline const strncmp_t* internal_default_instance() {
    return reinterpret_cast<const strncmp_t*>(
               &_strncmp_t_default_instance_);
  }

  void Swap(strncmp_t* other);

  // implements Message ----------------------------------------------

  inline strncmp_t* New() const PROTOBUF_FINAL { return New(NULL); }

  strncmp_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const strncmp_t& from);
  void MergeFrom(const strncmp_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(strncmp_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 s1 = 1;
  bool has_s1() const;
  void clear_s1();
  static const int kS1FieldNumber = 1;
  ::google::protobuf::uint64 s1() const;
  void set_s1(::google::protobuf::uint64 value);

  // required uint64 s2 = 2;
  bool has_s2() const;
  void clear_s2();
  static const int kS2FieldNumber = 2;
  ::google::protobuf::uint64 s2() const;
  void set_s2(::google::protobuf::uint64 value);

  // required uint64 n = 3;
  bool has_n() const;
  void clear_n();
  static const int kNFieldNumber = 3;
  ::google::protobuf::uint64 n() const;
  void set_n(::google::protobuf::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.strncmp_t)
 private:
  void set_has_s1();
  void clear_has_s1();
  void set_has_s2();
  void clear_has_s2();
  void set_has_n();
  void clear_has_n();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 s1_;
  ::google::protobuf::uint64 s2_;
  ::google::protobuf::uint64 n_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class memcmp_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.memcmp_t) */ {
 public:
  memcmp_t();
  virtual ~memcmp_t();

  memcmp_t(const memcmp_t& from);

  inline memcmp_t& operator=(const memcmp_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const memcmp_t& default_instance();

  static inline const memcmp_t* internal_default_instance() {
    return reinterpret_cast<const memcmp_t*>(
               &_memcmp_t_default_instance_);
  }

  void Swap(memcmp_t* other);

  // implements Message ----------------------------------------------

  inline memcmp_t* New() const PROTOBUF_FINAL { return New(NULL); }

  memcmp_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const memcmp_t& from);
  void MergeFrom(const memcmp_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(memcmp_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 s1 = 1;
  bool has_s1() const;
  void clear_s1();
  static const int kS1FieldNumber = 1;
  ::google::protobuf::uint64 s1() const;
  void set_s1(::google::protobuf::uint64 value);

  // required uint64 s2 = 2;
  bool has_s2() const;
  void clear_s2();
  static const int kS2FieldNumber = 2;
  ::google::protobuf::uint64 s2() const;
  void set_s2(::google::protobuf::uint64 value);

  // required uint64 n = 3;
  bool has_n() const;
  void clear_n();
  static const int kNFieldNumber = 3;
  ::google::protobuf::uint64 n() const;
  void set_n(::google::protobuf::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.memcmp_t)
 private:
  void set_has_s1();
  void clear_has_s1();
  void set_has_s2();
  void clear_has_s2();
  void set_has_n();
  void clear_has_n();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 s1_;
  ::google::protobuf::uint64 s2_;
  ::google::protobuf::uint64 n_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class printf_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.printf_t) */ {
 public:
  printf_t();
  virtual ~printf_t();

  printf_t(const printf_t& from);

  inline printf_t& operator=(const printf_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const printf_t& default_instance();

  static inline const printf_t* internal_default_instance() {
    return reinterpret_cast<const printf_t*>(
               &_printf_t_default_instance_);
  }

  void Swap(printf_t* other);

  // implements Message ----------------------------------------------

  inline printf_t* New() const PROTOBUF_FINAL { return New(NULL); }

  printf_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const printf_t& from);
  void MergeFrom(const printf_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(printf_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t format = 1;
  bool has_format() const;
  void clear_format();
  static const int kFormatFieldNumber = 1;
  const ::common::memory_t& format() const;
  ::common::memory_t* mutable_format();
  ::common::memory_t* release_format();
  void set_allocated_format(::common::memory_t* format);

  // required uint64 ret = 2;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 2;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.printf_t)
 private:
  void set_has_format();
  void clear_has_format();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* format_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class atoi_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.atoi_t) */ {
 public:
  atoi_t();
  virtual ~atoi_t();

  atoi_t(const atoi_t& from);

  inline atoi_t& operator=(const atoi_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const atoi_t& default_instance();

  static inline const atoi_t* internal_default_instance() {
    return reinterpret_cast<const atoi_t*>(
               &_atoi_t_default_instance_);
  }

  void Swap(atoi_t* other);

  // implements Message ----------------------------------------------

  inline atoi_t* New() const PROTOBUF_FINAL { return New(NULL); }

  atoi_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const atoi_t& from);
  void MergeFrom(const atoi_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(atoi_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t src = 1;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 1;
  const ::common::memory_t& src() const;
  ::common::memory_t* mutable_src();
  ::common::memory_t* release_src();
  void set_allocated_src(::common::memory_t* src);

  // required uint64 ret = 3;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 3;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.atoi_t)
 private:
  void set_has_src();
  void clear_has_src();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* src_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class malloc_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.malloc_t) */ {
 public:
  malloc_t();
  virtual ~malloc_t();

  malloc_t(const malloc_t& from);

  inline malloc_t& operator=(const malloc_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const malloc_t& default_instance();

  static inline const malloc_t* internal_default_instance() {
    return reinterpret_cast<const malloc_t*>(
               &_malloc_t_default_instance_);
  }

  void Swap(malloc_t* other);

  // implements Message ----------------------------------------------

  inline malloc_t* New() const PROTOBUF_FINAL { return New(NULL); }

  malloc_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const malloc_t& from);
  void MergeFrom(const malloc_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(malloc_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 size = 1;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 1;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required uint64 ret = 2;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 2;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.malloc_t)
 private:
  void set_has_size();
  void clear_has_size();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class getmodulehandle_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.getmodulehandle_t) */ {
 public:
  getmodulehandle_t();
  virtual ~getmodulehandle_t();

  getmodulehandle_t(const getmodulehandle_t& from);

  inline getmodulehandle_t& operator=(const getmodulehandle_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const getmodulehandle_t& default_instance();

  static inline const getmodulehandle_t* internal_default_instance() {
    return reinterpret_cast<const getmodulehandle_t*>(
               &_getmodulehandle_t_default_instance_);
  }

  void Swap(getmodulehandle_t* other);

  // implements Message ----------------------------------------------

  inline getmodulehandle_t* New() const PROTOBUF_FINAL { return New(NULL); }

  getmodulehandle_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const getmodulehandle_t& from);
  void MergeFrom(const getmodulehandle_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(getmodulehandle_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t module_name = 1;
  bool has_module_name() const;
  void clear_module_name();
  static const int kModuleNameFieldNumber = 1;
  const ::common::memory_t& module_name() const;
  ::common::memory_t* mutable_module_name();
  ::common::memory_t* release_module_name();
  void set_allocated_module_name(::common::memory_t* module_name);

  // required uint64 ret = 2;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 2;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.getmodulehandle_t)
 private:
  void set_has_module_name();
  void clear_has_module_name();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* module_name_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class getprocaddress_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.getprocaddress_t) */ {
 public:
  getprocaddress_t();
  virtual ~getprocaddress_t();

  getprocaddress_t(const getprocaddress_t& from);

  inline getprocaddress_t& operator=(const getprocaddress_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const getprocaddress_t& default_instance();

  static inline const getprocaddress_t* internal_default_instance() {
    return reinterpret_cast<const getprocaddress_t*>(
               &_getprocaddress_t_default_instance_);
  }

  void Swap(getprocaddress_t* other);

  // implements Message ----------------------------------------------

  inline getprocaddress_t* New() const PROTOBUF_FINAL { return New(NULL); }

  getprocaddress_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const getprocaddress_t& from);
  void MergeFrom(const getprocaddress_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(getprocaddress_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t proc_name = 2;
  bool has_proc_name() const;
  void clear_proc_name();
  static const int kProcNameFieldNumber = 2;
  const ::common::memory_t& proc_name() const;
  ::common::memory_t* mutable_proc_name();
  ::common::memory_t* release_proc_name();
  void set_allocated_proc_name(::common::memory_t* proc_name);

  // required uint64 hmodule = 1;
  bool has_hmodule() const;
  void clear_hmodule();
  static const int kHmoduleFieldNumber = 1;
  ::google::protobuf::uint64 hmodule() const;
  void set_hmodule(::google::protobuf::uint64 value);

  // required uint64 ret = 3;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 3;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.getprocaddress_t)
 private:
  void set_has_hmodule();
  void clear_has_hmodule();
  void set_has_proc_name();
  void clear_has_proc_name();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* proc_name_;
  ::google::protobuf::uint64 hmodule_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class getmainargs_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.getmainargs_t) */ {
 public:
  getmainargs_t();
  virtual ~getmainargs_t();

  getmainargs_t(const getmainargs_t& from);

  inline getmainargs_t& operator=(const getmainargs_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const getmainargs_t& default_instance();

  static inline const getmainargs_t* internal_default_instance() {
    return reinterpret_cast<const getmainargs_t*>(
               &_getmainargs_t_default_instance_);
  }

  void Swap(getmainargs_t* other);

  // implements Message ----------------------------------------------

  inline getmainargs_t* New() const PROTOBUF_FINAL { return New(NULL); }

  getmainargs_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const getmainargs_t& from);
  void MergeFrom(const getmainargs_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(getmainargs_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t argc = 1;
  bool has_argc() const;
  void clear_argc();
  static const int kArgcFieldNumber = 1;
  const ::common::memory_t& argc() const;
  ::common::memory_t* mutable_argc();
  ::common::memory_t* release_argc();
  void set_allocated_argc(::common::memory_t* argc);

  // required .common.memory_t argv = 2;
  bool has_argv() const;
  void clear_argv();
  static const int kArgvFieldNumber = 2;
  const ::common::memory_t& argv() const;
  ::common::memory_t* mutable_argv();
  ::common::memory_t* release_argv();
  void set_allocated_argv(::common::memory_t* argv);

  // required .common.memory_t env = 3;
  bool has_env() const;
  void clear_env();
  static const int kEnvFieldNumber = 3;
  const ::common::memory_t& env() const;
  ::common::memory_t* mutable_env();
  ::common::memory_t* release_env();
  void set_allocated_env(::common::memory_t* env);

  // required .common.memory_t startinfo = 5;
  bool has_startinfo() const;
  void clear_startinfo();
  static const int kStartinfoFieldNumber = 5;
  const ::common::memory_t& startinfo() const;
  ::common::memory_t* mutable_startinfo();
  ::common::memory_t* release_startinfo();
  void set_allocated_startinfo(::common::memory_t* startinfo);

  // required uint64 dowildcard = 4;
  bool has_dowildcard() const;
  void clear_dowildcard();
  static const int kDowildcardFieldNumber = 4;
  ::google::protobuf::uint64 dowildcard() const;
  void set_dowildcard(::google::protobuf::uint64 value);

  // required uint64 ret = 6;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 6;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.getmainargs_t)
 private:
  void set_has_argc();
  void clear_has_argc();
  void set_has_argv();
  void clear_has_argv();
  void set_has_env();
  void clear_has_env();
  void set_has_dowildcard();
  void clear_has_dowildcard();
  void set_has_startinfo();
  void clear_has_startinfo();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* argc_;
  ::common::memory_t* argv_;
  ::common::memory_t* env_;
  ::common::memory_t* startinfo_;
  ::google::protobuf::uint64 dowildcard_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class gethostname_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.gethostname_t) */ {
 public:
  gethostname_t();
  virtual ~gethostname_t();

  gethostname_t(const gethostname_t& from);

  inline gethostname_t& operator=(const gethostname_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gethostname_t& default_instance();

  static inline const gethostname_t* internal_default_instance() {
    return reinterpret_cast<const gethostname_t*>(
               &_gethostname_t_default_instance_);
  }

  void Swap(gethostname_t* other);

  // implements Message ----------------------------------------------

  inline gethostname_t* New() const PROTOBUF_FINAL { return New(NULL); }

  gethostname_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const gethostname_t& from);
  void MergeFrom(const gethostname_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(gethostname_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::common::memory_t& name() const;
  ::common::memory_t* mutable_name();
  ::common::memory_t* release_name();
  void set_allocated_name(::common::memory_t* name);

  // required uint64 namelen = 2;
  bool has_namelen() const;
  void clear_namelen();
  static const int kNamelenFieldNumber = 2;
  ::google::protobuf::uint64 namelen() const;
  void set_namelen(::google::protobuf::uint64 value);

  // required uint64 ret = 3;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 3;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.gethostname_t)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_namelen();
  void clear_has_namelen();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* name_;
  ::google::protobuf::uint64 namelen_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class free_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.free_t) */ {
 public:
  free_t();
  virtual ~free_t();

  free_t(const free_t& from);

  inline free_t& operator=(const free_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const free_t& default_instance();

  static inline const free_t* internal_default_instance() {
    return reinterpret_cast<const free_t*>(
               &_free_t_default_instance_);
  }

  void Swap(free_t* other);

  // implements Message ----------------------------------------------

  inline free_t* New() const PROTOBUF_FINAL { return New(NULL); }

  free_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const free_t& from);
  void MergeFrom(const free_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(free_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 ptr = 1;
  bool has_ptr() const;
  void clear_ptr();
  static const int kPtrFieldNumber = 1;
  ::google::protobuf::uint64 ptr() const;
  void set_ptr(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.free_t)
 private:
  void set_has_ptr();
  void clear_has_ptr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 ptr_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class memcpy_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.memcpy_t) */ {
 public:
  memcpy_t();
  virtual ~memcpy_t();

  memcpy_t(const memcpy_t& from);

  inline memcpy_t& operator=(const memcpy_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const memcpy_t& default_instance();

  static inline const memcpy_t* internal_default_instance() {
    return reinterpret_cast<const memcpy_t*>(
               &_memcpy_t_default_instance_);
  }

  void Swap(memcpy_t* other);

  // implements Message ----------------------------------------------

  inline memcpy_t* New() const PROTOBUF_FINAL { return New(NULL); }

  memcpy_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const memcpy_t& from);
  void MergeFrom(const memcpy_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(memcpy_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t dest = 1;
  bool has_dest() const;
  void clear_dest();
  static const int kDestFieldNumber = 1;
  const ::common::memory_t& dest() const;
  ::common::memory_t* mutable_dest();
  ::common::memory_t* release_dest();
  void set_allocated_dest(::common::memory_t* dest);

  // required .common.memory_t src = 2;
  bool has_src() const;
  void clear_src();
  static const int kSrcFieldNumber = 2;
  const ::common::memory_t& src() const;
  ::common::memory_t* mutable_src();
  ::common::memory_t* release_src();
  void set_allocated_src(::common::memory_t* src);

  // required uint64 size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.memcpy_t)
 private:
  void set_has_dest();
  void clear_has_dest();
  void set_has_src();
  void clear_has_src();
  void set_has_size();
  void clear_has_size();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* dest_;
  ::common::memory_t* src_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class memset_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.memset_t) */ {
 public:
  memset_t();
  virtual ~memset_t();

  memset_t(const memset_t& from);

  inline memset_t& operator=(const memset_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const memset_t& default_instance();

  static inline const memset_t* internal_default_instance() {
    return reinterpret_cast<const memset_t*>(
               &_memset_t_default_instance_);
  }

  void Swap(memset_t* other);

  // implements Message ----------------------------------------------

  inline memset_t* New() const PROTOBUF_FINAL { return New(NULL); }

  memset_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const memset_t& from);
  void MergeFrom(const memset_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(memset_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .common.memory_t s = 1;
  bool has_s() const;
  void clear_s();
  static const int kSFieldNumber = 1;
  const ::common::memory_t& s() const;
  ::common::memory_t* mutable_s();
  ::common::memory_t* release_s();
  void set_allocated_s(::common::memory_t* s);

  // required uint64 c = 2;
  bool has_c() const;
  void clear_c();
  static const int kCFieldNumber = 2;
  ::google::protobuf::uint64 c() const;
  void set_c(::google::protobuf::uint64 value);

  // required uint64 size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.memset_t)
 private:
  void set_has_s();
  void clear_has_s();
  void set_has_c();
  void clear_has_c();
  void set_has_size();
  void clear_has_size();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::common::memory_t* s_;
  ::google::protobuf::uint64 c_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class fgetc_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.fgetc_t) */ {
 public:
  fgetc_t();
  virtual ~fgetc_t();

  fgetc_t(const fgetc_t& from);

  inline fgetc_t& operator=(const fgetc_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fgetc_t& default_instance();

  static inline const fgetc_t* internal_default_instance() {
    return reinterpret_cast<const fgetc_t*>(
               &_fgetc_t_default_instance_);
  }

  void Swap(fgetc_t* other);

  // implements Message ----------------------------------------------

  inline fgetc_t* New() const PROTOBUF_FINAL { return New(NULL); }

  fgetc_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const fgetc_t& from);
  void MergeFrom(const fgetc_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(fgetc_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 stream = 1;
  bool has_stream() const;
  void clear_stream();
  static const int kStreamFieldNumber = 1;
  ::google::protobuf::uint64 stream() const;
  void set_stream(::google::protobuf::uint64 value);

  // required uint64 ret = 2;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 2;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.fgetc_t)
 private:
  void set_has_stream();
  void clear_has_stream();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 stream_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class lseek_t : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:libcall_types.lseek_t) */ {
 public:
  lseek_t();
  virtual ~lseek_t();

  lseek_t(const lseek_t& from);

  inline lseek_t& operator=(const lseek_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lseek_t& default_instance();

  static inline const lseek_t* internal_default_instance() {
    return reinterpret_cast<const lseek_t*>(
               &_lseek_t_default_instance_);
  }

  void Swap(lseek_t* other);

  // implements Message ----------------------------------------------

  inline lseek_t* New() const PROTOBUF_FINAL { return New(NULL); }

  lseek_t* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const lseek_t& from);
  void MergeFrom(const lseek_t& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(lseek_t* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 fd = 1;
  bool has_fd() const;
  void clear_fd();
  static const int kFdFieldNumber = 1;
  ::google::protobuf::uint64 fd() const;
  void set_fd(::google::protobuf::uint64 value);

  // required uint64 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // required uint64 whence = 3;
  bool has_whence() const;
  void clear_whence();
  static const int kWhenceFieldNumber = 3;
  ::google::protobuf::uint64 whence() const;
  void set_whence(::google::protobuf::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::google::protobuf::uint64 ret() const;
  void set_ret(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.lseek_t)
 private:
  void set_has_fd();
  void clear_has_fd();
  void set_has_offset();
  void clear_has_offset();
  void set_has_whence();
  void clear_has_whence();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 fd_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 whence_;
  ::google::protobuf::uint64 ret_;
  friend struct  protobuf_libcall_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// libcall_pol

// required string name = 1;
inline bool libcall_pol::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void libcall_pol::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void libcall_pol::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void libcall_pol::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& libcall_pol::name() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.name)
  return name_.GetNoArena();
}
inline void libcall_pol::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libcall_types.libcall_pol.name)
}
#if LANG_CXX11
inline void libcall_pol::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:libcall_types.libcall_pol.name)
}
#endif
inline void libcall_pol::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libcall_types.libcall_pol.name)
}
inline void libcall_pol::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libcall_types.libcall_pol.name)
}
inline ::std::string* libcall_pol::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* libcall_pol::release_name() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void libcall_pol::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.name)
}

// optional .libcall_types.lib_ident ident = 2 [default = GENERIC];
inline bool libcall_pol::has_ident() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void libcall_pol::set_has_ident() {
  _has_bits_[0] |= 0x00000004u;
}
inline void libcall_pol::clear_has_ident() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void libcall_pol::clear_ident() {
  ident_ = 255;
  clear_has_ident();
}
inline ::libcall_types::lib_ident libcall_pol::ident() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.ident)
  return static_cast< ::libcall_types::lib_ident >(ident_);
}
inline void libcall_pol::set_ident(::libcall_types::lib_ident value) {
  assert(::libcall_types::lib_ident_IsValid(value));
  set_has_ident();
  ident_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.libcall_pol.ident)
}

// optional .common.tracing_action action = 3 [default = SKIP];
inline bool libcall_pol::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void libcall_pol::set_has_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void libcall_pol::clear_has_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void libcall_pol::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::common::tracing_action libcall_pol::action() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.action)
  return static_cast< ::common::tracing_action >(action_);
}
inline void libcall_pol::set_action(::common::tracing_action value) {
  assert(::common::tracing_action_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.libcall_pol.action)
}

// repeated uint64 restrict_addresses = 4;
inline int libcall_pol::restrict_addresses_size() const {
  return restrict_addresses_.size();
}
inline void libcall_pol::clear_restrict_addresses() {
  restrict_addresses_.Clear();
}
inline ::google::protobuf::uint64 libcall_pol::restrict_addresses(int index) const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.restrict_addresses)
  return restrict_addresses_.Get(index);
}
inline void libcall_pol::set_restrict_addresses(int index, ::google::protobuf::uint64 value) {
  restrict_addresses_.Set(index, value);
  // @@protoc_insertion_point(field_set:libcall_types.libcall_pol.restrict_addresses)
}
inline void libcall_pol::add_restrict_addresses(::google::protobuf::uint64 value) {
  restrict_addresses_.Add(value);
  // @@protoc_insertion_point(field_add:libcall_types.libcall_pol.restrict_addresses)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
libcall_pol::restrict_addresses() const {
  // @@protoc_insertion_point(field_list:libcall_types.libcall_pol.restrict_addresses)
  return restrict_addresses_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
libcall_pol::mutable_restrict_addresses() {
  // @@protoc_insertion_point(field_mutable_list:libcall_types.libcall_pol.restrict_addresses)
  return &restrict_addresses_;
}

// optional .libcall_types.strcpy_pol strcpy = 5;
inline bool libcall_pol::has_strcpy() const {
  return libcall_cnt_case() == kStrcpy;
}
inline void libcall_pol::set_has_strcpy() {
  _oneof_case_[0] = kStrcpy;
}
inline void libcall_pol::clear_strcpy() {
  if (has_strcpy()) {
    delete libcall_cnt_.strcpy_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::strcpy_pol& libcall_pol::strcpy() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.strcpy)
  return has_strcpy()
      ? *libcall_cnt_.strcpy_
      : ::libcall_types::strcpy_pol::default_instance();
}
inline ::libcall_types::strcpy_pol* libcall_pol::mutable_strcpy() {
  if (!has_strcpy()) {
    clear_libcall_cnt();
    set_has_strcpy();
    libcall_cnt_.strcpy_ = new ::libcall_types::strcpy_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.strcpy)
  return libcall_cnt_.strcpy_;
}
inline ::libcall_types::strcpy_pol* libcall_pol::release_strcpy() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.strcpy)
  if (has_strcpy()) {
    clear_has_libcall_cnt();
    ::libcall_types::strcpy_pol* temp = libcall_cnt_.strcpy_;
    libcall_cnt_.strcpy_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_strcpy(::libcall_types::strcpy_pol* strcpy) {
  clear_libcall_cnt();
  if (strcpy) {
    set_has_strcpy();
    libcall_cnt_.strcpy_ = strcpy;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.strcpy)
}

// optional .libcall_types.printf_pol printf = 6;
inline bool libcall_pol::has_printf() const {
  return libcall_cnt_case() == kPrintf;
}
inline void libcall_pol::set_has_printf() {
  _oneof_case_[0] = kPrintf;
}
inline void libcall_pol::clear_printf() {
  if (has_printf()) {
    delete libcall_cnt_.printf_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::printf_pol& libcall_pol::printf() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.printf)
  return has_printf()
      ? *libcall_cnt_.printf_
      : ::libcall_types::printf_pol::default_instance();
}
inline ::libcall_types::printf_pol* libcall_pol::mutable_printf() {
  if (!has_printf()) {
    clear_libcall_cnt();
    set_has_printf();
    libcall_cnt_.printf_ = new ::libcall_types::printf_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.printf)
  return libcall_cnt_.printf_;
}
inline ::libcall_types::printf_pol* libcall_pol::release_printf() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.printf)
  if (has_printf()) {
    clear_has_libcall_cnt();
    ::libcall_types::printf_pol* temp = libcall_cnt_.printf_;
    libcall_cnt_.printf_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_printf(::libcall_types::printf_pol* printf) {
  clear_libcall_cnt();
  if (printf) {
    set_has_printf();
    libcall_cnt_.printf_ = printf;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.printf)
}

// optional .libcall_types.atoi_pol atoi = 7;
inline bool libcall_pol::has_atoi() const {
  return libcall_cnt_case() == kAtoi;
}
inline void libcall_pol::set_has_atoi() {
  _oneof_case_[0] = kAtoi;
}
inline void libcall_pol::clear_atoi() {
  if (has_atoi()) {
    delete libcall_cnt_.atoi_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::atoi_pol& libcall_pol::atoi() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.atoi)
  return has_atoi()
      ? *libcall_cnt_.atoi_
      : ::libcall_types::atoi_pol::default_instance();
}
inline ::libcall_types::atoi_pol* libcall_pol::mutable_atoi() {
  if (!has_atoi()) {
    clear_libcall_cnt();
    set_has_atoi();
    libcall_cnt_.atoi_ = new ::libcall_types::atoi_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.atoi)
  return libcall_cnt_.atoi_;
}
inline ::libcall_types::atoi_pol* libcall_pol::release_atoi() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.atoi)
  if (has_atoi()) {
    clear_has_libcall_cnt();
    ::libcall_types::atoi_pol* temp = libcall_cnt_.atoi_;
    libcall_cnt_.atoi_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_atoi(::libcall_types::atoi_pol* atoi) {
  clear_libcall_cnt();
  if (atoi) {
    set_has_atoi();
    libcall_cnt_.atoi_ = atoi;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.atoi)
}

// optional .libcall_types.malloc_pol malloc = 8;
inline bool libcall_pol::has_malloc() const {
  return libcall_cnt_case() == kMalloc;
}
inline void libcall_pol::set_has_malloc() {
  _oneof_case_[0] = kMalloc;
}
inline void libcall_pol::clear_malloc() {
  if (has_malloc()) {
    delete libcall_cnt_.malloc_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::malloc_pol& libcall_pol::malloc() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.malloc)
  return has_malloc()
      ? *libcall_cnt_.malloc_
      : ::libcall_types::malloc_pol::default_instance();
}
inline ::libcall_types::malloc_pol* libcall_pol::mutable_malloc() {
  if (!has_malloc()) {
    clear_libcall_cnt();
    set_has_malloc();
    libcall_cnt_.malloc_ = new ::libcall_types::malloc_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.malloc)
  return libcall_cnt_.malloc_;
}
inline ::libcall_types::malloc_pol* libcall_pol::release_malloc() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.malloc)
  if (has_malloc()) {
    clear_has_libcall_cnt();
    ::libcall_types::malloc_pol* temp = libcall_cnt_.malloc_;
    libcall_cnt_.malloc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_malloc(::libcall_types::malloc_pol* malloc) {
  clear_libcall_cnt();
  if (malloc) {
    set_has_malloc();
    libcall_cnt_.malloc_ = malloc;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.malloc)
}

// optional .libcall_types.getmodulehandle_pol getmodulehandle = 9;
inline bool libcall_pol::has_getmodulehandle() const {
  return libcall_cnt_case() == kGetmodulehandle;
}
inline void libcall_pol::set_has_getmodulehandle() {
  _oneof_case_[0] = kGetmodulehandle;
}
inline void libcall_pol::clear_getmodulehandle() {
  if (has_getmodulehandle()) {
    delete libcall_cnt_.getmodulehandle_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::getmodulehandle_pol& libcall_pol::getmodulehandle() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.getmodulehandle)
  return has_getmodulehandle()
      ? *libcall_cnt_.getmodulehandle_
      : ::libcall_types::getmodulehandle_pol::default_instance();
}
inline ::libcall_types::getmodulehandle_pol* libcall_pol::mutable_getmodulehandle() {
  if (!has_getmodulehandle()) {
    clear_libcall_cnt();
    set_has_getmodulehandle();
    libcall_cnt_.getmodulehandle_ = new ::libcall_types::getmodulehandle_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.getmodulehandle)
  return libcall_cnt_.getmodulehandle_;
}
inline ::libcall_types::getmodulehandle_pol* libcall_pol::release_getmodulehandle() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.getmodulehandle)
  if (has_getmodulehandle()) {
    clear_has_libcall_cnt();
    ::libcall_types::getmodulehandle_pol* temp = libcall_cnt_.getmodulehandle_;
    libcall_cnt_.getmodulehandle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_getmodulehandle(::libcall_types::getmodulehandle_pol* getmodulehandle) {
  clear_libcall_cnt();
  if (getmodulehandle) {
    set_has_getmodulehandle();
    libcall_cnt_.getmodulehandle_ = getmodulehandle;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.getmodulehandle)
}

// optional .libcall_types.getprocaddress_pol getprocaddress = 10;
inline bool libcall_pol::has_getprocaddress() const {
  return libcall_cnt_case() == kGetprocaddress;
}
inline void libcall_pol::set_has_getprocaddress() {
  _oneof_case_[0] = kGetprocaddress;
}
inline void libcall_pol::clear_getprocaddress() {
  if (has_getprocaddress()) {
    delete libcall_cnt_.getprocaddress_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::getprocaddress_pol& libcall_pol::getprocaddress() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.getprocaddress)
  return has_getprocaddress()
      ? *libcall_cnt_.getprocaddress_
      : ::libcall_types::getprocaddress_pol::default_instance();
}
inline ::libcall_types::getprocaddress_pol* libcall_pol::mutable_getprocaddress() {
  if (!has_getprocaddress()) {
    clear_libcall_cnt();
    set_has_getprocaddress();
    libcall_cnt_.getprocaddress_ = new ::libcall_types::getprocaddress_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.getprocaddress)
  return libcall_cnt_.getprocaddress_;
}
inline ::libcall_types::getprocaddress_pol* libcall_pol::release_getprocaddress() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.getprocaddress)
  if (has_getprocaddress()) {
    clear_has_libcall_cnt();
    ::libcall_types::getprocaddress_pol* temp = libcall_cnt_.getprocaddress_;
    libcall_cnt_.getprocaddress_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_getprocaddress(::libcall_types::getprocaddress_pol* getprocaddress) {
  clear_libcall_cnt();
  if (getprocaddress) {
    set_has_getprocaddress();
    libcall_cnt_.getprocaddress_ = getprocaddress;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.getprocaddress)
}

// optional .libcall_types.getmainargs_pol getmainargs = 11;
inline bool libcall_pol::has_getmainargs() const {
  return libcall_cnt_case() == kGetmainargs;
}
inline void libcall_pol::set_has_getmainargs() {
  _oneof_case_[0] = kGetmainargs;
}
inline void libcall_pol::clear_getmainargs() {
  if (has_getmainargs()) {
    delete libcall_cnt_.getmainargs_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::getmainargs_pol& libcall_pol::getmainargs() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.getmainargs)
  return has_getmainargs()
      ? *libcall_cnt_.getmainargs_
      : ::libcall_types::getmainargs_pol::default_instance();
}
inline ::libcall_types::getmainargs_pol* libcall_pol::mutable_getmainargs() {
  if (!has_getmainargs()) {
    clear_libcall_cnt();
    set_has_getmainargs();
    libcall_cnt_.getmainargs_ = new ::libcall_types::getmainargs_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.getmainargs)
  return libcall_cnt_.getmainargs_;
}
inline ::libcall_types::getmainargs_pol* libcall_pol::release_getmainargs() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.getmainargs)
  if (has_getmainargs()) {
    clear_has_libcall_cnt();
    ::libcall_types::getmainargs_pol* temp = libcall_cnt_.getmainargs_;
    libcall_cnt_.getmainargs_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_getmainargs(::libcall_types::getmainargs_pol* getmainargs) {
  clear_libcall_cnt();
  if (getmainargs) {
    set_has_getmainargs();
    libcall_cnt_.getmainargs_ = getmainargs;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.getmainargs)
}

// optional .libcall_types.gethostname_pol gethostname = 12;
inline bool libcall_pol::has_gethostname() const {
  return libcall_cnt_case() == kGethostname;
}
inline void libcall_pol::set_has_gethostname() {
  _oneof_case_[0] = kGethostname;
}
inline void libcall_pol::clear_gethostname() {
  if (has_gethostname()) {
    delete libcall_cnt_.gethostname_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::gethostname_pol& libcall_pol::gethostname() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.gethostname)
  return has_gethostname()
      ? *libcall_cnt_.gethostname_
      : ::libcall_types::gethostname_pol::default_instance();
}
inline ::libcall_types::gethostname_pol* libcall_pol::mutable_gethostname() {
  if (!has_gethostname()) {
    clear_libcall_cnt();
    set_has_gethostname();
    libcall_cnt_.gethostname_ = new ::libcall_types::gethostname_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.gethostname)
  return libcall_cnt_.gethostname_;
}
inline ::libcall_types::gethostname_pol* libcall_pol::release_gethostname() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.gethostname)
  if (has_gethostname()) {
    clear_has_libcall_cnt();
    ::libcall_types::gethostname_pol* temp = libcall_cnt_.gethostname_;
    libcall_cnt_.gethostname_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_gethostname(::libcall_types::gethostname_pol* gethostname) {
  clear_libcall_cnt();
  if (gethostname) {
    set_has_gethostname();
    libcall_cnt_.gethostname_ = gethostname;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.gethostname)
}

// optional .libcall_types.free_pol free = 13;
inline bool libcall_pol::has_free() const {
  return libcall_cnt_case() == kFree;
}
inline void libcall_pol::set_has_free() {
  _oneof_case_[0] = kFree;
}
inline void libcall_pol::clear_free() {
  if (has_free()) {
    delete libcall_cnt_.free_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::free_pol& libcall_pol::free() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.free)
  return has_free()
      ? *libcall_cnt_.free_
      : ::libcall_types::free_pol::default_instance();
}
inline ::libcall_types::free_pol* libcall_pol::mutable_free() {
  if (!has_free()) {
    clear_libcall_cnt();
    set_has_free();
    libcall_cnt_.free_ = new ::libcall_types::free_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.free)
  return libcall_cnt_.free_;
}
inline ::libcall_types::free_pol* libcall_pol::release_free() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.free)
  if (has_free()) {
    clear_has_libcall_cnt();
    ::libcall_types::free_pol* temp = libcall_cnt_.free_;
    libcall_cnt_.free_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_free(::libcall_types::free_pol* free) {
  clear_libcall_cnt();
  if (free) {
    set_has_free();
    libcall_cnt_.free_ = free;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.free)
}

// optional .libcall_types.memcpy_pol memcpy = 14;
inline bool libcall_pol::has_memcpy() const {
  return libcall_cnt_case() == kMemcpy;
}
inline void libcall_pol::set_has_memcpy() {
  _oneof_case_[0] = kMemcpy;
}
inline void libcall_pol::clear_memcpy() {
  if (has_memcpy()) {
    delete libcall_cnt_.memcpy_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::memcpy_pol& libcall_pol::memcpy() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.memcpy)
  return has_memcpy()
      ? *libcall_cnt_.memcpy_
      : ::libcall_types::memcpy_pol::default_instance();
}
inline ::libcall_types::memcpy_pol* libcall_pol::mutable_memcpy() {
  if (!has_memcpy()) {
    clear_libcall_cnt();
    set_has_memcpy();
    libcall_cnt_.memcpy_ = new ::libcall_types::memcpy_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.memcpy)
  return libcall_cnt_.memcpy_;
}
inline ::libcall_types::memcpy_pol* libcall_pol::release_memcpy() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.memcpy)
  if (has_memcpy()) {
    clear_has_libcall_cnt();
    ::libcall_types::memcpy_pol* temp = libcall_cnt_.memcpy_;
    libcall_cnt_.memcpy_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_memcpy(::libcall_types::memcpy_pol* memcpy) {
  clear_libcall_cnt();
  if (memcpy) {
    set_has_memcpy();
    libcall_cnt_.memcpy_ = memcpy;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.memcpy)
}

// optional .libcall_types.memset_pol memset = 15;
inline bool libcall_pol::has_memset() const {
  return libcall_cnt_case() == kMemset;
}
inline void libcall_pol::set_has_memset() {
  _oneof_case_[0] = kMemset;
}
inline void libcall_pol::clear_memset() {
  if (has_memset()) {
    delete libcall_cnt_.memset_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::memset_pol& libcall_pol::memset() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.memset)
  return has_memset()
      ? *libcall_cnt_.memset_
      : ::libcall_types::memset_pol::default_instance();
}
inline ::libcall_types::memset_pol* libcall_pol::mutable_memset() {
  if (!has_memset()) {
    clear_libcall_cnt();
    set_has_memset();
    libcall_cnt_.memset_ = new ::libcall_types::memset_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.memset)
  return libcall_cnt_.memset_;
}
inline ::libcall_types::memset_pol* libcall_pol::release_memset() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.memset)
  if (has_memset()) {
    clear_has_libcall_cnt();
    ::libcall_types::memset_pol* temp = libcall_cnt_.memset_;
    libcall_cnt_.memset_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_memset(::libcall_types::memset_pol* memset) {
  clear_libcall_cnt();
  if (memset) {
    set_has_memset();
    libcall_cnt_.memset_ = memset;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.memset)
}

// optional .libcall_types.fgetc_pol fgetc = 16;
inline bool libcall_pol::has_fgetc() const {
  return libcall_cnt_case() == kFgetc;
}
inline void libcall_pol::set_has_fgetc() {
  _oneof_case_[0] = kFgetc;
}
inline void libcall_pol::clear_fgetc() {
  if (has_fgetc()) {
    delete libcall_cnt_.fgetc_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::fgetc_pol& libcall_pol::fgetc() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.fgetc)
  return has_fgetc()
      ? *libcall_cnt_.fgetc_
      : ::libcall_types::fgetc_pol::default_instance();
}
inline ::libcall_types::fgetc_pol* libcall_pol::mutable_fgetc() {
  if (!has_fgetc()) {
    clear_libcall_cnt();
    set_has_fgetc();
    libcall_cnt_.fgetc_ = new ::libcall_types::fgetc_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.fgetc)
  return libcall_cnt_.fgetc_;
}
inline ::libcall_types::fgetc_pol* libcall_pol::release_fgetc() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.fgetc)
  if (has_fgetc()) {
    clear_has_libcall_cnt();
    ::libcall_types::fgetc_pol* temp = libcall_cnt_.fgetc_;
    libcall_cnt_.fgetc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_fgetc(::libcall_types::fgetc_pol* fgetc) {
  clear_libcall_cnt();
  if (fgetc) {
    set_has_fgetc();
    libcall_cnt_.fgetc_ = fgetc;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.fgetc)
}

// optional .libcall_types.read_pol read = 17;
inline bool libcall_pol::has_read() const {
  return libcall_cnt_case() == kRead;
}
inline void libcall_pol::set_has_read() {
  _oneof_case_[0] = kRead;
}
inline void libcall_pol::clear_read() {
  if (has_read()) {
    delete libcall_cnt_.read_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::read_pol& libcall_pol::read() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.read)
  return has_read()
      ? *libcall_cnt_.read_
      : ::libcall_types::read_pol::default_instance();
}
inline ::libcall_types::read_pol* libcall_pol::mutable_read() {
  if (!has_read()) {
    clear_libcall_cnt();
    set_has_read();
    libcall_cnt_.read_ = new ::libcall_types::read_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.read)
  return libcall_cnt_.read_;
}
inline ::libcall_types::read_pol* libcall_pol::release_read() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.read)
  if (has_read()) {
    clear_has_libcall_cnt();
    ::libcall_types::read_pol* temp = libcall_cnt_.read_;
    libcall_cnt_.read_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_read(::libcall_types::read_pol* read) {
  clear_libcall_cnt();
  if (read) {
    set_has_read();
    libcall_cnt_.read_ = read;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.read)
}

// optional .libcall_types.strchr_pol strchr = 18;
inline bool libcall_pol::has_strchr() const {
  return libcall_cnt_case() == kStrchr;
}
inline void libcall_pol::set_has_strchr() {
  _oneof_case_[0] = kStrchr;
}
inline void libcall_pol::clear_strchr() {
  if (has_strchr()) {
    delete libcall_cnt_.strchr_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::strchr_pol& libcall_pol::strchr() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.strchr)
  return has_strchr()
      ? *libcall_cnt_.strchr_
      : ::libcall_types::strchr_pol::default_instance();
}
inline ::libcall_types::strchr_pol* libcall_pol::mutable_strchr() {
  if (!has_strchr()) {
    clear_libcall_cnt();
    set_has_strchr();
    libcall_cnt_.strchr_ = new ::libcall_types::strchr_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.strchr)
  return libcall_cnt_.strchr_;
}
inline ::libcall_types::strchr_pol* libcall_pol::release_strchr() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.strchr)
  if (has_strchr()) {
    clear_has_libcall_cnt();
    ::libcall_types::strchr_pol* temp = libcall_cnt_.strchr_;
    libcall_cnt_.strchr_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_strchr(::libcall_types::strchr_pol* strchr) {
  clear_libcall_cnt();
  if (strchr) {
    set_has_strchr();
    libcall_cnt_.strchr_ = strchr;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.strchr)
}

// optional .libcall_types.exit_pol exit = 19;
inline bool libcall_pol::has_exit() const {
  return libcall_cnt_case() == kExit;
}
inline void libcall_pol::set_has_exit() {
  _oneof_case_[0] = kExit;
}
inline void libcall_pol::clear_exit() {
  if (has_exit()) {
    delete libcall_cnt_.exit_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::exit_pol& libcall_pol::exit() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.exit)
  return has_exit()
      ? *libcall_cnt_.exit_
      : ::libcall_types::exit_pol::default_instance();
}
inline ::libcall_types::exit_pol* libcall_pol::mutable_exit() {
  if (!has_exit()) {
    clear_libcall_cnt();
    set_has_exit();
    libcall_cnt_.exit_ = new ::libcall_types::exit_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.exit)
  return libcall_cnt_.exit_;
}
inline ::libcall_types::exit_pol* libcall_pol::release_exit() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.exit)
  if (has_exit()) {
    clear_has_libcall_cnt();
    ::libcall_types::exit_pol* temp = libcall_cnt_.exit_;
    libcall_cnt_.exit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_exit(::libcall_types::exit_pol* exit) {
  clear_libcall_cnt();
  if (exit) {
    set_has_exit();
    libcall_cnt_.exit_ = exit;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.exit)
}

// optional .libcall_types.strcmp_pol strcmp = 20;
inline bool libcall_pol::has_strcmp() const {
  return libcall_cnt_case() == kStrcmp;
}
inline void libcall_pol::set_has_strcmp() {
  _oneof_case_[0] = kStrcmp;
}
inline void libcall_pol::clear_strcmp() {
  if (has_strcmp()) {
    delete libcall_cnt_.strcmp_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::strcmp_pol& libcall_pol::strcmp() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.strcmp)
  return has_strcmp()
      ? *libcall_cnt_.strcmp_
      : ::libcall_types::strcmp_pol::default_instance();
}
inline ::libcall_types::strcmp_pol* libcall_pol::mutable_strcmp() {
  if (!has_strcmp()) {
    clear_libcall_cnt();
    set_has_strcmp();
    libcall_cnt_.strcmp_ = new ::libcall_types::strcmp_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.strcmp)
  return libcall_cnt_.strcmp_;
}
inline ::libcall_types::strcmp_pol* libcall_pol::release_strcmp() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.strcmp)
  if (has_strcmp()) {
    clear_has_libcall_cnt();
    ::libcall_types::strcmp_pol* temp = libcall_cnt_.strcmp_;
    libcall_cnt_.strcmp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_strcmp(::libcall_types::strcmp_pol* strcmp) {
  clear_libcall_cnt();
  if (strcmp) {
    set_has_strcmp();
    libcall_cnt_.strcmp_ = strcmp;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.strcmp)
}

// optional .libcall_types.ctype_b_loc_pol ctype_b_loc = 22;
inline bool libcall_pol::has_ctype_b_loc() const {
  return libcall_cnt_case() == kCtypeBLoc;
}
inline void libcall_pol::set_has_ctype_b_loc() {
  _oneof_case_[0] = kCtypeBLoc;
}
inline void libcall_pol::clear_ctype_b_loc() {
  if (has_ctype_b_loc()) {
    delete libcall_cnt_.ctype_b_loc_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::ctype_b_loc_pol& libcall_pol::ctype_b_loc() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.ctype_b_loc)
  return has_ctype_b_loc()
      ? *libcall_cnt_.ctype_b_loc_
      : ::libcall_types::ctype_b_loc_pol::default_instance();
}
inline ::libcall_types::ctype_b_loc_pol* libcall_pol::mutable_ctype_b_loc() {
  if (!has_ctype_b_loc()) {
    clear_libcall_cnt();
    set_has_ctype_b_loc();
    libcall_cnt_.ctype_b_loc_ = new ::libcall_types::ctype_b_loc_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.ctype_b_loc)
  return libcall_cnt_.ctype_b_loc_;
}
inline ::libcall_types::ctype_b_loc_pol* libcall_pol::release_ctype_b_loc() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.ctype_b_loc)
  if (has_ctype_b_loc()) {
    clear_has_libcall_cnt();
    ::libcall_types::ctype_b_loc_pol* temp = libcall_cnt_.ctype_b_loc_;
    libcall_cnt_.ctype_b_loc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_ctype_b_loc(::libcall_types::ctype_b_loc_pol* ctype_b_loc) {
  clear_libcall_cnt();
  if (ctype_b_loc) {
    set_has_ctype_b_loc();
    libcall_cnt_.ctype_b_loc_ = ctype_b_loc;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.ctype_b_loc)
}

// optional .libcall_types.fscanf_pol fscanf = 23;
inline bool libcall_pol::has_fscanf() const {
  return libcall_cnt_case() == kFscanf;
}
inline void libcall_pol::set_has_fscanf() {
  _oneof_case_[0] = kFscanf;
}
inline void libcall_pol::clear_fscanf() {
  if (has_fscanf()) {
    delete libcall_cnt_.fscanf_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::fscanf_pol& libcall_pol::fscanf() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.fscanf)
  return has_fscanf()
      ? *libcall_cnt_.fscanf_
      : ::libcall_types::fscanf_pol::default_instance();
}
inline ::libcall_types::fscanf_pol* libcall_pol::mutable_fscanf() {
  if (!has_fscanf()) {
    clear_libcall_cnt();
    set_has_fscanf();
    libcall_cnt_.fscanf_ = new ::libcall_types::fscanf_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.fscanf)
  return libcall_cnt_.fscanf_;
}
inline ::libcall_types::fscanf_pol* libcall_pol::release_fscanf() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.fscanf)
  if (has_fscanf()) {
    clear_has_libcall_cnt();
    ::libcall_types::fscanf_pol* temp = libcall_cnt_.fscanf_;
    libcall_cnt_.fscanf_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_fscanf(::libcall_types::fscanf_pol* fscanf) {
  clear_libcall_cnt();
  if (fscanf) {
    set_has_fscanf();
    libcall_cnt_.fscanf_ = fscanf;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.fscanf)
}

// optional .libcall_types.strncpy_pol strncpy = 24;
inline bool libcall_pol::has_strncpy() const {
  return libcall_cnt_case() == kStrncpy;
}
inline void libcall_pol::set_has_strncpy() {
  _oneof_case_[0] = kStrncpy;
}
inline void libcall_pol::clear_strncpy() {
  if (has_strncpy()) {
    delete libcall_cnt_.strncpy_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::strncpy_pol& libcall_pol::strncpy() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.strncpy)
  return has_strncpy()
      ? *libcall_cnt_.strncpy_
      : ::libcall_types::strncpy_pol::default_instance();
}
inline ::libcall_types::strncpy_pol* libcall_pol::mutable_strncpy() {
  if (!has_strncpy()) {
    clear_libcall_cnt();
    set_has_strncpy();
    libcall_cnt_.strncpy_ = new ::libcall_types::strncpy_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.strncpy)
  return libcall_cnt_.strncpy_;
}
inline ::libcall_types::strncpy_pol* libcall_pol::release_strncpy() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.strncpy)
  if (has_strncpy()) {
    clear_has_libcall_cnt();
    ::libcall_types::strncpy_pol* temp = libcall_cnt_.strncpy_;
    libcall_cnt_.strncpy_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_strncpy(::libcall_types::strncpy_pol* strncpy) {
  clear_libcall_cnt();
  if (strncpy) {
    set_has_strncpy();
    libcall_cnt_.strncpy_ = strncpy;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.strncpy)
}

// optional .libcall_types.fstat_pol fstat = 25;
inline bool libcall_pol::has_fstat() const {
  return libcall_cnt_case() == kFstat;
}
inline void libcall_pol::set_has_fstat() {
  _oneof_case_[0] = kFstat;
}
inline void libcall_pol::clear_fstat() {
  if (has_fstat()) {
    delete libcall_cnt_.fstat_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::fstat_pol& libcall_pol::fstat() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.fstat)
  return has_fstat()
      ? *libcall_cnt_.fstat_
      : ::libcall_types::fstat_pol::default_instance();
}
inline ::libcall_types::fstat_pol* libcall_pol::mutable_fstat() {
  if (!has_fstat()) {
    clear_libcall_cnt();
    set_has_fstat();
    libcall_cnt_.fstat_ = new ::libcall_types::fstat_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.fstat)
  return libcall_cnt_.fstat_;
}
inline ::libcall_types::fstat_pol* libcall_pol::release_fstat() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.fstat)
  if (has_fstat()) {
    clear_has_libcall_cnt();
    ::libcall_types::fstat_pol* temp = libcall_cnt_.fstat_;
    libcall_cnt_.fstat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_fstat(::libcall_types::fstat_pol* fstat) {
  clear_libcall_cnt();
  if (fstat) {
    set_has_fstat();
    libcall_cnt_.fstat_ = fstat;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.fstat)
}

// optional .libcall_types.realloc_pol realloc = 26;
inline bool libcall_pol::has_realloc() const {
  return libcall_cnt_case() == kRealloc;
}
inline void libcall_pol::set_has_realloc() {
  _oneof_case_[0] = kRealloc;
}
inline void libcall_pol::clear_realloc() {
  if (has_realloc()) {
    delete libcall_cnt_.realloc_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::realloc_pol& libcall_pol::realloc() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.realloc)
  return has_realloc()
      ? *libcall_cnt_.realloc_
      : ::libcall_types::realloc_pol::default_instance();
}
inline ::libcall_types::realloc_pol* libcall_pol::mutable_realloc() {
  if (!has_realloc()) {
    clear_libcall_cnt();
    set_has_realloc();
    libcall_cnt_.realloc_ = new ::libcall_types::realloc_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.realloc)
  return libcall_cnt_.realloc_;
}
inline ::libcall_types::realloc_pol* libcall_pol::release_realloc() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.realloc)
  if (has_realloc()) {
    clear_has_libcall_cnt();
    ::libcall_types::realloc_pol* temp = libcall_cnt_.realloc_;
    libcall_cnt_.realloc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_realloc(::libcall_types::realloc_pol* realloc) {
  clear_libcall_cnt();
  if (realloc) {
    set_has_realloc();
    libcall_cnt_.realloc_ = realloc;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.realloc)
}

// optional .libcall_types.mmap_pol mmap = 27;
inline bool libcall_pol::has_mmap() const {
  return libcall_cnt_case() == kMmap;
}
inline void libcall_pol::set_has_mmap() {
  _oneof_case_[0] = kMmap;
}
inline void libcall_pol::clear_mmap() {
  if (has_mmap()) {
    delete libcall_cnt_.mmap_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::mmap_pol& libcall_pol::mmap() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.mmap)
  return has_mmap()
      ? *libcall_cnt_.mmap_
      : ::libcall_types::mmap_pol::default_instance();
}
inline ::libcall_types::mmap_pol* libcall_pol::mutable_mmap() {
  if (!has_mmap()) {
    clear_libcall_cnt();
    set_has_mmap();
    libcall_cnt_.mmap_ = new ::libcall_types::mmap_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.mmap)
  return libcall_cnt_.mmap_;
}
inline ::libcall_types::mmap_pol* libcall_pol::release_mmap() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.mmap)
  if (has_mmap()) {
    clear_has_libcall_cnt();
    ::libcall_types::mmap_pol* temp = libcall_cnt_.mmap_;
    libcall_cnt_.mmap_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_mmap(::libcall_types::mmap_pol* mmap) {
  clear_libcall_cnt();
  if (mmap) {
    set_has_mmap();
    libcall_cnt_.mmap_ = mmap;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.mmap)
}

// optional .libcall_types.qsort_pol qsort = 28;
inline bool libcall_pol::has_qsort() const {
  return libcall_cnt_case() == kQsort;
}
inline void libcall_pol::set_has_qsort() {
  _oneof_case_[0] = kQsort;
}
inline void libcall_pol::clear_qsort() {
  if (has_qsort()) {
    delete libcall_cnt_.qsort_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::qsort_pol& libcall_pol::qsort() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.qsort)
  return has_qsort()
      ? *libcall_cnt_.qsort_
      : ::libcall_types::qsort_pol::default_instance();
}
inline ::libcall_types::qsort_pol* libcall_pol::mutable_qsort() {
  if (!has_qsort()) {
    clear_libcall_cnt();
    set_has_qsort();
    libcall_cnt_.qsort_ = new ::libcall_types::qsort_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.qsort)
  return libcall_cnt_.qsort_;
}
inline ::libcall_types::qsort_pol* libcall_pol::release_qsort() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.qsort)
  if (has_qsort()) {
    clear_has_libcall_cnt();
    ::libcall_types::qsort_pol* temp = libcall_cnt_.qsort_;
    libcall_cnt_.qsort_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_qsort(::libcall_types::qsort_pol* qsort) {
  clear_libcall_cnt();
  if (qsort) {
    set_has_qsort();
    libcall_cnt_.qsort_ = qsort;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.qsort)
}

// optional .libcall_types.bsearch_pol bsearch = 29;
inline bool libcall_pol::has_bsearch() const {
  return libcall_cnt_case() == kBsearch;
}
inline void libcall_pol::set_has_bsearch() {
  _oneof_case_[0] = kBsearch;
}
inline void libcall_pol::clear_bsearch() {
  if (has_bsearch()) {
    delete libcall_cnt_.bsearch_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::bsearch_pol& libcall_pol::bsearch() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.bsearch)
  return has_bsearch()
      ? *libcall_cnt_.bsearch_
      : ::libcall_types::bsearch_pol::default_instance();
}
inline ::libcall_types::bsearch_pol* libcall_pol::mutable_bsearch() {
  if (!has_bsearch()) {
    clear_libcall_cnt();
    set_has_bsearch();
    libcall_cnt_.bsearch_ = new ::libcall_types::bsearch_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.bsearch)
  return libcall_cnt_.bsearch_;
}
inline ::libcall_types::bsearch_pol* libcall_pol::release_bsearch() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.bsearch)
  if (has_bsearch()) {
    clear_has_libcall_cnt();
    ::libcall_types::bsearch_pol* temp = libcall_cnt_.bsearch_;
    libcall_cnt_.bsearch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_bsearch(::libcall_types::bsearch_pol* bsearch) {
  clear_libcall_cnt();
  if (bsearch) {
    set_has_bsearch();
    libcall_cnt_.bsearch_ = bsearch;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.bsearch)
}

// optional .libcall_types.open_pol open_stub = 30;
inline bool libcall_pol::has_open_stub() const {
  return libcall_cnt_case() == kOpenStub;
}
inline void libcall_pol::set_has_open_stub() {
  _oneof_case_[0] = kOpenStub;
}
inline void libcall_pol::clear_open_stub() {
  if (has_open_stub()) {
    delete libcall_cnt_.open_stub_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::open_pol& libcall_pol::open_stub() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.open_stub)
  return has_open_stub()
      ? *libcall_cnt_.open_stub_
      : ::libcall_types::open_pol::default_instance();
}
inline ::libcall_types::open_pol* libcall_pol::mutable_open_stub() {
  if (!has_open_stub()) {
    clear_libcall_cnt();
    set_has_open_stub();
    libcall_cnt_.open_stub_ = new ::libcall_types::open_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.open_stub)
  return libcall_cnt_.open_stub_;
}
inline ::libcall_types::open_pol* libcall_pol::release_open_stub() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.open_stub)
  if (has_open_stub()) {
    clear_has_libcall_cnt();
    ::libcall_types::open_pol* temp = libcall_cnt_.open_stub_;
    libcall_cnt_.open_stub_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_open_stub(::libcall_types::open_pol* open_stub) {
  clear_libcall_cnt();
  if (open_stub) {
    set_has_open_stub();
    libcall_cnt_.open_stub_ = open_stub;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.open_stub)
}

// optional .libcall_types.lseek_pol lseek = 31;
inline bool libcall_pol::has_lseek() const {
  return libcall_cnt_case() == kLseek;
}
inline void libcall_pol::set_has_lseek() {
  _oneof_case_[0] = kLseek;
}
inline void libcall_pol::clear_lseek() {
  if (has_lseek()) {
    delete libcall_cnt_.lseek_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::lseek_pol& libcall_pol::lseek() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.lseek)
  return has_lseek()
      ? *libcall_cnt_.lseek_
      : ::libcall_types::lseek_pol::default_instance();
}
inline ::libcall_types::lseek_pol* libcall_pol::mutable_lseek() {
  if (!has_lseek()) {
    clear_libcall_cnt();
    set_has_lseek();
    libcall_cnt_.lseek_ = new ::libcall_types::lseek_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.lseek)
  return libcall_cnt_.lseek_;
}
inline ::libcall_types::lseek_pol* libcall_pol::release_lseek() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.lseek)
  if (has_lseek()) {
    clear_has_libcall_cnt();
    ::libcall_types::lseek_pol* temp = libcall_cnt_.lseek_;
    libcall_cnt_.lseek_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_lseek(::libcall_types::lseek_pol* lseek) {
  clear_libcall_cnt();
  if (lseek) {
    set_has_lseek();
    libcall_cnt_.lseek_ = lseek;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.lseek)
}

// optional .libcall_types.fread_pol fread = 32;
inline bool libcall_pol::has_fread() const {
  return libcall_cnt_case() == kFread;
}
inline void libcall_pol::set_has_fread() {
  _oneof_case_[0] = kFread;
}
inline void libcall_pol::clear_fread() {
  if (has_fread()) {
    delete libcall_cnt_.fread_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::fread_pol& libcall_pol::fread() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.fread)
  return has_fread()
      ? *libcall_cnt_.fread_
      : ::libcall_types::fread_pol::default_instance();
}
inline ::libcall_types::fread_pol* libcall_pol::mutable_fread() {
  if (!has_fread()) {
    clear_libcall_cnt();
    set_has_fread();
    libcall_cnt_.fread_ = new ::libcall_types::fread_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.fread)
  return libcall_cnt_.fread_;
}
inline ::libcall_types::fread_pol* libcall_pol::release_fread() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.fread)
  if (has_fread()) {
    clear_has_libcall_cnt();
    ::libcall_types::fread_pol* temp = libcall_cnt_.fread_;
    libcall_cnt_.fread_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_fread(::libcall_types::fread_pol* fread) {
  clear_libcall_cnt();
  if (fread) {
    set_has_fread();
    libcall_cnt_.fread_ = fread;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.fread)
}

// optional .libcall_types.strncmp_pol strncmp = 33;
inline bool libcall_pol::has_strncmp() const {
  return libcall_cnt_case() == kStrncmp;
}
inline void libcall_pol::set_has_strncmp() {
  _oneof_case_[0] = kStrncmp;
}
inline void libcall_pol::clear_strncmp() {
  if (has_strncmp()) {
    delete libcall_cnt_.strncmp_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::strncmp_pol& libcall_pol::strncmp() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.strncmp)
  return has_strncmp()
      ? *libcall_cnt_.strncmp_
      : ::libcall_types::strncmp_pol::default_instance();
}
inline ::libcall_types::strncmp_pol* libcall_pol::mutable_strncmp() {
  if (!has_strncmp()) {
    clear_libcall_cnt();
    set_has_strncmp();
    libcall_cnt_.strncmp_ = new ::libcall_types::strncmp_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.strncmp)
  return libcall_cnt_.strncmp_;
}
inline ::libcall_types::strncmp_pol* libcall_pol::release_strncmp() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.strncmp)
  if (has_strncmp()) {
    clear_has_libcall_cnt();
    ::libcall_types::strncmp_pol* temp = libcall_cnt_.strncmp_;
    libcall_cnt_.strncmp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_strncmp(::libcall_types::strncmp_pol* strncmp) {
  clear_libcall_cnt();
  if (strncmp) {
    set_has_strncmp();
    libcall_cnt_.strncmp_ = strncmp;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.strncmp)
}

// optional .libcall_types.memcmp_pol memcmp = 34;
inline bool libcall_pol::has_memcmp() const {
  return libcall_cnt_case() == kMemcmp;
}
inline void libcall_pol::set_has_memcmp() {
  _oneof_case_[0] = kMemcmp;
}
inline void libcall_pol::clear_memcmp() {
  if (has_memcmp()) {
    delete libcall_cnt_.memcmp_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::memcmp_pol& libcall_pol::memcmp() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.memcmp)
  return has_memcmp()
      ? *libcall_cnt_.memcmp_
      : ::libcall_types::memcmp_pol::default_instance();
}
inline ::libcall_types::memcmp_pol* libcall_pol::mutable_memcmp() {
  if (!has_memcmp()) {
    clear_libcall_cnt();
    set_has_memcmp();
    libcall_cnt_.memcmp_ = new ::libcall_types::memcmp_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.memcmp)
  return libcall_cnt_.memcmp_;
}
inline ::libcall_types::memcmp_pol* libcall_pol::release_memcmp() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.memcmp)
  if (has_memcmp()) {
    clear_has_libcall_cnt();
    ::libcall_types::memcmp_pol* temp = libcall_cnt_.memcmp_;
    libcall_cnt_.memcmp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_memcmp(::libcall_types::memcmp_pol* memcmp) {
  clear_libcall_cnt();
  if (memcmp) {
    set_has_memcmp();
    libcall_cnt_.memcmp_ = memcmp;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.memcmp)
}

// optional .libcall_types.fxstat64_pol fxstat64 = 35;
inline bool libcall_pol::has_fxstat64() const {
  return libcall_cnt_case() == kFxstat64;
}
inline void libcall_pol::set_has_fxstat64() {
  _oneof_case_[0] = kFxstat64;
}
inline void libcall_pol::clear_fxstat64() {
  if (has_fxstat64()) {
    delete libcall_cnt_.fxstat64_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::fxstat64_pol& libcall_pol::fxstat64() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.fxstat64)
  return has_fxstat64()
      ? *libcall_cnt_.fxstat64_
      : ::libcall_types::fxstat64_pol::default_instance();
}
inline ::libcall_types::fxstat64_pol* libcall_pol::mutable_fxstat64() {
  if (!has_fxstat64()) {
    clear_libcall_cnt();
    set_has_fxstat64();
    libcall_cnt_.fxstat64_ = new ::libcall_types::fxstat64_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.fxstat64)
  return libcall_cnt_.fxstat64_;
}
inline ::libcall_types::fxstat64_pol* libcall_pol::release_fxstat64() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.fxstat64)
  if (has_fxstat64()) {
    clear_has_libcall_cnt();
    ::libcall_types::fxstat64_pol* temp = libcall_cnt_.fxstat64_;
    libcall_cnt_.fxstat64_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_fxstat64(::libcall_types::fxstat64_pol* fxstat64) {
  clear_libcall_cnt();
  if (fxstat64) {
    set_has_fxstat64();
    libcall_cnt_.fxstat64_ = fxstat64;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.fxstat64)
}

// optional .libcall_types.generic_pol generic = 50;
inline bool libcall_pol::has_generic() const {
  return libcall_cnt_case() == kGeneric;
}
inline void libcall_pol::set_has_generic() {
  _oneof_case_[0] = kGeneric;
}
inline void libcall_pol::clear_generic() {
  if (has_generic()) {
    delete libcall_cnt_.generic_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::generic_pol& libcall_pol::generic() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.generic)
  return has_generic()
      ? *libcall_cnt_.generic_
      : ::libcall_types::generic_pol::default_instance();
}
inline ::libcall_types::generic_pol* libcall_pol::mutable_generic() {
  if (!has_generic()) {
    clear_libcall_cnt();
    set_has_generic();
    libcall_cnt_.generic_ = new ::libcall_types::generic_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.generic)
  return libcall_cnt_.generic_;
}
inline ::libcall_types::generic_pol* libcall_pol::release_generic() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.generic)
  if (has_generic()) {
    clear_has_libcall_cnt();
    ::libcall_types::generic_pol* temp = libcall_cnt_.generic_;
    libcall_cnt_.generic_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_pol::set_allocated_generic(::libcall_types::generic_pol* generic) {
  clear_libcall_cnt();
  if (generic) {
    set_has_generic();
    libcall_cnt_.generic_ = generic;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.generic)
}

inline bool libcall_pol::has_libcall_cnt() const {
  return libcall_cnt_case() != LIBCALL_CNT_NOT_SET;
}
inline void libcall_pol::clear_has_libcall_cnt() {
  _oneof_case_[0] = LIBCALL_CNT_NOT_SET;
}
inline libcall_pol::LibcallCntCase libcall_pol::libcall_cnt_case() const {
  return libcall_pol::LibcallCntCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// libcall_t

// required uint64 func_addr = 1;
inline bool libcall_t::has_func_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void libcall_t::set_has_func_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void libcall_t::clear_has_func_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void libcall_t::clear_func_addr() {
  func_addr_ = GOOGLE_ULONGLONG(0);
  clear_has_func_addr();
}
inline ::google::protobuf::uint64 libcall_t::func_addr() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.func_addr)
  return func_addr_;
}
inline void libcall_t::set_func_addr(::google::protobuf::uint64 value) {
  set_has_func_addr();
  func_addr_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.libcall_t.func_addr)
}

// required string func_name = 2;
inline bool libcall_t::has_func_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void libcall_t::set_has_func_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void libcall_t::clear_has_func_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void libcall_t::clear_func_name() {
  func_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_func_name();
}
inline const ::std::string& libcall_t::func_name() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.func_name)
  return func_name_.GetNoArena();
}
inline void libcall_t::set_func_name(const ::std::string& value) {
  set_has_func_name();
  func_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libcall_types.libcall_t.func_name)
}
#if LANG_CXX11
inline void libcall_t::set_func_name(::std::string&& value) {
  set_has_func_name();
  func_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:libcall_types.libcall_t.func_name)
}
#endif
inline void libcall_t::set_func_name(const char* value) {
  set_has_func_name();
  func_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libcall_types.libcall_t.func_name)
}
inline void libcall_t::set_func_name(const char* value, size_t size) {
  set_has_func_name();
  func_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libcall_types.libcall_t.func_name)
}
inline ::std::string* libcall_t::mutable_func_name() {
  set_has_func_name();
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.func_name)
  return func_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* libcall_t::release_func_name() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.func_name)
  clear_has_func_name();
  return func_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void libcall_t::set_allocated_func_name(::std::string* func_name) {
  if (func_name != NULL) {
    set_has_func_name();
  } else {
    clear_has_func_name();
  }
  func_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), func_name);
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.func_name)
}

// required bool is_traced = 3;
inline bool libcall_t::has_is_traced() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void libcall_t::set_has_is_traced() {
  _has_bits_[0] |= 0x00000004u;
}
inline void libcall_t::clear_has_is_traced() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void libcall_t::clear_is_traced() {
  is_traced_ = false;
  clear_has_is_traced();
}
inline bool libcall_t::is_traced() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.is_traced)
  return is_traced_;
}
inline void libcall_t::set_is_traced(bool value) {
  set_has_is_traced();
  is_traced_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.libcall_t.is_traced)
}

// required .libcall_types.lib_ident ident = 4;
inline bool libcall_t::has_ident() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void libcall_t::set_has_ident() {
  _has_bits_[0] |= 0x00000008u;
}
inline void libcall_t::clear_has_ident() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void libcall_t::clear_ident() {
  ident_ = 0;
  clear_has_ident();
}
inline ::libcall_types::lib_ident libcall_t::ident() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.ident)
  return static_cast< ::libcall_types::lib_ident >(ident_);
}
inline void libcall_t::set_ident(::libcall_types::lib_ident value) {
  assert(::libcall_types::lib_ident_IsValid(value));
  set_has_ident();
  ident_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.libcall_t.ident)
}

// optional .libcall_types.strcpy_t strcpy = 5;
inline bool libcall_t::has_strcpy() const {
  return libcall_cnt_case() == kStrcpy;
}
inline void libcall_t::set_has_strcpy() {
  _oneof_case_[0] = kStrcpy;
}
inline void libcall_t::clear_strcpy() {
  if (has_strcpy()) {
    delete libcall_cnt_.strcpy_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::strcpy_t& libcall_t::strcpy() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.strcpy)
  return has_strcpy()
      ? *libcall_cnt_.strcpy_
      : ::libcall_types::strcpy_t::default_instance();
}
inline ::libcall_types::strcpy_t* libcall_t::mutable_strcpy() {
  if (!has_strcpy()) {
    clear_libcall_cnt();
    set_has_strcpy();
    libcall_cnt_.strcpy_ = new ::libcall_types::strcpy_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.strcpy)
  return libcall_cnt_.strcpy_;
}
inline ::libcall_types::strcpy_t* libcall_t::release_strcpy() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.strcpy)
  if (has_strcpy()) {
    clear_has_libcall_cnt();
    ::libcall_types::strcpy_t* temp = libcall_cnt_.strcpy_;
    libcall_cnt_.strcpy_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_strcpy(::libcall_types::strcpy_t* strcpy) {
  clear_libcall_cnt();
  if (strcpy) {
    set_has_strcpy();
    libcall_cnt_.strcpy_ = strcpy;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.strcpy)
}

// optional .libcall_types.printf_t printf = 6;
inline bool libcall_t::has_printf() const {
  return libcall_cnt_case() == kPrintf;
}
inline void libcall_t::set_has_printf() {
  _oneof_case_[0] = kPrintf;
}
inline void libcall_t::clear_printf() {
  if (has_printf()) {
    delete libcall_cnt_.printf_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::printf_t& libcall_t::printf() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.printf)
  return has_printf()
      ? *libcall_cnt_.printf_
      : ::libcall_types::printf_t::default_instance();
}
inline ::libcall_types::printf_t* libcall_t::mutable_printf() {
  if (!has_printf()) {
    clear_libcall_cnt();
    set_has_printf();
    libcall_cnt_.printf_ = new ::libcall_types::printf_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.printf)
  return libcall_cnt_.printf_;
}
inline ::libcall_types::printf_t* libcall_t::release_printf() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.printf)
  if (has_printf()) {
    clear_has_libcall_cnt();
    ::libcall_types::printf_t* temp = libcall_cnt_.printf_;
    libcall_cnt_.printf_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_printf(::libcall_types::printf_t* printf) {
  clear_libcall_cnt();
  if (printf) {
    set_has_printf();
    libcall_cnt_.printf_ = printf;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.printf)
}

// optional .libcall_types.atoi_t atoi = 7;
inline bool libcall_t::has_atoi() const {
  return libcall_cnt_case() == kAtoi;
}
inline void libcall_t::set_has_atoi() {
  _oneof_case_[0] = kAtoi;
}
inline void libcall_t::clear_atoi() {
  if (has_atoi()) {
    delete libcall_cnt_.atoi_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::atoi_t& libcall_t::atoi() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.atoi)
  return has_atoi()
      ? *libcall_cnt_.atoi_
      : ::libcall_types::atoi_t::default_instance();
}
inline ::libcall_types::atoi_t* libcall_t::mutable_atoi() {
  if (!has_atoi()) {
    clear_libcall_cnt();
    set_has_atoi();
    libcall_cnt_.atoi_ = new ::libcall_types::atoi_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.atoi)
  return libcall_cnt_.atoi_;
}
inline ::libcall_types::atoi_t* libcall_t::release_atoi() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.atoi)
  if (has_atoi()) {
    clear_has_libcall_cnt();
    ::libcall_types::atoi_t* temp = libcall_cnt_.atoi_;
    libcall_cnt_.atoi_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_atoi(::libcall_types::atoi_t* atoi) {
  clear_libcall_cnt();
  if (atoi) {
    set_has_atoi();
    libcall_cnt_.atoi_ = atoi;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.atoi)
}

// optional .libcall_types.malloc_t malloc = 8;
inline bool libcall_t::has_malloc() const {
  return libcall_cnt_case() == kMalloc;
}
inline void libcall_t::set_has_malloc() {
  _oneof_case_[0] = kMalloc;
}
inline void libcall_t::clear_malloc() {
  if (has_malloc()) {
    delete libcall_cnt_.malloc_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::malloc_t& libcall_t::malloc() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.malloc)
  return has_malloc()
      ? *libcall_cnt_.malloc_
      : ::libcall_types::malloc_t::default_instance();
}
inline ::libcall_types::malloc_t* libcall_t::mutable_malloc() {
  if (!has_malloc()) {
    clear_libcall_cnt();
    set_has_malloc();
    libcall_cnt_.malloc_ = new ::libcall_types::malloc_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.malloc)
  return libcall_cnt_.malloc_;
}
inline ::libcall_types::malloc_t* libcall_t::release_malloc() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.malloc)
  if (has_malloc()) {
    clear_has_libcall_cnt();
    ::libcall_types::malloc_t* temp = libcall_cnt_.malloc_;
    libcall_cnt_.malloc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_malloc(::libcall_types::malloc_t* malloc) {
  clear_libcall_cnt();
  if (malloc) {
    set_has_malloc();
    libcall_cnt_.malloc_ = malloc;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.malloc)
}

// optional .libcall_types.getmodulehandle_t getmodulehandle = 9;
inline bool libcall_t::has_getmodulehandle() const {
  return libcall_cnt_case() == kGetmodulehandle;
}
inline void libcall_t::set_has_getmodulehandle() {
  _oneof_case_[0] = kGetmodulehandle;
}
inline void libcall_t::clear_getmodulehandle() {
  if (has_getmodulehandle()) {
    delete libcall_cnt_.getmodulehandle_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::getmodulehandle_t& libcall_t::getmodulehandle() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.getmodulehandle)
  return has_getmodulehandle()
      ? *libcall_cnt_.getmodulehandle_
      : ::libcall_types::getmodulehandle_t::default_instance();
}
inline ::libcall_types::getmodulehandle_t* libcall_t::mutable_getmodulehandle() {
  if (!has_getmodulehandle()) {
    clear_libcall_cnt();
    set_has_getmodulehandle();
    libcall_cnt_.getmodulehandle_ = new ::libcall_types::getmodulehandle_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.getmodulehandle)
  return libcall_cnt_.getmodulehandle_;
}
inline ::libcall_types::getmodulehandle_t* libcall_t::release_getmodulehandle() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.getmodulehandle)
  if (has_getmodulehandle()) {
    clear_has_libcall_cnt();
    ::libcall_types::getmodulehandle_t* temp = libcall_cnt_.getmodulehandle_;
    libcall_cnt_.getmodulehandle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_getmodulehandle(::libcall_types::getmodulehandle_t* getmodulehandle) {
  clear_libcall_cnt();
  if (getmodulehandle) {
    set_has_getmodulehandle();
    libcall_cnt_.getmodulehandle_ = getmodulehandle;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.getmodulehandle)
}

// optional .libcall_types.getprocaddress_t getprocaddress = 10;
inline bool libcall_t::has_getprocaddress() const {
  return libcall_cnt_case() == kGetprocaddress;
}
inline void libcall_t::set_has_getprocaddress() {
  _oneof_case_[0] = kGetprocaddress;
}
inline void libcall_t::clear_getprocaddress() {
  if (has_getprocaddress()) {
    delete libcall_cnt_.getprocaddress_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::getprocaddress_t& libcall_t::getprocaddress() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.getprocaddress)
  return has_getprocaddress()
      ? *libcall_cnt_.getprocaddress_
      : ::libcall_types::getprocaddress_t::default_instance();
}
inline ::libcall_types::getprocaddress_t* libcall_t::mutable_getprocaddress() {
  if (!has_getprocaddress()) {
    clear_libcall_cnt();
    set_has_getprocaddress();
    libcall_cnt_.getprocaddress_ = new ::libcall_types::getprocaddress_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.getprocaddress)
  return libcall_cnt_.getprocaddress_;
}
inline ::libcall_types::getprocaddress_t* libcall_t::release_getprocaddress() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.getprocaddress)
  if (has_getprocaddress()) {
    clear_has_libcall_cnt();
    ::libcall_types::getprocaddress_t* temp = libcall_cnt_.getprocaddress_;
    libcall_cnt_.getprocaddress_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_getprocaddress(::libcall_types::getprocaddress_t* getprocaddress) {
  clear_libcall_cnt();
  if (getprocaddress) {
    set_has_getprocaddress();
    libcall_cnt_.getprocaddress_ = getprocaddress;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.getprocaddress)
}

// optional .libcall_types.getmainargs_t getmainargs = 11;
inline bool libcall_t::has_getmainargs() const {
  return libcall_cnt_case() == kGetmainargs;
}
inline void libcall_t::set_has_getmainargs() {
  _oneof_case_[0] = kGetmainargs;
}
inline void libcall_t::clear_getmainargs() {
  if (has_getmainargs()) {
    delete libcall_cnt_.getmainargs_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::getmainargs_t& libcall_t::getmainargs() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.getmainargs)
  return has_getmainargs()
      ? *libcall_cnt_.getmainargs_
      : ::libcall_types::getmainargs_t::default_instance();
}
inline ::libcall_types::getmainargs_t* libcall_t::mutable_getmainargs() {
  if (!has_getmainargs()) {
    clear_libcall_cnt();
    set_has_getmainargs();
    libcall_cnt_.getmainargs_ = new ::libcall_types::getmainargs_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.getmainargs)
  return libcall_cnt_.getmainargs_;
}
inline ::libcall_types::getmainargs_t* libcall_t::release_getmainargs() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.getmainargs)
  if (has_getmainargs()) {
    clear_has_libcall_cnt();
    ::libcall_types::getmainargs_t* temp = libcall_cnt_.getmainargs_;
    libcall_cnt_.getmainargs_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_getmainargs(::libcall_types::getmainargs_t* getmainargs) {
  clear_libcall_cnt();
  if (getmainargs) {
    set_has_getmainargs();
    libcall_cnt_.getmainargs_ = getmainargs;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.getmainargs)
}

// optional .libcall_types.gethostname_t gethostname = 12;
inline bool libcall_t::has_gethostname() const {
  return libcall_cnt_case() == kGethostname;
}
inline void libcall_t::set_has_gethostname() {
  _oneof_case_[0] = kGethostname;
}
inline void libcall_t::clear_gethostname() {
  if (has_gethostname()) {
    delete libcall_cnt_.gethostname_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::gethostname_t& libcall_t::gethostname() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.gethostname)
  return has_gethostname()
      ? *libcall_cnt_.gethostname_
      : ::libcall_types::gethostname_t::default_instance();
}
inline ::libcall_types::gethostname_t* libcall_t::mutable_gethostname() {
  if (!has_gethostname()) {
    clear_libcall_cnt();
    set_has_gethostname();
    libcall_cnt_.gethostname_ = new ::libcall_types::gethostname_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.gethostname)
  return libcall_cnt_.gethostname_;
}
inline ::libcall_types::gethostname_t* libcall_t::release_gethostname() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.gethostname)
  if (has_gethostname()) {
    clear_has_libcall_cnt();
    ::libcall_types::gethostname_t* temp = libcall_cnt_.gethostname_;
    libcall_cnt_.gethostname_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_gethostname(::libcall_types::gethostname_t* gethostname) {
  clear_libcall_cnt();
  if (gethostname) {
    set_has_gethostname();
    libcall_cnt_.gethostname_ = gethostname;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.gethostname)
}

// optional .libcall_types.free_t free = 13;
inline bool libcall_t::has_free() const {
  return libcall_cnt_case() == kFree;
}
inline void libcall_t::set_has_free() {
  _oneof_case_[0] = kFree;
}
inline void libcall_t::clear_free() {
  if (has_free()) {
    delete libcall_cnt_.free_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::free_t& libcall_t::free() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.free)
  return has_free()
      ? *libcall_cnt_.free_
      : ::libcall_types::free_t::default_instance();
}
inline ::libcall_types::free_t* libcall_t::mutable_free() {
  if (!has_free()) {
    clear_libcall_cnt();
    set_has_free();
    libcall_cnt_.free_ = new ::libcall_types::free_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.free)
  return libcall_cnt_.free_;
}
inline ::libcall_types::free_t* libcall_t::release_free() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.free)
  if (has_free()) {
    clear_has_libcall_cnt();
    ::libcall_types::free_t* temp = libcall_cnt_.free_;
    libcall_cnt_.free_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_free(::libcall_types::free_t* free) {
  clear_libcall_cnt();
  if (free) {
    set_has_free();
    libcall_cnt_.free_ = free;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.free)
}

// optional .libcall_types.memcpy_t memcpy = 14;
inline bool libcall_t::has_memcpy() const {
  return libcall_cnt_case() == kMemcpy;
}
inline void libcall_t::set_has_memcpy() {
  _oneof_case_[0] = kMemcpy;
}
inline void libcall_t::clear_memcpy() {
  if (has_memcpy()) {
    delete libcall_cnt_.memcpy_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::memcpy_t& libcall_t::memcpy() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.memcpy)
  return has_memcpy()
      ? *libcall_cnt_.memcpy_
      : ::libcall_types::memcpy_t::default_instance();
}
inline ::libcall_types::memcpy_t* libcall_t::mutable_memcpy() {
  if (!has_memcpy()) {
    clear_libcall_cnt();
    set_has_memcpy();
    libcall_cnt_.memcpy_ = new ::libcall_types::memcpy_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.memcpy)
  return libcall_cnt_.memcpy_;
}
inline ::libcall_types::memcpy_t* libcall_t::release_memcpy() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.memcpy)
  if (has_memcpy()) {
    clear_has_libcall_cnt();
    ::libcall_types::memcpy_t* temp = libcall_cnt_.memcpy_;
    libcall_cnt_.memcpy_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_memcpy(::libcall_types::memcpy_t* memcpy) {
  clear_libcall_cnt();
  if (memcpy) {
    set_has_memcpy();
    libcall_cnt_.memcpy_ = memcpy;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.memcpy)
}

// optional .libcall_types.memset_t memset = 15;
inline bool libcall_t::has_memset() const {
  return libcall_cnt_case() == kMemset;
}
inline void libcall_t::set_has_memset() {
  _oneof_case_[0] = kMemset;
}
inline void libcall_t::clear_memset() {
  if (has_memset()) {
    delete libcall_cnt_.memset_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::memset_t& libcall_t::memset() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.memset)
  return has_memset()
      ? *libcall_cnt_.memset_
      : ::libcall_types::memset_t::default_instance();
}
inline ::libcall_types::memset_t* libcall_t::mutable_memset() {
  if (!has_memset()) {
    clear_libcall_cnt();
    set_has_memset();
    libcall_cnt_.memset_ = new ::libcall_types::memset_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.memset)
  return libcall_cnt_.memset_;
}
inline ::libcall_types::memset_t* libcall_t::release_memset() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.memset)
  if (has_memset()) {
    clear_has_libcall_cnt();
    ::libcall_types::memset_t* temp = libcall_cnt_.memset_;
    libcall_cnt_.memset_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_memset(::libcall_types::memset_t* memset) {
  clear_libcall_cnt();
  if (memset) {
    set_has_memset();
    libcall_cnt_.memset_ = memset;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.memset)
}

// optional .libcall_types.fgetc_t fgetc = 16;
inline bool libcall_t::has_fgetc() const {
  return libcall_cnt_case() == kFgetc;
}
inline void libcall_t::set_has_fgetc() {
  _oneof_case_[0] = kFgetc;
}
inline void libcall_t::clear_fgetc() {
  if (has_fgetc()) {
    delete libcall_cnt_.fgetc_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::fgetc_t& libcall_t::fgetc() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.fgetc)
  return has_fgetc()
      ? *libcall_cnt_.fgetc_
      : ::libcall_types::fgetc_t::default_instance();
}
inline ::libcall_types::fgetc_t* libcall_t::mutable_fgetc() {
  if (!has_fgetc()) {
    clear_libcall_cnt();
    set_has_fgetc();
    libcall_cnt_.fgetc_ = new ::libcall_types::fgetc_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.fgetc)
  return libcall_cnt_.fgetc_;
}
inline ::libcall_types::fgetc_t* libcall_t::release_fgetc() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.fgetc)
  if (has_fgetc()) {
    clear_has_libcall_cnt();
    ::libcall_types::fgetc_t* temp = libcall_cnt_.fgetc_;
    libcall_cnt_.fgetc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_fgetc(::libcall_types::fgetc_t* fgetc) {
  clear_libcall_cnt();
  if (fgetc) {
    set_has_fgetc();
    libcall_cnt_.fgetc_ = fgetc;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.fgetc)
}

// optional .libcall_types.generic_t generic = 17;
inline bool libcall_t::has_generic() const {
  return libcall_cnt_case() == kGeneric;
}
inline void libcall_t::set_has_generic() {
  _oneof_case_[0] = kGeneric;
}
inline void libcall_t::clear_generic() {
  if (has_generic()) {
    delete libcall_cnt_.generic_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::generic_t& libcall_t::generic() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.generic)
  return has_generic()
      ? *libcall_cnt_.generic_
      : ::libcall_types::generic_t::default_instance();
}
inline ::libcall_types::generic_t* libcall_t::mutable_generic() {
  if (!has_generic()) {
    clear_libcall_cnt();
    set_has_generic();
    libcall_cnt_.generic_ = new ::libcall_types::generic_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.generic)
  return libcall_cnt_.generic_;
}
inline ::libcall_types::generic_t* libcall_t::release_generic() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.generic)
  if (has_generic()) {
    clear_has_libcall_cnt();
    ::libcall_types::generic_t* temp = libcall_cnt_.generic_;
    libcall_cnt_.generic_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_generic(::libcall_types::generic_t* generic) {
  clear_libcall_cnt();
  if (generic) {
    set_has_generic();
    libcall_cnt_.generic_ = generic;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.generic)
}

// optional .libcall_types.read_t read = 18;
inline bool libcall_t::has_read() const {
  return libcall_cnt_case() == kRead;
}
inline void libcall_t::set_has_read() {
  _oneof_case_[0] = kRead;
}
inline void libcall_t::clear_read() {
  if (has_read()) {
    delete libcall_cnt_.read_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::read_t& libcall_t::read() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.read)
  return has_read()
      ? *libcall_cnt_.read_
      : ::libcall_types::read_t::default_instance();
}
inline ::libcall_types::read_t* libcall_t::mutable_read() {
  if (!has_read()) {
    clear_libcall_cnt();
    set_has_read();
    libcall_cnt_.read_ = new ::libcall_types::read_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.read)
  return libcall_cnt_.read_;
}
inline ::libcall_types::read_t* libcall_t::release_read() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.read)
  if (has_read()) {
    clear_has_libcall_cnt();
    ::libcall_types::read_t* temp = libcall_cnt_.read_;
    libcall_cnt_.read_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_read(::libcall_types::read_t* read) {
  clear_libcall_cnt();
  if (read) {
    set_has_read();
    libcall_cnt_.read_ = read;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.read)
}

// optional .libcall_types.strchr_t strchr = 19;
inline bool libcall_t::has_strchr() const {
  return libcall_cnt_case() == kStrchr;
}
inline void libcall_t::set_has_strchr() {
  _oneof_case_[0] = kStrchr;
}
inline void libcall_t::clear_strchr() {
  if (has_strchr()) {
    delete libcall_cnt_.strchr_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::strchr_t& libcall_t::strchr() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.strchr)
  return has_strchr()
      ? *libcall_cnt_.strchr_
      : ::libcall_types::strchr_t::default_instance();
}
inline ::libcall_types::strchr_t* libcall_t::mutable_strchr() {
  if (!has_strchr()) {
    clear_libcall_cnt();
    set_has_strchr();
    libcall_cnt_.strchr_ = new ::libcall_types::strchr_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.strchr)
  return libcall_cnt_.strchr_;
}
inline ::libcall_types::strchr_t* libcall_t::release_strchr() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.strchr)
  if (has_strchr()) {
    clear_has_libcall_cnt();
    ::libcall_types::strchr_t* temp = libcall_cnt_.strchr_;
    libcall_cnt_.strchr_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_strchr(::libcall_types::strchr_t* strchr) {
  clear_libcall_cnt();
  if (strchr) {
    set_has_strchr();
    libcall_cnt_.strchr_ = strchr;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.strchr)
}

// optional .libcall_types.exit_t exit = 20;
inline bool libcall_t::has_exit() const {
  return libcall_cnt_case() == kExit;
}
inline void libcall_t::set_has_exit() {
  _oneof_case_[0] = kExit;
}
inline void libcall_t::clear_exit() {
  if (has_exit()) {
    delete libcall_cnt_.exit_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::exit_t& libcall_t::exit() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.exit)
  return has_exit()
      ? *libcall_cnt_.exit_
      : ::libcall_types::exit_t::default_instance();
}
inline ::libcall_types::exit_t* libcall_t::mutable_exit() {
  if (!has_exit()) {
    clear_libcall_cnt();
    set_has_exit();
    libcall_cnt_.exit_ = new ::libcall_types::exit_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.exit)
  return libcall_cnt_.exit_;
}
inline ::libcall_types::exit_t* libcall_t::release_exit() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.exit)
  if (has_exit()) {
    clear_has_libcall_cnt();
    ::libcall_types::exit_t* temp = libcall_cnt_.exit_;
    libcall_cnt_.exit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_exit(::libcall_types::exit_t* exit) {
  clear_libcall_cnt();
  if (exit) {
    set_has_exit();
    libcall_cnt_.exit_ = exit;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.exit)
}

// optional .libcall_types.strcmp_t strcmp = 21;
inline bool libcall_t::has_strcmp() const {
  return libcall_cnt_case() == kStrcmp;
}
inline void libcall_t::set_has_strcmp() {
  _oneof_case_[0] = kStrcmp;
}
inline void libcall_t::clear_strcmp() {
  if (has_strcmp()) {
    delete libcall_cnt_.strcmp_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::strcmp_t& libcall_t::strcmp() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.strcmp)
  return has_strcmp()
      ? *libcall_cnt_.strcmp_
      : ::libcall_types::strcmp_t::default_instance();
}
inline ::libcall_types::strcmp_t* libcall_t::mutable_strcmp() {
  if (!has_strcmp()) {
    clear_libcall_cnt();
    set_has_strcmp();
    libcall_cnt_.strcmp_ = new ::libcall_types::strcmp_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.strcmp)
  return libcall_cnt_.strcmp_;
}
inline ::libcall_types::strcmp_t* libcall_t::release_strcmp() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.strcmp)
  if (has_strcmp()) {
    clear_has_libcall_cnt();
    ::libcall_types::strcmp_t* temp = libcall_cnt_.strcmp_;
    libcall_cnt_.strcmp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_strcmp(::libcall_types::strcmp_t* strcmp) {
  clear_libcall_cnt();
  if (strcmp) {
    set_has_strcmp();
    libcall_cnt_.strcmp_ = strcmp;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.strcmp)
}

// optional .libcall_types.ctype_b_loc_t ctype_b_loc = 23;
inline bool libcall_t::has_ctype_b_loc() const {
  return libcall_cnt_case() == kCtypeBLoc;
}
inline void libcall_t::set_has_ctype_b_loc() {
  _oneof_case_[0] = kCtypeBLoc;
}
inline void libcall_t::clear_ctype_b_loc() {
  if (has_ctype_b_loc()) {
    delete libcall_cnt_.ctype_b_loc_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::ctype_b_loc_t& libcall_t::ctype_b_loc() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.ctype_b_loc)
  return has_ctype_b_loc()
      ? *libcall_cnt_.ctype_b_loc_
      : ::libcall_types::ctype_b_loc_t::default_instance();
}
inline ::libcall_types::ctype_b_loc_t* libcall_t::mutable_ctype_b_loc() {
  if (!has_ctype_b_loc()) {
    clear_libcall_cnt();
    set_has_ctype_b_loc();
    libcall_cnt_.ctype_b_loc_ = new ::libcall_types::ctype_b_loc_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.ctype_b_loc)
  return libcall_cnt_.ctype_b_loc_;
}
inline ::libcall_types::ctype_b_loc_t* libcall_t::release_ctype_b_loc() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.ctype_b_loc)
  if (has_ctype_b_loc()) {
    clear_has_libcall_cnt();
    ::libcall_types::ctype_b_loc_t* temp = libcall_cnt_.ctype_b_loc_;
    libcall_cnt_.ctype_b_loc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_ctype_b_loc(::libcall_types::ctype_b_loc_t* ctype_b_loc) {
  clear_libcall_cnt();
  if (ctype_b_loc) {
    set_has_ctype_b_loc();
    libcall_cnt_.ctype_b_loc_ = ctype_b_loc;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.ctype_b_loc)
}

// optional .libcall_types.fscanf_t fscanf = 24;
inline bool libcall_t::has_fscanf() const {
  return libcall_cnt_case() == kFscanf;
}
inline void libcall_t::set_has_fscanf() {
  _oneof_case_[0] = kFscanf;
}
inline void libcall_t::clear_fscanf() {
  if (has_fscanf()) {
    delete libcall_cnt_.fscanf_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::fscanf_t& libcall_t::fscanf() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.fscanf)
  return has_fscanf()
      ? *libcall_cnt_.fscanf_
      : ::libcall_types::fscanf_t::default_instance();
}
inline ::libcall_types::fscanf_t* libcall_t::mutable_fscanf() {
  if (!has_fscanf()) {
    clear_libcall_cnt();
    set_has_fscanf();
    libcall_cnt_.fscanf_ = new ::libcall_types::fscanf_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.fscanf)
  return libcall_cnt_.fscanf_;
}
inline ::libcall_types::fscanf_t* libcall_t::release_fscanf() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.fscanf)
  if (has_fscanf()) {
    clear_has_libcall_cnt();
    ::libcall_types::fscanf_t* temp = libcall_cnt_.fscanf_;
    libcall_cnt_.fscanf_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_fscanf(::libcall_types::fscanf_t* fscanf) {
  clear_libcall_cnt();
  if (fscanf) {
    set_has_fscanf();
    libcall_cnt_.fscanf_ = fscanf;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.fscanf)
}

// optional .libcall_types.strncpy_t strncpy = 25;
inline bool libcall_t::has_strncpy() const {
  return libcall_cnt_case() == kStrncpy;
}
inline void libcall_t::set_has_strncpy() {
  _oneof_case_[0] = kStrncpy;
}
inline void libcall_t::clear_strncpy() {
  if (has_strncpy()) {
    delete libcall_cnt_.strncpy_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::strncpy_t& libcall_t::strncpy() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.strncpy)
  return has_strncpy()
      ? *libcall_cnt_.strncpy_
      : ::libcall_types::strncpy_t::default_instance();
}
inline ::libcall_types::strncpy_t* libcall_t::mutable_strncpy() {
  if (!has_strncpy()) {
    clear_libcall_cnt();
    set_has_strncpy();
    libcall_cnt_.strncpy_ = new ::libcall_types::strncpy_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.strncpy)
  return libcall_cnt_.strncpy_;
}
inline ::libcall_types::strncpy_t* libcall_t::release_strncpy() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.strncpy)
  if (has_strncpy()) {
    clear_has_libcall_cnt();
    ::libcall_types::strncpy_t* temp = libcall_cnt_.strncpy_;
    libcall_cnt_.strncpy_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_strncpy(::libcall_types::strncpy_t* strncpy) {
  clear_libcall_cnt();
  if (strncpy) {
    set_has_strncpy();
    libcall_cnt_.strncpy_ = strncpy;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.strncpy)
}

// optional .libcall_types.fstat_t fstat = 26;
inline bool libcall_t::has_fstat() const {
  return libcall_cnt_case() == kFstat;
}
inline void libcall_t::set_has_fstat() {
  _oneof_case_[0] = kFstat;
}
inline void libcall_t::clear_fstat() {
  if (has_fstat()) {
    delete libcall_cnt_.fstat_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::fstat_t& libcall_t::fstat() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.fstat)
  return has_fstat()
      ? *libcall_cnt_.fstat_
      : ::libcall_types::fstat_t::default_instance();
}
inline ::libcall_types::fstat_t* libcall_t::mutable_fstat() {
  if (!has_fstat()) {
    clear_libcall_cnt();
    set_has_fstat();
    libcall_cnt_.fstat_ = new ::libcall_types::fstat_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.fstat)
  return libcall_cnt_.fstat_;
}
inline ::libcall_types::fstat_t* libcall_t::release_fstat() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.fstat)
  if (has_fstat()) {
    clear_has_libcall_cnt();
    ::libcall_types::fstat_t* temp = libcall_cnt_.fstat_;
    libcall_cnt_.fstat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_fstat(::libcall_types::fstat_t* fstat) {
  clear_libcall_cnt();
  if (fstat) {
    set_has_fstat();
    libcall_cnt_.fstat_ = fstat;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.fstat)
}

// optional .libcall_types.realloc_t realloc = 27;
inline bool libcall_t::has_realloc() const {
  return libcall_cnt_case() == kRealloc;
}
inline void libcall_t::set_has_realloc() {
  _oneof_case_[0] = kRealloc;
}
inline void libcall_t::clear_realloc() {
  if (has_realloc()) {
    delete libcall_cnt_.realloc_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::realloc_t& libcall_t::realloc() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.realloc)
  return has_realloc()
      ? *libcall_cnt_.realloc_
      : ::libcall_types::realloc_t::default_instance();
}
inline ::libcall_types::realloc_t* libcall_t::mutable_realloc() {
  if (!has_realloc()) {
    clear_libcall_cnt();
    set_has_realloc();
    libcall_cnt_.realloc_ = new ::libcall_types::realloc_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.realloc)
  return libcall_cnt_.realloc_;
}
inline ::libcall_types::realloc_t* libcall_t::release_realloc() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.realloc)
  if (has_realloc()) {
    clear_has_libcall_cnt();
    ::libcall_types::realloc_t* temp = libcall_cnt_.realloc_;
    libcall_cnt_.realloc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_realloc(::libcall_types::realloc_t* realloc) {
  clear_libcall_cnt();
  if (realloc) {
    set_has_realloc();
    libcall_cnt_.realloc_ = realloc;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.realloc)
}

// optional .libcall_types.mmap_t mmap = 28;
inline bool libcall_t::has_mmap() const {
  return libcall_cnt_case() == kMmap;
}
inline void libcall_t::set_has_mmap() {
  _oneof_case_[0] = kMmap;
}
inline void libcall_t::clear_mmap() {
  if (has_mmap()) {
    delete libcall_cnt_.mmap_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::mmap_t& libcall_t::mmap() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.mmap)
  return has_mmap()
      ? *libcall_cnt_.mmap_
      : ::libcall_types::mmap_t::default_instance();
}
inline ::libcall_types::mmap_t* libcall_t::mutable_mmap() {
  if (!has_mmap()) {
    clear_libcall_cnt();
    set_has_mmap();
    libcall_cnt_.mmap_ = new ::libcall_types::mmap_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.mmap)
  return libcall_cnt_.mmap_;
}
inline ::libcall_types::mmap_t* libcall_t::release_mmap() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.mmap)
  if (has_mmap()) {
    clear_has_libcall_cnt();
    ::libcall_types::mmap_t* temp = libcall_cnt_.mmap_;
    libcall_cnt_.mmap_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_mmap(::libcall_types::mmap_t* mmap) {
  clear_libcall_cnt();
  if (mmap) {
    set_has_mmap();
    libcall_cnt_.mmap_ = mmap;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.mmap)
}

// optional .libcall_types.qsort_t qsort = 29;
inline bool libcall_t::has_qsort() const {
  return libcall_cnt_case() == kQsort;
}
inline void libcall_t::set_has_qsort() {
  _oneof_case_[0] = kQsort;
}
inline void libcall_t::clear_qsort() {
  if (has_qsort()) {
    delete libcall_cnt_.qsort_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::qsort_t& libcall_t::qsort() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.qsort)
  return has_qsort()
      ? *libcall_cnt_.qsort_
      : ::libcall_types::qsort_t::default_instance();
}
inline ::libcall_types::qsort_t* libcall_t::mutable_qsort() {
  if (!has_qsort()) {
    clear_libcall_cnt();
    set_has_qsort();
    libcall_cnt_.qsort_ = new ::libcall_types::qsort_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.qsort)
  return libcall_cnt_.qsort_;
}
inline ::libcall_types::qsort_t* libcall_t::release_qsort() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.qsort)
  if (has_qsort()) {
    clear_has_libcall_cnt();
    ::libcall_types::qsort_t* temp = libcall_cnt_.qsort_;
    libcall_cnt_.qsort_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_qsort(::libcall_types::qsort_t* qsort) {
  clear_libcall_cnt();
  if (qsort) {
    set_has_qsort();
    libcall_cnt_.qsort_ = qsort;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.qsort)
}

// optional .libcall_types.bsearch_t bsearch = 30;
inline bool libcall_t::has_bsearch() const {
  return libcall_cnt_case() == kBsearch;
}
inline void libcall_t::set_has_bsearch() {
  _oneof_case_[0] = kBsearch;
}
inline void libcall_t::clear_bsearch() {
  if (has_bsearch()) {
    delete libcall_cnt_.bsearch_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::bsearch_t& libcall_t::bsearch() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.bsearch)
  return has_bsearch()
      ? *libcall_cnt_.bsearch_
      : ::libcall_types::bsearch_t::default_instance();
}
inline ::libcall_types::bsearch_t* libcall_t::mutable_bsearch() {
  if (!has_bsearch()) {
    clear_libcall_cnt();
    set_has_bsearch();
    libcall_cnt_.bsearch_ = new ::libcall_types::bsearch_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.bsearch)
  return libcall_cnt_.bsearch_;
}
inline ::libcall_types::bsearch_t* libcall_t::release_bsearch() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.bsearch)
  if (has_bsearch()) {
    clear_has_libcall_cnt();
    ::libcall_types::bsearch_t* temp = libcall_cnt_.bsearch_;
    libcall_cnt_.bsearch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_bsearch(::libcall_types::bsearch_t* bsearch) {
  clear_libcall_cnt();
  if (bsearch) {
    set_has_bsearch();
    libcall_cnt_.bsearch_ = bsearch;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.bsearch)
}

// optional .libcall_types.open_t open_stub = 31;
inline bool libcall_t::has_open_stub() const {
  return libcall_cnt_case() == kOpenStub;
}
inline void libcall_t::set_has_open_stub() {
  _oneof_case_[0] = kOpenStub;
}
inline void libcall_t::clear_open_stub() {
  if (has_open_stub()) {
    delete libcall_cnt_.open_stub_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::open_t& libcall_t::open_stub() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.open_stub)
  return has_open_stub()
      ? *libcall_cnt_.open_stub_
      : ::libcall_types::open_t::default_instance();
}
inline ::libcall_types::open_t* libcall_t::mutable_open_stub() {
  if (!has_open_stub()) {
    clear_libcall_cnt();
    set_has_open_stub();
    libcall_cnt_.open_stub_ = new ::libcall_types::open_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.open_stub)
  return libcall_cnt_.open_stub_;
}
inline ::libcall_types::open_t* libcall_t::release_open_stub() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.open_stub)
  if (has_open_stub()) {
    clear_has_libcall_cnt();
    ::libcall_types::open_t* temp = libcall_cnt_.open_stub_;
    libcall_cnt_.open_stub_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_open_stub(::libcall_types::open_t* open_stub) {
  clear_libcall_cnt();
  if (open_stub) {
    set_has_open_stub();
    libcall_cnt_.open_stub_ = open_stub;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.open_stub)
}

// optional .libcall_types.lseek_t lseek = 32;
inline bool libcall_t::has_lseek() const {
  return libcall_cnt_case() == kLseek;
}
inline void libcall_t::set_has_lseek() {
  _oneof_case_[0] = kLseek;
}
inline void libcall_t::clear_lseek() {
  if (has_lseek()) {
    delete libcall_cnt_.lseek_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::lseek_t& libcall_t::lseek() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.lseek)
  return has_lseek()
      ? *libcall_cnt_.lseek_
      : ::libcall_types::lseek_t::default_instance();
}
inline ::libcall_types::lseek_t* libcall_t::mutable_lseek() {
  if (!has_lseek()) {
    clear_libcall_cnt();
    set_has_lseek();
    libcall_cnt_.lseek_ = new ::libcall_types::lseek_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.lseek)
  return libcall_cnt_.lseek_;
}
inline ::libcall_types::lseek_t* libcall_t::release_lseek() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.lseek)
  if (has_lseek()) {
    clear_has_libcall_cnt();
    ::libcall_types::lseek_t* temp = libcall_cnt_.lseek_;
    libcall_cnt_.lseek_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_lseek(::libcall_types::lseek_t* lseek) {
  clear_libcall_cnt();
  if (lseek) {
    set_has_lseek();
    libcall_cnt_.lseek_ = lseek;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.lseek)
}

// optional .libcall_types.fread_t fread = 33;
inline bool libcall_t::has_fread() const {
  return libcall_cnt_case() == kFread;
}
inline void libcall_t::set_has_fread() {
  _oneof_case_[0] = kFread;
}
inline void libcall_t::clear_fread() {
  if (has_fread()) {
    delete libcall_cnt_.fread_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::fread_t& libcall_t::fread() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.fread)
  return has_fread()
      ? *libcall_cnt_.fread_
      : ::libcall_types::fread_t::default_instance();
}
inline ::libcall_types::fread_t* libcall_t::mutable_fread() {
  if (!has_fread()) {
    clear_libcall_cnt();
    set_has_fread();
    libcall_cnt_.fread_ = new ::libcall_types::fread_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.fread)
  return libcall_cnt_.fread_;
}
inline ::libcall_types::fread_t* libcall_t::release_fread() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.fread)
  if (has_fread()) {
    clear_has_libcall_cnt();
    ::libcall_types::fread_t* temp = libcall_cnt_.fread_;
    libcall_cnt_.fread_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_fread(::libcall_types::fread_t* fread) {
  clear_libcall_cnt();
  if (fread) {
    set_has_fread();
    libcall_cnt_.fread_ = fread;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.fread)
}

// optional .libcall_types.strncmp_t strncmp = 34;
inline bool libcall_t::has_strncmp() const {
  return libcall_cnt_case() == kStrncmp;
}
inline void libcall_t::set_has_strncmp() {
  _oneof_case_[0] = kStrncmp;
}
inline void libcall_t::clear_strncmp() {
  if (has_strncmp()) {
    delete libcall_cnt_.strncmp_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::strncmp_t& libcall_t::strncmp() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.strncmp)
  return has_strncmp()
      ? *libcall_cnt_.strncmp_
      : ::libcall_types::strncmp_t::default_instance();
}
inline ::libcall_types::strncmp_t* libcall_t::mutable_strncmp() {
  if (!has_strncmp()) {
    clear_libcall_cnt();
    set_has_strncmp();
    libcall_cnt_.strncmp_ = new ::libcall_types::strncmp_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.strncmp)
  return libcall_cnt_.strncmp_;
}
inline ::libcall_types::strncmp_t* libcall_t::release_strncmp() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.strncmp)
  if (has_strncmp()) {
    clear_has_libcall_cnt();
    ::libcall_types::strncmp_t* temp = libcall_cnt_.strncmp_;
    libcall_cnt_.strncmp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_strncmp(::libcall_types::strncmp_t* strncmp) {
  clear_libcall_cnt();
  if (strncmp) {
    set_has_strncmp();
    libcall_cnt_.strncmp_ = strncmp;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.strncmp)
}

// optional .libcall_types.memcmp_t memcmp = 35;
inline bool libcall_t::has_memcmp() const {
  return libcall_cnt_case() == kMemcmp;
}
inline void libcall_t::set_has_memcmp() {
  _oneof_case_[0] = kMemcmp;
}
inline void libcall_t::clear_memcmp() {
  if (has_memcmp()) {
    delete libcall_cnt_.memcmp_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::memcmp_t& libcall_t::memcmp() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.memcmp)
  return has_memcmp()
      ? *libcall_cnt_.memcmp_
      : ::libcall_types::memcmp_t::default_instance();
}
inline ::libcall_types::memcmp_t* libcall_t::mutable_memcmp() {
  if (!has_memcmp()) {
    clear_libcall_cnt();
    set_has_memcmp();
    libcall_cnt_.memcmp_ = new ::libcall_types::memcmp_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.memcmp)
  return libcall_cnt_.memcmp_;
}
inline ::libcall_types::memcmp_t* libcall_t::release_memcmp() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.memcmp)
  if (has_memcmp()) {
    clear_has_libcall_cnt();
    ::libcall_types::memcmp_t* temp = libcall_cnt_.memcmp_;
    libcall_cnt_.memcmp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_memcmp(::libcall_types::memcmp_t* memcmp) {
  clear_libcall_cnt();
  if (memcmp) {
    set_has_memcmp();
    libcall_cnt_.memcmp_ = memcmp;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.memcmp)
}

// optional .libcall_types.fxstat64_t fxstat64 = 36;
inline bool libcall_t::has_fxstat64() const {
  return libcall_cnt_case() == kFxstat64;
}
inline void libcall_t::set_has_fxstat64() {
  _oneof_case_[0] = kFxstat64;
}
inline void libcall_t::clear_fxstat64() {
  if (has_fxstat64()) {
    delete libcall_cnt_.fxstat64_;
    clear_has_libcall_cnt();
  }
}
inline  const ::libcall_types::fxstat64_t& libcall_t::fxstat64() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.fxstat64)
  return has_fxstat64()
      ? *libcall_cnt_.fxstat64_
      : ::libcall_types::fxstat64_t::default_instance();
}
inline ::libcall_types::fxstat64_t* libcall_t::mutable_fxstat64() {
  if (!has_fxstat64()) {
    clear_libcall_cnt();
    set_has_fxstat64();
    libcall_cnt_.fxstat64_ = new ::libcall_types::fxstat64_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.fxstat64)
  return libcall_cnt_.fxstat64_;
}
inline ::libcall_types::fxstat64_t* libcall_t::release_fxstat64() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.fxstat64)
  if (has_fxstat64()) {
    clear_has_libcall_cnt();
    ::libcall_types::fxstat64_t* temp = libcall_cnt_.fxstat64_;
    libcall_cnt_.fxstat64_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void libcall_t::set_allocated_fxstat64(::libcall_types::fxstat64_t* fxstat64) {
  clear_libcall_cnt();
  if (fxstat64) {
    set_has_fxstat64();
    libcall_cnt_.fxstat64_ = fxstat64;
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.fxstat64)
}

inline bool libcall_t::has_libcall_cnt() const {
  return libcall_cnt_case() != LIBCALL_CNT_NOT_SET;
}
inline void libcall_t::clear_has_libcall_cnt() {
  _oneof_case_[0] = LIBCALL_CNT_NOT_SET;
}
inline libcall_t::LibcallCntCase libcall_t::libcall_cnt_case() const {
  return libcall_t::LibcallCntCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// generic_pol

// required .common.action ret = 1;
inline bool generic_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void generic_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void generic_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void generic_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action generic_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.generic_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void generic_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.generic_pol.ret)
}

// -------------------------------------------------------------------

// ctype_b_loc_pol

// required .common.memory_pol table = 1;
inline bool ctype_b_loc_pol::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ctype_b_loc_pol::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ctype_b_loc_pol::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ctype_b_loc_pol::clear_table() {
  if (table_ != NULL) table_->::common::memory_pol::Clear();
  clear_has_table();
}
inline const ::common::memory_pol& ctype_b_loc_pol::table() const {
  // @@protoc_insertion_point(field_get:libcall_types.ctype_b_loc_pol.table)
  return table_ != NULL ? *table_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* ctype_b_loc_pol::mutable_table() {
  set_has_table();
  if (table_ == NULL) {
    table_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.ctype_b_loc_pol.table)
  return table_;
}
inline ::common::memory_pol* ctype_b_loc_pol::release_table() {
  // @@protoc_insertion_point(field_release:libcall_types.ctype_b_loc_pol.table)
  clear_has_table();
  ::common::memory_pol* temp = table_;
  table_ = NULL;
  return temp;
}
inline void ctype_b_loc_pol::set_allocated_table(::common::memory_pol* table) {
  delete table_;
  table_ = table;
  if (table) {
    set_has_table();
  } else {
    clear_has_table();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.ctype_b_loc_pol.table)
}

// required .common.action ret = 2;
inline bool ctype_b_loc_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ctype_b_loc_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ctype_b_loc_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ctype_b_loc_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action ctype_b_loc_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.ctype_b_loc_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void ctype_b_loc_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.ctype_b_loc_pol.ret)
}

// -------------------------------------------------------------------

// exit_pol

// -------------------------------------------------------------------

// fscanf_pol

// required .common.action stream = 1;
inline bool fscanf_pol::has_stream() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fscanf_pol::set_has_stream() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fscanf_pol::clear_has_stream() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fscanf_pol::clear_stream() {
  stream_ = 0;
  clear_has_stream();
}
inline ::common::action fscanf_pol::stream() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_pol.stream)
  return static_cast< ::common::action >(stream_);
}
inline void fscanf_pol::set_stream(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_stream();
  stream_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_pol.stream)
}

// required .common.action elems = 2;
inline bool fscanf_pol::has_elems() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fscanf_pol::set_has_elems() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fscanf_pol::clear_has_elems() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fscanf_pol::clear_elems() {
  elems_ = 0;
  clear_has_elems();
}
inline ::common::action fscanf_pol::elems() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_pol.elems)
  return static_cast< ::common::action >(elems_);
}
inline void fscanf_pol::set_elems(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_elems();
  elems_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_pol.elems)
}

// required .common.action ret = 3;
inline bool fscanf_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fscanf_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fscanf_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fscanf_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action fscanf_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void fscanf_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_pol.ret)
}

// -------------------------------------------------------------------

// read_pol

// required .common.action fd = 1;
inline bool read_pol::has_fd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void read_pol::set_has_fd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void read_pol::clear_has_fd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void read_pol::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::common::action read_pol::fd() const {
  // @@protoc_insertion_point(field_get:libcall_types.read_pol.fd)
  return static_cast< ::common::action >(fd_);
}
inline void read_pol::set_fd(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_fd();
  fd_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.read_pol.fd)
}

// required .common.memory_pol buf = 2;
inline bool read_pol::has_buf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void read_pol::set_has_buf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void read_pol::clear_has_buf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void read_pol::clear_buf() {
  if (buf_ != NULL) buf_->::common::memory_pol::Clear();
  clear_has_buf();
}
inline const ::common::memory_pol& read_pol::buf() const {
  // @@protoc_insertion_point(field_get:libcall_types.read_pol.buf)
  return buf_ != NULL ? *buf_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* read_pol::mutable_buf() {
  set_has_buf();
  if (buf_ == NULL) {
    buf_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.read_pol.buf)
  return buf_;
}
inline ::common::memory_pol* read_pol::release_buf() {
  // @@protoc_insertion_point(field_release:libcall_types.read_pol.buf)
  clear_has_buf();
  ::common::memory_pol* temp = buf_;
  buf_ = NULL;
  return temp;
}
inline void read_pol::set_allocated_buf(::common::memory_pol* buf) {
  delete buf_;
  buf_ = buf;
  if (buf) {
    set_has_buf();
  } else {
    clear_has_buf();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.read_pol.buf)
}

// required .common.action count = 3;
inline bool read_pol::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void read_pol::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void read_pol::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void read_pol::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::common::action read_pol::count() const {
  // @@protoc_insertion_point(field_get:libcall_types.read_pol.count)
  return static_cast< ::common::action >(count_);
}
inline void read_pol::set_count(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.read_pol.count)
}

// required .common.action ret = 4;
inline bool read_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void read_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void read_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void read_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action read_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.read_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void read_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.read_pol.ret)
}

// -------------------------------------------------------------------

// fread_pol

// required .common.memory_pol ptr = 1;
inline bool fread_pol::has_ptr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fread_pol::set_has_ptr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fread_pol::clear_has_ptr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fread_pol::clear_ptr() {
  if (ptr_ != NULL) ptr_->::common::memory_pol::Clear();
  clear_has_ptr();
}
inline const ::common::memory_pol& fread_pol::ptr() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_pol.ptr)
  return ptr_ != NULL ? *ptr_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* fread_pol::mutable_ptr() {
  set_has_ptr();
  if (ptr_ == NULL) {
    ptr_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.fread_pol.ptr)
  return ptr_;
}
inline ::common::memory_pol* fread_pol::release_ptr() {
  // @@protoc_insertion_point(field_release:libcall_types.fread_pol.ptr)
  clear_has_ptr();
  ::common::memory_pol* temp = ptr_;
  ptr_ = NULL;
  return temp;
}
inline void fread_pol::set_allocated_ptr(::common::memory_pol* ptr) {
  delete ptr_;
  ptr_ = ptr;
  if (ptr) {
    set_has_ptr();
  } else {
    clear_has_ptr();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.fread_pol.ptr)
}

// required .common.action size = 2;
inline bool fread_pol::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fread_pol::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fread_pol::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fread_pol::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::common::action fread_pol::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_pol.size)
  return static_cast< ::common::action >(size_);
}
inline void fread_pol::set_size(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fread_pol.size)
}

// required .common.action nmemb = 3;
inline bool fread_pol::has_nmemb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fread_pol::set_has_nmemb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fread_pol::clear_has_nmemb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fread_pol::clear_nmemb() {
  nmemb_ = 0;
  clear_has_nmemb();
}
inline ::common::action fread_pol::nmemb() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_pol.nmemb)
  return static_cast< ::common::action >(nmemb_);
}
inline void fread_pol::set_nmemb(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_nmemb();
  nmemb_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fread_pol.nmemb)
}

// required .common.action stream = 4;
inline bool fread_pol::has_stream() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fread_pol::set_has_stream() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fread_pol::clear_has_stream() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fread_pol::clear_stream() {
  stream_ = 0;
  clear_has_stream();
}
inline ::common::action fread_pol::stream() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_pol.stream)
  return static_cast< ::common::action >(stream_);
}
inline void fread_pol::set_stream(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_stream();
  stream_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fread_pol.stream)
}

// required .common.action ret = 5;
inline bool fread_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fread_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fread_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fread_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action fread_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void fread_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fread_pol.ret)
}

// -------------------------------------------------------------------

// strcmp_pol

// required .common.memory_pol src = 1;
inline bool strcmp_pol::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void strcmp_pol::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void strcmp_pol::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void strcmp_pol::clear_src() {
  if (src_ != NULL) src_->::common::memory_pol::Clear();
  clear_has_src();
}
inline const ::common::memory_pol& strcmp_pol::src() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcmp_pol.src)
  return src_ != NULL ? *src_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* strcmp_pol::mutable_src() {
  set_has_src();
  if (src_ == NULL) {
    src_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.strcmp_pol.src)
  return src_;
}
inline ::common::memory_pol* strcmp_pol::release_src() {
  // @@protoc_insertion_point(field_release:libcall_types.strcmp_pol.src)
  clear_has_src();
  ::common::memory_pol* temp = src_;
  src_ = NULL;
  return temp;
}
inline void strcmp_pol::set_allocated_src(::common::memory_pol* src) {
  delete src_;
  src_ = src;
  if (src) {
    set_has_src();
  } else {
    clear_has_src();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.strcmp_pol.src)
}

// required .common.memory_pol dst = 2;
inline bool strcmp_pol::has_dst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void strcmp_pol::set_has_dst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void strcmp_pol::clear_has_dst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void strcmp_pol::clear_dst() {
  if (dst_ != NULL) dst_->::common::memory_pol::Clear();
  clear_has_dst();
}
inline const ::common::memory_pol& strcmp_pol::dst() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcmp_pol.dst)
  return dst_ != NULL ? *dst_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* strcmp_pol::mutable_dst() {
  set_has_dst();
  if (dst_ == NULL) {
    dst_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.strcmp_pol.dst)
  return dst_;
}
inline ::common::memory_pol* strcmp_pol::release_dst() {
  // @@protoc_insertion_point(field_release:libcall_types.strcmp_pol.dst)
  clear_has_dst();
  ::common::memory_pol* temp = dst_;
  dst_ = NULL;
  return temp;
}
inline void strcmp_pol::set_allocated_dst(::common::memory_pol* dst) {
  delete dst_;
  dst_ = dst;
  if (dst) {
    set_has_dst();
  } else {
    clear_has_dst();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.strcmp_pol.dst)
}

// required .common.action ret = 3;
inline bool strcmp_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strcmp_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void strcmp_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void strcmp_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action strcmp_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcmp_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void strcmp_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strcmp_pol.ret)
}

// -------------------------------------------------------------------

// strncmp_pol

// required .common.action s1 = 1;
inline bool strncmp_pol::has_s1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void strncmp_pol::set_has_s1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void strncmp_pol::clear_has_s1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void strncmp_pol::clear_s1() {
  s1_ = 0;
  clear_has_s1();
}
inline ::common::action strncmp_pol::s1() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncmp_pol.s1)
  return static_cast< ::common::action >(s1_);
}
inline void strncmp_pol::set_s1(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_s1();
  s1_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncmp_pol.s1)
}

// required .common.action s2 = 2;
inline bool strncmp_pol::has_s2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void strncmp_pol::set_has_s2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void strncmp_pol::clear_has_s2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void strncmp_pol::clear_s2() {
  s2_ = 0;
  clear_has_s2();
}
inline ::common::action strncmp_pol::s2() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncmp_pol.s2)
  return static_cast< ::common::action >(s2_);
}
inline void strncmp_pol::set_s2(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_s2();
  s2_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncmp_pol.s2)
}

// required .common.action n = 3;
inline bool strncmp_pol::has_n() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strncmp_pol::set_has_n() {
  _has_bits_[0] |= 0x00000004u;
}
inline void strncmp_pol::clear_has_n() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void strncmp_pol::clear_n() {
  n_ = 0;
  clear_has_n();
}
inline ::common::action strncmp_pol::n() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncmp_pol.n)
  return static_cast< ::common::action >(n_);
}
inline void strncmp_pol::set_n(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_n();
  n_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncmp_pol.n)
}

// required .common.action ret = 4;
inline bool strncmp_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void strncmp_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void strncmp_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void strncmp_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action strncmp_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncmp_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void strncmp_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncmp_pol.ret)
}

// -------------------------------------------------------------------

// memcmp_pol

// required .common.action s1 = 1;
inline bool memcmp_pol::has_s1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void memcmp_pol::set_has_s1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void memcmp_pol::clear_has_s1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void memcmp_pol::clear_s1() {
  s1_ = 0;
  clear_has_s1();
}
inline ::common::action memcmp_pol::s1() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcmp_pol.s1)
  return static_cast< ::common::action >(s1_);
}
inline void memcmp_pol::set_s1(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_s1();
  s1_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcmp_pol.s1)
}

// required .common.action s2 = 2;
inline bool memcmp_pol::has_s2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void memcmp_pol::set_has_s2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void memcmp_pol::clear_has_s2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void memcmp_pol::clear_s2() {
  s2_ = 0;
  clear_has_s2();
}
inline ::common::action memcmp_pol::s2() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcmp_pol.s2)
  return static_cast< ::common::action >(s2_);
}
inline void memcmp_pol::set_s2(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_s2();
  s2_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcmp_pol.s2)
}

// required .common.action n = 3;
inline bool memcmp_pol::has_n() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void memcmp_pol::set_has_n() {
  _has_bits_[0] |= 0x00000004u;
}
inline void memcmp_pol::clear_has_n() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void memcmp_pol::clear_n() {
  n_ = 0;
  clear_has_n();
}
inline ::common::action memcmp_pol::n() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcmp_pol.n)
  return static_cast< ::common::action >(n_);
}
inline void memcmp_pol::set_n(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_n();
  n_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcmp_pol.n)
}

// required .common.action ret = 4;
inline bool memcmp_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void memcmp_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void memcmp_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void memcmp_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action memcmp_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcmp_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void memcmp_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcmp_pol.ret)
}

// -------------------------------------------------------------------

// strchr_pol

// required .common.memory_pol sc = 1;
inline bool strchr_pol::has_sc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void strchr_pol::set_has_sc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void strchr_pol::clear_has_sc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void strchr_pol::clear_sc() {
  if (sc_ != NULL) sc_->::common::memory_pol::Clear();
  clear_has_sc();
}
inline const ::common::memory_pol& strchr_pol::sc() const {
  // @@protoc_insertion_point(field_get:libcall_types.strchr_pol.sc)
  return sc_ != NULL ? *sc_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* strchr_pol::mutable_sc() {
  set_has_sc();
  if (sc_ == NULL) {
    sc_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.strchr_pol.sc)
  return sc_;
}
inline ::common::memory_pol* strchr_pol::release_sc() {
  // @@protoc_insertion_point(field_release:libcall_types.strchr_pol.sc)
  clear_has_sc();
  ::common::memory_pol* temp = sc_;
  sc_ = NULL;
  return temp;
}
inline void strchr_pol::set_allocated_sc(::common::memory_pol* sc) {
  delete sc_;
  sc_ = sc;
  if (sc) {
    set_has_sc();
  } else {
    clear_has_sc();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.strchr_pol.sc)
}

// required .common.memory_pol c = 2;
inline bool strchr_pol::has_c() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void strchr_pol::set_has_c() {
  _has_bits_[0] |= 0x00000002u;
}
inline void strchr_pol::clear_has_c() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void strchr_pol::clear_c() {
  if (c_ != NULL) c_->::common::memory_pol::Clear();
  clear_has_c();
}
inline const ::common::memory_pol& strchr_pol::c() const {
  // @@protoc_insertion_point(field_get:libcall_types.strchr_pol.c)
  return c_ != NULL ? *c_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* strchr_pol::mutable_c() {
  set_has_c();
  if (c_ == NULL) {
    c_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.strchr_pol.c)
  return c_;
}
inline ::common::memory_pol* strchr_pol::release_c() {
  // @@protoc_insertion_point(field_release:libcall_types.strchr_pol.c)
  clear_has_c();
  ::common::memory_pol* temp = c_;
  c_ = NULL;
  return temp;
}
inline void strchr_pol::set_allocated_c(::common::memory_pol* c) {
  delete c_;
  c_ = c;
  if (c) {
    set_has_c();
  } else {
    clear_has_c();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.strchr_pol.c)
}

// required .common.action ret = 3;
inline bool strchr_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strchr_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void strchr_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void strchr_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action strchr_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strchr_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void strchr_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strchr_pol.ret)
}

// -------------------------------------------------------------------

// strncpy_pol

// required .common.action dst = 1;
inline bool strncpy_pol::has_dst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void strncpy_pol::set_has_dst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void strncpy_pol::clear_has_dst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void strncpy_pol::clear_dst() {
  dst_ = 0;
  clear_has_dst();
}
inline ::common::action strncpy_pol::dst() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncpy_pol.dst)
  return static_cast< ::common::action >(dst_);
}
inline void strncpy_pol::set_dst(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_dst();
  dst_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncpy_pol.dst)
}

// required .common.action src = 2;
inline bool strncpy_pol::has_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void strncpy_pol::set_has_src() {
  _has_bits_[0] |= 0x00000002u;
}
inline void strncpy_pol::clear_has_src() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void strncpy_pol::clear_src() {
  src_ = 0;
  clear_has_src();
}
inline ::common::action strncpy_pol::src() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncpy_pol.src)
  return static_cast< ::common::action >(src_);
}
inline void strncpy_pol::set_src(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_src();
  src_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncpy_pol.src)
}

// required .common.action n = 3;
inline bool strncpy_pol::has_n() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strncpy_pol::set_has_n() {
  _has_bits_[0] |= 0x00000004u;
}
inline void strncpy_pol::clear_has_n() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void strncpy_pol::clear_n() {
  n_ = 0;
  clear_has_n();
}
inline ::common::action strncpy_pol::n() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncpy_pol.n)
  return static_cast< ::common::action >(n_);
}
inline void strncpy_pol::set_n(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_n();
  n_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncpy_pol.n)
}

// required .common.action ret = 4;
inline bool strncpy_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void strncpy_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void strncpy_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void strncpy_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action strncpy_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncpy_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void strncpy_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncpy_pol.ret)
}

// -------------------------------------------------------------------

// fstat_pol

// -------------------------------------------------------------------

// fxstat64_pol

// -------------------------------------------------------------------

// realloc_pol

// required .common.action ptr = 1;
inline bool realloc_pol::has_ptr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void realloc_pol::set_has_ptr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void realloc_pol::clear_has_ptr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void realloc_pol::clear_ptr() {
  ptr_ = 0;
  clear_has_ptr();
}
inline ::common::action realloc_pol::ptr() const {
  // @@protoc_insertion_point(field_get:libcall_types.realloc_pol.ptr)
  return static_cast< ::common::action >(ptr_);
}
inline void realloc_pol::set_ptr(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ptr();
  ptr_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.realloc_pol.ptr)
}

// required .common.action size = 2;
inline bool realloc_pol::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void realloc_pol::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void realloc_pol::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void realloc_pol::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::common::action realloc_pol::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.realloc_pol.size)
  return static_cast< ::common::action >(size_);
}
inline void realloc_pol::set_size(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.realloc_pol.size)
}

// required .common.action ret = 3;
inline bool realloc_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void realloc_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void realloc_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void realloc_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action realloc_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.realloc_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void realloc_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.realloc_pol.ret)
}

// -------------------------------------------------------------------

// mmap_pol

// required .common.action addr = 1;
inline bool mmap_pol::has_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mmap_pol::set_has_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mmap_pol::clear_has_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mmap_pol::clear_addr() {
  addr_ = 0;
  clear_has_addr();
}
inline ::common::action mmap_pol::addr() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_pol.addr)
  return static_cast< ::common::action >(addr_);
}
inline void mmap_pol::set_addr(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_addr();
  addr_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_pol.addr)
}

// required .common.action length = 2;
inline bool mmap_pol::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mmap_pol::set_has_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mmap_pol::clear_has_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mmap_pol::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::common::action mmap_pol::length() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_pol.length)
  return static_cast< ::common::action >(length_);
}
inline void mmap_pol::set_length(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_pol.length)
}

// required .common.action prot = 3;
inline bool mmap_pol::has_prot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mmap_pol::set_has_prot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mmap_pol::clear_has_prot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mmap_pol::clear_prot() {
  prot_ = 0;
  clear_has_prot();
}
inline ::common::action mmap_pol::prot() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_pol.prot)
  return static_cast< ::common::action >(prot_);
}
inline void mmap_pol::set_prot(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_prot();
  prot_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_pol.prot)
}

// required .common.action flags = 4;
inline bool mmap_pol::has_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mmap_pol::set_has_flags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void mmap_pol::clear_has_flags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void mmap_pol::clear_flags() {
  flags_ = 0;
  clear_has_flags();
}
inline ::common::action mmap_pol::flags() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_pol.flags)
  return static_cast< ::common::action >(flags_);
}
inline void mmap_pol::set_flags(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_pol.flags)
}

// required .common.action fd = 5;
inline bool mmap_pol::has_fd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void mmap_pol::set_has_fd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void mmap_pol::clear_has_fd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void mmap_pol::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::common::action mmap_pol::fd() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_pol.fd)
  return static_cast< ::common::action >(fd_);
}
inline void mmap_pol::set_fd(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_fd();
  fd_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_pol.fd)
}

// required .common.action offset = 6;
inline bool mmap_pol::has_offset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void mmap_pol::set_has_offset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void mmap_pol::clear_has_offset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void mmap_pol::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::common::action mmap_pol::offset() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_pol.offset)
  return static_cast< ::common::action >(offset_);
}
inline void mmap_pol::set_offset(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_pol.offset)
}

// required .common.memory_pol ret = 7;
inline bool mmap_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mmap_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mmap_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mmap_pol::clear_ret() {
  if (ret_ != NULL) ret_->::common::memory_pol::Clear();
  clear_has_ret();
}
inline const ::common::memory_pol& mmap_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_pol.ret)
  return ret_ != NULL ? *ret_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* mmap_pol::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) {
    ret_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.mmap_pol.ret)
  return ret_;
}
inline ::common::memory_pol* mmap_pol::release_ret() {
  // @@protoc_insertion_point(field_release:libcall_types.mmap_pol.ret)
  clear_has_ret();
  ::common::memory_pol* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void mmap_pol::set_allocated_ret(::common::memory_pol* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.mmap_pol.ret)
}

// -------------------------------------------------------------------

// qsort_pol

// required .common.memory_pol base = 1;
inline bool qsort_pol::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void qsort_pol::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void qsort_pol::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void qsort_pol::clear_base() {
  if (base_ != NULL) base_->::common::memory_pol::Clear();
  clear_has_base();
}
inline const ::common::memory_pol& qsort_pol::base() const {
  // @@protoc_insertion_point(field_get:libcall_types.qsort_pol.base)
  return base_ != NULL ? *base_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* qsort_pol::mutable_base() {
  set_has_base();
  if (base_ == NULL) {
    base_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.qsort_pol.base)
  return base_;
}
inline ::common::memory_pol* qsort_pol::release_base() {
  // @@protoc_insertion_point(field_release:libcall_types.qsort_pol.base)
  clear_has_base();
  ::common::memory_pol* temp = base_;
  base_ = NULL;
  return temp;
}
inline void qsort_pol::set_allocated_base(::common::memory_pol* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.qsort_pol.base)
}

// required .common.action nmemb = 2;
inline bool qsort_pol::has_nmemb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void qsort_pol::set_has_nmemb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void qsort_pol::clear_has_nmemb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void qsort_pol::clear_nmemb() {
  nmemb_ = 0;
  clear_has_nmemb();
}
inline ::common::action qsort_pol::nmemb() const {
  // @@protoc_insertion_point(field_get:libcall_types.qsort_pol.nmemb)
  return static_cast< ::common::action >(nmemb_);
}
inline void qsort_pol::set_nmemb(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_nmemb();
  nmemb_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.qsort_pol.nmemb)
}

// required .common.action size = 3;
inline bool qsort_pol::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void qsort_pol::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void qsort_pol::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void qsort_pol::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::common::action qsort_pol::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.qsort_pol.size)
  return static_cast< ::common::action >(size_);
}
inline void qsort_pol::set_size(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.qsort_pol.size)
}

// required .common.action compare = 4;
inline bool qsort_pol::has_compare() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void qsort_pol::set_has_compare() {
  _has_bits_[0] |= 0x00000008u;
}
inline void qsort_pol::clear_has_compare() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void qsort_pol::clear_compare() {
  compare_ = 0;
  clear_has_compare();
}
inline ::common::action qsort_pol::compare() const {
  // @@protoc_insertion_point(field_get:libcall_types.qsort_pol.compare)
  return static_cast< ::common::action >(compare_);
}
inline void qsort_pol::set_compare(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_compare();
  compare_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.qsort_pol.compare)
}

// -------------------------------------------------------------------

// bsearch_pol

// required .common.memory_pol key = 1;
inline bool bsearch_pol::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void bsearch_pol::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void bsearch_pol::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void bsearch_pol::clear_key() {
  if (key_ != NULL) key_->::common::memory_pol::Clear();
  clear_has_key();
}
inline const ::common::memory_pol& bsearch_pol::key() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_pol.key)
  return key_ != NULL ? *key_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* bsearch_pol::mutable_key() {
  set_has_key();
  if (key_ == NULL) {
    key_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.bsearch_pol.key)
  return key_;
}
inline ::common::memory_pol* bsearch_pol::release_key() {
  // @@protoc_insertion_point(field_release:libcall_types.bsearch_pol.key)
  clear_has_key();
  ::common::memory_pol* temp = key_;
  key_ = NULL;
  return temp;
}
inline void bsearch_pol::set_allocated_key(::common::memory_pol* key) {
  delete key_;
  key_ = key;
  if (key) {
    set_has_key();
  } else {
    clear_has_key();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.bsearch_pol.key)
}

// required .common.memory_pol base = 2;
inline bool bsearch_pol::has_base() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void bsearch_pol::set_has_base() {
  _has_bits_[0] |= 0x00000002u;
}
inline void bsearch_pol::clear_has_base() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void bsearch_pol::clear_base() {
  if (base_ != NULL) base_->::common::memory_pol::Clear();
  clear_has_base();
}
inline const ::common::memory_pol& bsearch_pol::base() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_pol.base)
  return base_ != NULL ? *base_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* bsearch_pol::mutable_base() {
  set_has_base();
  if (base_ == NULL) {
    base_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.bsearch_pol.base)
  return base_;
}
inline ::common::memory_pol* bsearch_pol::release_base() {
  // @@protoc_insertion_point(field_release:libcall_types.bsearch_pol.base)
  clear_has_base();
  ::common::memory_pol* temp = base_;
  base_ = NULL;
  return temp;
}
inline void bsearch_pol::set_allocated_base(::common::memory_pol* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.bsearch_pol.base)
}

// required .common.action nmemb = 3;
inline bool bsearch_pol::has_nmemb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void bsearch_pol::set_has_nmemb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void bsearch_pol::clear_has_nmemb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void bsearch_pol::clear_nmemb() {
  nmemb_ = 0;
  clear_has_nmemb();
}
inline ::common::action bsearch_pol::nmemb() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_pol.nmemb)
  return static_cast< ::common::action >(nmemb_);
}
inline void bsearch_pol::set_nmemb(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_nmemb();
  nmemb_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.bsearch_pol.nmemb)
}

// required .common.action size = 4;
inline bool bsearch_pol::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void bsearch_pol::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void bsearch_pol::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void bsearch_pol::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::common::action bsearch_pol::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_pol.size)
  return static_cast< ::common::action >(size_);
}
inline void bsearch_pol::set_size(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.bsearch_pol.size)
}

// required .common.action compare = 5;
inline bool bsearch_pol::has_compare() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void bsearch_pol::set_has_compare() {
  _has_bits_[0] |= 0x00000020u;
}
inline void bsearch_pol::clear_has_compare() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void bsearch_pol::clear_compare() {
  compare_ = 0;
  clear_has_compare();
}
inline ::common::action bsearch_pol::compare() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_pol.compare)
  return static_cast< ::common::action >(compare_);
}
inline void bsearch_pol::set_compare(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_compare();
  compare_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.bsearch_pol.compare)
}

// required .common.memory_pol ret = 6;
inline bool bsearch_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void bsearch_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void bsearch_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void bsearch_pol::clear_ret() {
  if (ret_ != NULL) ret_->::common::memory_pol::Clear();
  clear_has_ret();
}
inline const ::common::memory_pol& bsearch_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_pol.ret)
  return ret_ != NULL ? *ret_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* bsearch_pol::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) {
    ret_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.bsearch_pol.ret)
  return ret_;
}
inline ::common::memory_pol* bsearch_pol::release_ret() {
  // @@protoc_insertion_point(field_release:libcall_types.bsearch_pol.ret)
  clear_has_ret();
  ::common::memory_pol* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void bsearch_pol::set_allocated_ret(::common::memory_pol* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.bsearch_pol.ret)
}

// -------------------------------------------------------------------

// open_pol

// required .common.memory_pol pathname = 1;
inline bool open_pol::has_pathname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void open_pol::set_has_pathname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void open_pol::clear_has_pathname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void open_pol::clear_pathname() {
  if (pathname_ != NULL) pathname_->::common::memory_pol::Clear();
  clear_has_pathname();
}
inline const ::common::memory_pol& open_pol::pathname() const {
  // @@protoc_insertion_point(field_get:libcall_types.open_pol.pathname)
  return pathname_ != NULL ? *pathname_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* open_pol::mutable_pathname() {
  set_has_pathname();
  if (pathname_ == NULL) {
    pathname_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.open_pol.pathname)
  return pathname_;
}
inline ::common::memory_pol* open_pol::release_pathname() {
  // @@protoc_insertion_point(field_release:libcall_types.open_pol.pathname)
  clear_has_pathname();
  ::common::memory_pol* temp = pathname_;
  pathname_ = NULL;
  return temp;
}
inline void open_pol::set_allocated_pathname(::common::memory_pol* pathname) {
  delete pathname_;
  pathname_ = pathname;
  if (pathname) {
    set_has_pathname();
  } else {
    clear_has_pathname();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.open_pol.pathname)
}

// required .common.action flags = 2;
inline bool open_pol::has_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void open_pol::set_has_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void open_pol::clear_has_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void open_pol::clear_flags() {
  flags_ = 0;
  clear_has_flags();
}
inline ::common::action open_pol::flags() const {
  // @@protoc_insertion_point(field_get:libcall_types.open_pol.flags)
  return static_cast< ::common::action >(flags_);
}
inline void open_pol::set_flags(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.open_pol.flags)
}

// required .common.action mode = 3;
inline bool open_pol::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void open_pol::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void open_pol::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void open_pol::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::common::action open_pol::mode() const {
  // @@protoc_insertion_point(field_get:libcall_types.open_pol.mode)
  return static_cast< ::common::action >(mode_);
}
inline void open_pol::set_mode(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.open_pol.mode)
}

// required .common.action ret = 4;
inline bool open_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void open_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void open_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void open_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action open_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.open_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void open_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.open_pol.ret)
}

// -------------------------------------------------------------------

// strcpy_pol

// required .common.memory_pol src = 1;
inline bool strcpy_pol::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void strcpy_pol::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void strcpy_pol::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void strcpy_pol::clear_src() {
  if (src_ != NULL) src_->::common::memory_pol::Clear();
  clear_has_src();
}
inline const ::common::memory_pol& strcpy_pol::src() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcpy_pol.src)
  return src_ != NULL ? *src_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* strcpy_pol::mutable_src() {
  set_has_src();
  if (src_ == NULL) {
    src_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.strcpy_pol.src)
  return src_;
}
inline ::common::memory_pol* strcpy_pol::release_src() {
  // @@protoc_insertion_point(field_release:libcall_types.strcpy_pol.src)
  clear_has_src();
  ::common::memory_pol* temp = src_;
  src_ = NULL;
  return temp;
}
inline void strcpy_pol::set_allocated_src(::common::memory_pol* src) {
  delete src_;
  src_ = src;
  if (src) {
    set_has_src();
  } else {
    clear_has_src();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.strcpy_pol.src)
}

// required .common.memory_pol dst = 2;
inline bool strcpy_pol::has_dst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void strcpy_pol::set_has_dst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void strcpy_pol::clear_has_dst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void strcpy_pol::clear_dst() {
  if (dst_ != NULL) dst_->::common::memory_pol::Clear();
  clear_has_dst();
}
inline const ::common::memory_pol& strcpy_pol::dst() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcpy_pol.dst)
  return dst_ != NULL ? *dst_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* strcpy_pol::mutable_dst() {
  set_has_dst();
  if (dst_ == NULL) {
    dst_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.strcpy_pol.dst)
  return dst_;
}
inline ::common::memory_pol* strcpy_pol::release_dst() {
  // @@protoc_insertion_point(field_release:libcall_types.strcpy_pol.dst)
  clear_has_dst();
  ::common::memory_pol* temp = dst_;
  dst_ = NULL;
  return temp;
}
inline void strcpy_pol::set_allocated_dst(::common::memory_pol* dst) {
  delete dst_;
  dst_ = dst;
  if (dst) {
    set_has_dst();
  } else {
    clear_has_dst();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.strcpy_pol.dst)
}

// required .common.action ret = 3;
inline bool strcpy_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strcpy_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void strcpy_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void strcpy_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action strcpy_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcpy_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void strcpy_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strcpy_pol.ret)
}

// -------------------------------------------------------------------

// printf_pol

// required .common.memory_pol format = 1;
inline bool printf_pol::has_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void printf_pol::set_has_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void printf_pol::clear_has_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void printf_pol::clear_format() {
  if (format_ != NULL) format_->::common::memory_pol::Clear();
  clear_has_format();
}
inline const ::common::memory_pol& printf_pol::format() const {
  // @@protoc_insertion_point(field_get:libcall_types.printf_pol.format)
  return format_ != NULL ? *format_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* printf_pol::mutable_format() {
  set_has_format();
  if (format_ == NULL) {
    format_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.printf_pol.format)
  return format_;
}
inline ::common::memory_pol* printf_pol::release_format() {
  // @@protoc_insertion_point(field_release:libcall_types.printf_pol.format)
  clear_has_format();
  ::common::memory_pol* temp = format_;
  format_ = NULL;
  return temp;
}
inline void printf_pol::set_allocated_format(::common::memory_pol* format) {
  delete format_;
  format_ = format;
  if (format) {
    set_has_format();
  } else {
    clear_has_format();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.printf_pol.format)
}

// required .common.action ret = 2;
inline bool printf_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void printf_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void printf_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void printf_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action printf_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.printf_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void printf_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.printf_pol.ret)
}

// -------------------------------------------------------------------

// atoi_pol

// required .common.memory_pol src = 1;
inline bool atoi_pol::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void atoi_pol::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void atoi_pol::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void atoi_pol::clear_src() {
  if (src_ != NULL) src_->::common::memory_pol::Clear();
  clear_has_src();
}
inline const ::common::memory_pol& atoi_pol::src() const {
  // @@protoc_insertion_point(field_get:libcall_types.atoi_pol.src)
  return src_ != NULL ? *src_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* atoi_pol::mutable_src() {
  set_has_src();
  if (src_ == NULL) {
    src_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.atoi_pol.src)
  return src_;
}
inline ::common::memory_pol* atoi_pol::release_src() {
  // @@protoc_insertion_point(field_release:libcall_types.atoi_pol.src)
  clear_has_src();
  ::common::memory_pol* temp = src_;
  src_ = NULL;
  return temp;
}
inline void atoi_pol::set_allocated_src(::common::memory_pol* src) {
  delete src_;
  src_ = src;
  if (src) {
    set_has_src();
  } else {
    clear_has_src();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.atoi_pol.src)
}

// required .common.action ret = 3;
inline bool atoi_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void atoi_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void atoi_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void atoi_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action atoi_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.atoi_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void atoi_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.atoi_pol.ret)
}

// -------------------------------------------------------------------

// malloc_pol

// required .common.action size = 1;
inline bool malloc_pol::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void malloc_pol::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void malloc_pol::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void malloc_pol::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::common::action malloc_pol::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.malloc_pol.size)
  return static_cast< ::common::action >(size_);
}
inline void malloc_pol::set_size(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.malloc_pol.size)
}

// required .common.action ret = 2;
inline bool malloc_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void malloc_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void malloc_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void malloc_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action malloc_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.malloc_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void malloc_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.malloc_pol.ret)
}

// -------------------------------------------------------------------

// getmodulehandle_pol

// required .common.memory_pol module_name = 1;
inline bool getmodulehandle_pol::has_module_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void getmodulehandle_pol::set_has_module_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void getmodulehandle_pol::clear_has_module_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void getmodulehandle_pol::clear_module_name() {
  if (module_name_ != NULL) module_name_->::common::memory_pol::Clear();
  clear_has_module_name();
}
inline const ::common::memory_pol& getmodulehandle_pol::module_name() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmodulehandle_pol.module_name)
  return module_name_ != NULL ? *module_name_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* getmodulehandle_pol::mutable_module_name() {
  set_has_module_name();
  if (module_name_ == NULL) {
    module_name_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmodulehandle_pol.module_name)
  return module_name_;
}
inline ::common::memory_pol* getmodulehandle_pol::release_module_name() {
  // @@protoc_insertion_point(field_release:libcall_types.getmodulehandle_pol.module_name)
  clear_has_module_name();
  ::common::memory_pol* temp = module_name_;
  module_name_ = NULL;
  return temp;
}
inline void getmodulehandle_pol::set_allocated_module_name(::common::memory_pol* module_name) {
  delete module_name_;
  module_name_ = module_name;
  if (module_name) {
    set_has_module_name();
  } else {
    clear_has_module_name();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmodulehandle_pol.module_name)
}

// required .common.action ret = 2;
inline bool getmodulehandle_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void getmodulehandle_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void getmodulehandle_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void getmodulehandle_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action getmodulehandle_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmodulehandle_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void getmodulehandle_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getmodulehandle_pol.ret)
}

// -------------------------------------------------------------------

// getprocaddress_pol

// required .common.action hmodule = 1;
inline bool getprocaddress_pol::has_hmodule() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void getprocaddress_pol::set_has_hmodule() {
  _has_bits_[0] |= 0x00000002u;
}
inline void getprocaddress_pol::clear_has_hmodule() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void getprocaddress_pol::clear_hmodule() {
  hmodule_ = 0;
  clear_has_hmodule();
}
inline ::common::action getprocaddress_pol::hmodule() const {
  // @@protoc_insertion_point(field_get:libcall_types.getprocaddress_pol.hmodule)
  return static_cast< ::common::action >(hmodule_);
}
inline void getprocaddress_pol::set_hmodule(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_hmodule();
  hmodule_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getprocaddress_pol.hmodule)
}

// required .common.memory_pol proc_name = 2;
inline bool getprocaddress_pol::has_proc_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void getprocaddress_pol::set_has_proc_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void getprocaddress_pol::clear_has_proc_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void getprocaddress_pol::clear_proc_name() {
  if (proc_name_ != NULL) proc_name_->::common::memory_pol::Clear();
  clear_has_proc_name();
}
inline const ::common::memory_pol& getprocaddress_pol::proc_name() const {
  // @@protoc_insertion_point(field_get:libcall_types.getprocaddress_pol.proc_name)
  return proc_name_ != NULL ? *proc_name_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* getprocaddress_pol::mutable_proc_name() {
  set_has_proc_name();
  if (proc_name_ == NULL) {
    proc_name_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getprocaddress_pol.proc_name)
  return proc_name_;
}
inline ::common::memory_pol* getprocaddress_pol::release_proc_name() {
  // @@protoc_insertion_point(field_release:libcall_types.getprocaddress_pol.proc_name)
  clear_has_proc_name();
  ::common::memory_pol* temp = proc_name_;
  proc_name_ = NULL;
  return temp;
}
inline void getprocaddress_pol::set_allocated_proc_name(::common::memory_pol* proc_name) {
  delete proc_name_;
  proc_name_ = proc_name;
  if (proc_name) {
    set_has_proc_name();
  } else {
    clear_has_proc_name();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getprocaddress_pol.proc_name)
}

// required .common.action ret = 3;
inline bool getprocaddress_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void getprocaddress_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void getprocaddress_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void getprocaddress_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action getprocaddress_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.getprocaddress_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void getprocaddress_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getprocaddress_pol.ret)
}

// -------------------------------------------------------------------

// getmainargs_pol

// required .common.memory_pol argc = 1;
inline bool getmainargs_pol::has_argc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void getmainargs_pol::set_has_argc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void getmainargs_pol::clear_has_argc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void getmainargs_pol::clear_argc() {
  if (argc_ != NULL) argc_->::common::memory_pol::Clear();
  clear_has_argc();
}
inline const ::common::memory_pol& getmainargs_pol::argc() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_pol.argc)
  return argc_ != NULL ? *argc_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* getmainargs_pol::mutable_argc() {
  set_has_argc();
  if (argc_ == NULL) {
    argc_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmainargs_pol.argc)
  return argc_;
}
inline ::common::memory_pol* getmainargs_pol::release_argc() {
  // @@protoc_insertion_point(field_release:libcall_types.getmainargs_pol.argc)
  clear_has_argc();
  ::common::memory_pol* temp = argc_;
  argc_ = NULL;
  return temp;
}
inline void getmainargs_pol::set_allocated_argc(::common::memory_pol* argc) {
  delete argc_;
  argc_ = argc;
  if (argc) {
    set_has_argc();
  } else {
    clear_has_argc();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmainargs_pol.argc)
}

// required .common.memory_pol argv = 2;
inline bool getmainargs_pol::has_argv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void getmainargs_pol::set_has_argv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void getmainargs_pol::clear_has_argv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void getmainargs_pol::clear_argv() {
  if (argv_ != NULL) argv_->::common::memory_pol::Clear();
  clear_has_argv();
}
inline const ::common::memory_pol& getmainargs_pol::argv() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_pol.argv)
  return argv_ != NULL ? *argv_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* getmainargs_pol::mutable_argv() {
  set_has_argv();
  if (argv_ == NULL) {
    argv_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmainargs_pol.argv)
  return argv_;
}
inline ::common::memory_pol* getmainargs_pol::release_argv() {
  // @@protoc_insertion_point(field_release:libcall_types.getmainargs_pol.argv)
  clear_has_argv();
  ::common::memory_pol* temp = argv_;
  argv_ = NULL;
  return temp;
}
inline void getmainargs_pol::set_allocated_argv(::common::memory_pol* argv) {
  delete argv_;
  argv_ = argv;
  if (argv) {
    set_has_argv();
  } else {
    clear_has_argv();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmainargs_pol.argv)
}

// required .common.memory_pol env = 3;
inline bool getmainargs_pol::has_env() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void getmainargs_pol::set_has_env() {
  _has_bits_[0] |= 0x00000004u;
}
inline void getmainargs_pol::clear_has_env() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void getmainargs_pol::clear_env() {
  if (env_ != NULL) env_->::common::memory_pol::Clear();
  clear_has_env();
}
inline const ::common::memory_pol& getmainargs_pol::env() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_pol.env)
  return env_ != NULL ? *env_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* getmainargs_pol::mutable_env() {
  set_has_env();
  if (env_ == NULL) {
    env_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmainargs_pol.env)
  return env_;
}
inline ::common::memory_pol* getmainargs_pol::release_env() {
  // @@protoc_insertion_point(field_release:libcall_types.getmainargs_pol.env)
  clear_has_env();
  ::common::memory_pol* temp = env_;
  env_ = NULL;
  return temp;
}
inline void getmainargs_pol::set_allocated_env(::common::memory_pol* env) {
  delete env_;
  env_ = env;
  if (env) {
    set_has_env();
  } else {
    clear_has_env();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmainargs_pol.env)
}

// required .common.action dowildcard = 4;
inline bool getmainargs_pol::has_dowildcard() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void getmainargs_pol::set_has_dowildcard() {
  _has_bits_[0] |= 0x00000010u;
}
inline void getmainargs_pol::clear_has_dowildcard() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void getmainargs_pol::clear_dowildcard() {
  dowildcard_ = 0;
  clear_has_dowildcard();
}
inline ::common::action getmainargs_pol::dowildcard() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_pol.dowildcard)
  return static_cast< ::common::action >(dowildcard_);
}
inline void getmainargs_pol::set_dowildcard(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_dowildcard();
  dowildcard_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getmainargs_pol.dowildcard)
}

// required .common.memory_pol startinfo = 5;
inline bool getmainargs_pol::has_startinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void getmainargs_pol::set_has_startinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void getmainargs_pol::clear_has_startinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void getmainargs_pol::clear_startinfo() {
  if (startinfo_ != NULL) startinfo_->::common::memory_pol::Clear();
  clear_has_startinfo();
}
inline const ::common::memory_pol& getmainargs_pol::startinfo() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_pol.startinfo)
  return startinfo_ != NULL ? *startinfo_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* getmainargs_pol::mutable_startinfo() {
  set_has_startinfo();
  if (startinfo_ == NULL) {
    startinfo_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmainargs_pol.startinfo)
  return startinfo_;
}
inline ::common::memory_pol* getmainargs_pol::release_startinfo() {
  // @@protoc_insertion_point(field_release:libcall_types.getmainargs_pol.startinfo)
  clear_has_startinfo();
  ::common::memory_pol* temp = startinfo_;
  startinfo_ = NULL;
  return temp;
}
inline void getmainargs_pol::set_allocated_startinfo(::common::memory_pol* startinfo) {
  delete startinfo_;
  startinfo_ = startinfo;
  if (startinfo) {
    set_has_startinfo();
  } else {
    clear_has_startinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmainargs_pol.startinfo)
}

// required .common.action ret = 6;
inline bool getmainargs_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void getmainargs_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000020u;
}
inline void getmainargs_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void getmainargs_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action getmainargs_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void getmainargs_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getmainargs_pol.ret)
}

// -------------------------------------------------------------------

// gethostname_pol

// required .common.memory_pol name = 1;
inline bool gethostname_pol::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gethostname_pol::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gethostname_pol::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gethostname_pol::clear_name() {
  if (name_ != NULL) name_->::common::memory_pol::Clear();
  clear_has_name();
}
inline const ::common::memory_pol& gethostname_pol::name() const {
  // @@protoc_insertion_point(field_get:libcall_types.gethostname_pol.name)
  return name_ != NULL ? *name_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* gethostname_pol::mutable_name() {
  set_has_name();
  if (name_ == NULL) {
    name_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.gethostname_pol.name)
  return name_;
}
inline ::common::memory_pol* gethostname_pol::release_name() {
  // @@protoc_insertion_point(field_release:libcall_types.gethostname_pol.name)
  clear_has_name();
  ::common::memory_pol* temp = name_;
  name_ = NULL;
  return temp;
}
inline void gethostname_pol::set_allocated_name(::common::memory_pol* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.gethostname_pol.name)
}

// required .common.action namelen = 2;
inline bool gethostname_pol::has_namelen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gethostname_pol::set_has_namelen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gethostname_pol::clear_has_namelen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gethostname_pol::clear_namelen() {
  namelen_ = 0;
  clear_has_namelen();
}
inline ::common::action gethostname_pol::namelen() const {
  // @@protoc_insertion_point(field_get:libcall_types.gethostname_pol.namelen)
  return static_cast< ::common::action >(namelen_);
}
inline void gethostname_pol::set_namelen(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_namelen();
  namelen_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.gethostname_pol.namelen)
}

// required .common.action ret = 3;
inline bool gethostname_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gethostname_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gethostname_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gethostname_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action gethostname_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.gethostname_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void gethostname_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.gethostname_pol.ret)
}

// -------------------------------------------------------------------

// free_pol

// required .common.action ptr = 1;
inline bool free_pol::has_ptr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void free_pol::set_has_ptr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void free_pol::clear_has_ptr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void free_pol::clear_ptr() {
  ptr_ = 0;
  clear_has_ptr();
}
inline ::common::action free_pol::ptr() const {
  // @@protoc_insertion_point(field_get:libcall_types.free_pol.ptr)
  return static_cast< ::common::action >(ptr_);
}
inline void free_pol::set_ptr(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ptr();
  ptr_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.free_pol.ptr)
}

// -------------------------------------------------------------------

// memcpy_pol

// required .common.memory_pol dest = 1;
inline bool memcpy_pol::has_dest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void memcpy_pol::set_has_dest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void memcpy_pol::clear_has_dest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void memcpy_pol::clear_dest() {
  if (dest_ != NULL) dest_->::common::memory_pol::Clear();
  clear_has_dest();
}
inline const ::common::memory_pol& memcpy_pol::dest() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcpy_pol.dest)
  return dest_ != NULL ? *dest_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* memcpy_pol::mutable_dest() {
  set_has_dest();
  if (dest_ == NULL) {
    dest_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.memcpy_pol.dest)
  return dest_;
}
inline ::common::memory_pol* memcpy_pol::release_dest() {
  // @@protoc_insertion_point(field_release:libcall_types.memcpy_pol.dest)
  clear_has_dest();
  ::common::memory_pol* temp = dest_;
  dest_ = NULL;
  return temp;
}
inline void memcpy_pol::set_allocated_dest(::common::memory_pol* dest) {
  delete dest_;
  dest_ = dest;
  if (dest) {
    set_has_dest();
  } else {
    clear_has_dest();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.memcpy_pol.dest)
}

// required .common.memory_pol src = 2;
inline bool memcpy_pol::has_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void memcpy_pol::set_has_src() {
  _has_bits_[0] |= 0x00000002u;
}
inline void memcpy_pol::clear_has_src() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void memcpy_pol::clear_src() {
  if (src_ != NULL) src_->::common::memory_pol::Clear();
  clear_has_src();
}
inline const ::common::memory_pol& memcpy_pol::src() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcpy_pol.src)
  return src_ != NULL ? *src_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* memcpy_pol::mutable_src() {
  set_has_src();
  if (src_ == NULL) {
    src_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.memcpy_pol.src)
  return src_;
}
inline ::common::memory_pol* memcpy_pol::release_src() {
  // @@protoc_insertion_point(field_release:libcall_types.memcpy_pol.src)
  clear_has_src();
  ::common::memory_pol* temp = src_;
  src_ = NULL;
  return temp;
}
inline void memcpy_pol::set_allocated_src(::common::memory_pol* src) {
  delete src_;
  src_ = src;
  if (src) {
    set_has_src();
  } else {
    clear_has_src();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.memcpy_pol.src)
}

// required .common.action size = 3;
inline bool memcpy_pol::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void memcpy_pol::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void memcpy_pol::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void memcpy_pol::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::common::action memcpy_pol::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcpy_pol.size)
  return static_cast< ::common::action >(size_);
}
inline void memcpy_pol::set_size(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcpy_pol.size)
}

// required .common.action ret = 4;
inline bool memcpy_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void memcpy_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void memcpy_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void memcpy_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action memcpy_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcpy_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void memcpy_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcpy_pol.ret)
}

// -------------------------------------------------------------------

// memset_pol

// required .common.memory_pol s = 1;
inline bool memset_pol::has_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void memset_pol::set_has_s() {
  _has_bits_[0] |= 0x00000001u;
}
inline void memset_pol::clear_has_s() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void memset_pol::clear_s() {
  if (s_ != NULL) s_->::common::memory_pol::Clear();
  clear_has_s();
}
inline const ::common::memory_pol& memset_pol::s() const {
  // @@protoc_insertion_point(field_get:libcall_types.memset_pol.s)
  return s_ != NULL ? *s_
                         : *::common::memory_pol::internal_default_instance();
}
inline ::common::memory_pol* memset_pol::mutable_s() {
  set_has_s();
  if (s_ == NULL) {
    s_ = new ::common::memory_pol;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.memset_pol.s)
  return s_;
}
inline ::common::memory_pol* memset_pol::release_s() {
  // @@protoc_insertion_point(field_release:libcall_types.memset_pol.s)
  clear_has_s();
  ::common::memory_pol* temp = s_;
  s_ = NULL;
  return temp;
}
inline void memset_pol::set_allocated_s(::common::memory_pol* s) {
  delete s_;
  s_ = s;
  if (s) {
    set_has_s();
  } else {
    clear_has_s();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.memset_pol.s)
}

// required .common.action c = 2;
inline bool memset_pol::has_c() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void memset_pol::set_has_c() {
  _has_bits_[0] |= 0x00000002u;
}
inline void memset_pol::clear_has_c() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void memset_pol::clear_c() {
  c_ = 0;
  clear_has_c();
}
inline ::common::action memset_pol::c() const {
  // @@protoc_insertion_point(field_get:libcall_types.memset_pol.c)
  return static_cast< ::common::action >(c_);
}
inline void memset_pol::set_c(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_c();
  c_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memset_pol.c)
}

// required .common.action size = 3;
inline bool memset_pol::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void memset_pol::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void memset_pol::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void memset_pol::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::common::action memset_pol::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.memset_pol.size)
  return static_cast< ::common::action >(size_);
}
inline void memset_pol::set_size(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memset_pol.size)
}

// required .common.action ret = 4;
inline bool memset_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void memset_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void memset_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void memset_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action memset_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.memset_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void memset_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memset_pol.ret)
}

// -------------------------------------------------------------------

// fgetc_pol

// required .common.action stream = 1;
inline bool fgetc_pol::has_stream() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fgetc_pol::set_has_stream() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fgetc_pol::clear_has_stream() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fgetc_pol::clear_stream() {
  stream_ = 0;
  clear_has_stream();
}
inline ::common::action fgetc_pol::stream() const {
  // @@protoc_insertion_point(field_get:libcall_types.fgetc_pol.stream)
  return static_cast< ::common::action >(stream_);
}
inline void fgetc_pol::set_stream(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_stream();
  stream_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fgetc_pol.stream)
}

// required .common.action ret = 2;
inline bool fgetc_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fgetc_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fgetc_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fgetc_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action fgetc_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.fgetc_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void fgetc_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fgetc_pol.ret)
}

// -------------------------------------------------------------------

// lseek_pol

// required .common.action fd = 1;
inline bool lseek_pol::has_fd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lseek_pol::set_has_fd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lseek_pol::clear_has_fd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lseek_pol::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::common::action lseek_pol::fd() const {
  // @@protoc_insertion_point(field_get:libcall_types.lseek_pol.fd)
  return static_cast< ::common::action >(fd_);
}
inline void lseek_pol::set_fd(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_fd();
  fd_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.lseek_pol.fd)
}

// required .common.action offset = 2;
inline bool lseek_pol::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lseek_pol::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lseek_pol::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lseek_pol::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::common::action lseek_pol::offset() const {
  // @@protoc_insertion_point(field_get:libcall_types.lseek_pol.offset)
  return static_cast< ::common::action >(offset_);
}
inline void lseek_pol::set_offset(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.lseek_pol.offset)
}

// required .common.action whence = 3;
inline bool lseek_pol::has_whence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lseek_pol::set_has_whence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lseek_pol::clear_has_whence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lseek_pol::clear_whence() {
  whence_ = 0;
  clear_has_whence();
}
inline ::common::action lseek_pol::whence() const {
  // @@protoc_insertion_point(field_get:libcall_types.lseek_pol.whence)
  return static_cast< ::common::action >(whence_);
}
inline void lseek_pol::set_whence(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_whence();
  whence_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.lseek_pol.whence)
}

// required .common.action ret = 4;
inline bool lseek_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lseek_pol::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void lseek_pol::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void lseek_pol::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::common::action lseek_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.lseek_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void lseek_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.lseek_pol.ret)
}

// -------------------------------------------------------------------

// exit_t

// -------------------------------------------------------------------

// generic_t

// required uint64 ret = 1;
inline bool generic_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void generic_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void generic_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void generic_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 generic_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.generic_t.ret)
  return ret_;
}
inline void generic_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.generic_t.ret)
}

// -------------------------------------------------------------------

// fscanf_elem_t

// required .libcall_types.fscanf_enum type = 1;
inline bool fscanf_elem_t::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fscanf_elem_t::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fscanf_elem_t::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fscanf_elem_t::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::libcall_types::fscanf_enum fscanf_elem_t::type() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_elem_t.type)
  return static_cast< ::libcall_types::fscanf_enum >(type_);
}
inline void fscanf_elem_t::set_type(::libcall_types::fscanf_enum value) {
  assert(::libcall_types::fscanf_enum_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_elem_t.type)
}

// required uint64 addr = 2;
inline bool fscanf_elem_t::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fscanf_elem_t::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fscanf_elem_t::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fscanf_elem_t::clear_addr() {
  addr_ = GOOGLE_ULONGLONG(0);
  clear_has_addr();
}
inline ::google::protobuf::uint64 fscanf_elem_t::addr() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_elem_t.addr)
  return addr_;
}
inline void fscanf_elem_t::set_addr(::google::protobuf::uint64 value) {
  set_has_addr();
  addr_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_elem_t.addr)
}

// optional uint64 value_dec = 3;
inline bool fscanf_elem_t::has_value_dec() const {
  return fscanf_cnt_case() == kValueDec;
}
inline void fscanf_elem_t::set_has_value_dec() {
  _oneof_case_[0] = kValueDec;
}
inline void fscanf_elem_t::clear_value_dec() {
  if (has_value_dec()) {
    fscanf_cnt_.value_dec_ = GOOGLE_ULONGLONG(0);
    clear_has_fscanf_cnt();
  }
}
inline ::google::protobuf::uint64 fscanf_elem_t::value_dec() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_elem_t.value_dec)
  if (has_value_dec()) {
    return fscanf_cnt_.value_dec_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void fscanf_elem_t::set_value_dec(::google::protobuf::uint64 value) {
  if (!has_value_dec()) {
    clear_fscanf_cnt();
    set_has_value_dec();
  }
  fscanf_cnt_.value_dec_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_elem_t.value_dec)
}

// optional string value_string = 4;
inline bool fscanf_elem_t::has_value_string() const {
  return fscanf_cnt_case() == kValueString;
}
inline void fscanf_elem_t::set_has_value_string() {
  _oneof_case_[0] = kValueString;
}
inline void fscanf_elem_t::clear_value_string() {
  if (has_value_string()) {
    fscanf_cnt_.value_string_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_fscanf_cnt();
  }
}
inline const ::std::string& fscanf_elem_t::value_string() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_elem_t.value_string)
  if (has_value_string()) {
    return fscanf_cnt_.value_string_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void fscanf_elem_t::set_value_string(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_elem_t.value_string)
  if (!has_value_string()) {
    clear_fscanf_cnt();
    set_has_value_string();
    fscanf_cnt_.value_string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  fscanf_cnt_.value_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_elem_t.value_string)
}
#if LANG_CXX11
inline void fscanf_elem_t::set_value_string(::std::string&& value) {
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_elem_t.value_string)
  if (!has_value_string()) {
    clear_fscanf_cnt();
    set_has_value_string();
    fscanf_cnt_.value_string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  fscanf_cnt_.value_string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:libcall_types.fscanf_elem_t.value_string)
}
#endif
inline void fscanf_elem_t::set_value_string(const char* value) {
  if (!has_value_string()) {
    clear_fscanf_cnt();
    set_has_value_string();
    fscanf_cnt_.value_string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  fscanf_cnt_.value_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libcall_types.fscanf_elem_t.value_string)
}
inline void fscanf_elem_t::set_value_string(const char* value, size_t size) {
  if (!has_value_string()) {
    clear_fscanf_cnt();
    set_has_value_string();
    fscanf_cnt_.value_string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  fscanf_cnt_.value_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libcall_types.fscanf_elem_t.value_string)
}
inline ::std::string* fscanf_elem_t::mutable_value_string() {
  if (!has_value_string()) {
    clear_fscanf_cnt();
    set_has_value_string();
    fscanf_cnt_.value_string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.fscanf_elem_t.value_string)
  return fscanf_cnt_.value_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* fscanf_elem_t::release_value_string() {
  // @@protoc_insertion_point(field_release:libcall_types.fscanf_elem_t.value_string)
  if (has_value_string()) {
    clear_has_fscanf_cnt();
    return fscanf_cnt_.value_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void fscanf_elem_t::set_allocated_value_string(::std::string* value_string) {
  if (!has_value_string()) {
    fscanf_cnt_.value_string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_fscanf_cnt();
  if (value_string != NULL) {
    set_has_value_string();
    fscanf_cnt_.value_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        value_string);
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.fscanf_elem_t.value_string)
}

inline bool fscanf_elem_t::has_fscanf_cnt() const {
  return fscanf_cnt_case() != FSCANF_CNT_NOT_SET;
}
inline void fscanf_elem_t::clear_has_fscanf_cnt() {
  _oneof_case_[0] = FSCANF_CNT_NOT_SET;
}
inline fscanf_elem_t::FscanfCntCase fscanf_elem_t::fscanf_cnt_case() const {
  return fscanf_elem_t::FscanfCntCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// fscanf_t

// required uint64 stream = 1;
inline bool fscanf_t::has_stream() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fscanf_t::set_has_stream() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fscanf_t::clear_has_stream() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fscanf_t::clear_stream() {
  stream_ = GOOGLE_ULONGLONG(0);
  clear_has_stream();
}
inline ::google::protobuf::uint64 fscanf_t::stream() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_t.stream)
  return stream_;
}
inline void fscanf_t::set_stream(::google::protobuf::uint64 value) {
  set_has_stream();
  stream_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_t.stream)
}

// repeated .libcall_types.fscanf_elem_t elems = 2;
inline int fscanf_t::elems_size() const {
  return elems_.size();
}
inline void fscanf_t::clear_elems() {
  elems_.Clear();
}
inline const ::libcall_types::fscanf_elem_t& fscanf_t::elems(int index) const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_t.elems)
  return elems_.Get(index);
}
inline ::libcall_types::fscanf_elem_t* fscanf_t::mutable_elems(int index) {
  // @@protoc_insertion_point(field_mutable:libcall_types.fscanf_t.elems)
  return elems_.Mutable(index);
}
inline ::libcall_types::fscanf_elem_t* fscanf_t::add_elems() {
  // @@protoc_insertion_point(field_add:libcall_types.fscanf_t.elems)
  return elems_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::libcall_types::fscanf_elem_t >*
fscanf_t::mutable_elems() {
  // @@protoc_insertion_point(field_mutable_list:libcall_types.fscanf_t.elems)
  return &elems_;
}
inline const ::google::protobuf::RepeatedPtrField< ::libcall_types::fscanf_elem_t >&
fscanf_t::elems() const {
  // @@protoc_insertion_point(field_list:libcall_types.fscanf_t.elems)
  return elems_;
}

// required uint64 ret = 3;
inline bool fscanf_t::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fscanf_t::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fscanf_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fscanf_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 fscanf_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_t.ret)
  return ret_;
}
inline void fscanf_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_t.ret)
}

// -------------------------------------------------------------------

// ctype_b_loc_t

// required .common.memory_t table = 1;
inline bool ctype_b_loc_t::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ctype_b_loc_t::set_has_table() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ctype_b_loc_t::clear_has_table() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ctype_b_loc_t::clear_table() {
  if (table_ != NULL) table_->::common::memory_t::Clear();
  clear_has_table();
}
inline const ::common::memory_t& ctype_b_loc_t::table() const {
  // @@protoc_insertion_point(field_get:libcall_types.ctype_b_loc_t.table)
  return table_ != NULL ? *table_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* ctype_b_loc_t::mutable_table() {
  set_has_table();
  if (table_ == NULL) {
    table_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.ctype_b_loc_t.table)
  return table_;
}
inline ::common::memory_t* ctype_b_loc_t::release_table() {
  // @@protoc_insertion_point(field_release:libcall_types.ctype_b_loc_t.table)
  clear_has_table();
  ::common::memory_t* temp = table_;
  table_ = NULL;
  return temp;
}
inline void ctype_b_loc_t::set_allocated_table(::common::memory_t* table) {
  delete table_;
  table_ = table;
  if (table) {
    set_has_table();
  } else {
    clear_has_table();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.ctype_b_loc_t.table)
}

// required uint64 ret = 2;
inline bool ctype_b_loc_t::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ctype_b_loc_t::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ctype_b_loc_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ctype_b_loc_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 ctype_b_loc_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.ctype_b_loc_t.ret)
  return ret_;
}
inline void ctype_b_loc_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.ctype_b_loc_t.ret)
}

// -------------------------------------------------------------------

// read_t

// required uint64 fd = 1;
inline bool read_t::has_fd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void read_t::set_has_fd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void read_t::clear_has_fd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void read_t::clear_fd() {
  fd_ = GOOGLE_ULONGLONG(0);
  clear_has_fd();
}
inline ::google::protobuf::uint64 read_t::fd() const {
  // @@protoc_insertion_point(field_get:libcall_types.read_t.fd)
  return fd_;
}
inline void read_t::set_fd(::google::protobuf::uint64 value) {
  set_has_fd();
  fd_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.read_t.fd)
}

// required .common.memory_t buf = 2;
inline bool read_t::has_buf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void read_t::set_has_buf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void read_t::clear_has_buf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void read_t::clear_buf() {
  if (buf_ != NULL) buf_->::common::memory_t::Clear();
  clear_has_buf();
}
inline const ::common::memory_t& read_t::buf() const {
  // @@protoc_insertion_point(field_get:libcall_types.read_t.buf)
  return buf_ != NULL ? *buf_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* read_t::mutable_buf() {
  set_has_buf();
  if (buf_ == NULL) {
    buf_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.read_t.buf)
  return buf_;
}
inline ::common::memory_t* read_t::release_buf() {
  // @@protoc_insertion_point(field_release:libcall_types.read_t.buf)
  clear_has_buf();
  ::common::memory_t* temp = buf_;
  buf_ = NULL;
  return temp;
}
inline void read_t::set_allocated_buf(::common::memory_t* buf) {
  delete buf_;
  buf_ = buf;
  if (buf) {
    set_has_buf();
  } else {
    clear_has_buf();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.read_t.buf)
}

// required uint64 count = 3;
inline bool read_t::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void read_t::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void read_t::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void read_t::clear_count() {
  count_ = GOOGLE_ULONGLONG(0);
  clear_has_count();
}
inline ::google::protobuf::uint64 read_t::count() const {
  // @@protoc_insertion_point(field_get:libcall_types.read_t.count)
  return count_;
}
inline void read_t::set_count(::google::protobuf::uint64 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.read_t.count)
}

// required uint64 ret = 4;
inline bool read_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void read_t::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void read_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void read_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 read_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.read_t.ret)
  return ret_;
}
inline void read_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.read_t.ret)
}

// -------------------------------------------------------------------

// fread_t

// required .common.memory_t ptr = 1;
inline bool fread_t::has_ptr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fread_t::set_has_ptr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fread_t::clear_has_ptr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fread_t::clear_ptr() {
  if (ptr_ != NULL) ptr_->::common::memory_t::Clear();
  clear_has_ptr();
}
inline const ::common::memory_t& fread_t::ptr() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_t.ptr)
  return ptr_ != NULL ? *ptr_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* fread_t::mutable_ptr() {
  set_has_ptr();
  if (ptr_ == NULL) {
    ptr_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.fread_t.ptr)
  return ptr_;
}
inline ::common::memory_t* fread_t::release_ptr() {
  // @@protoc_insertion_point(field_release:libcall_types.fread_t.ptr)
  clear_has_ptr();
  ::common::memory_t* temp = ptr_;
  ptr_ = NULL;
  return temp;
}
inline void fread_t::set_allocated_ptr(::common::memory_t* ptr) {
  delete ptr_;
  ptr_ = ptr;
  if (ptr) {
    set_has_ptr();
  } else {
    clear_has_ptr();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.fread_t.ptr)
}

// required uint64 size = 2;
inline bool fread_t::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fread_t::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fread_t::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fread_t::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 fread_t::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_t.size)
  return size_;
}
inline void fread_t::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fread_t.size)
}

// required uint64 nmemb = 3;
inline bool fread_t::has_nmemb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fread_t::set_has_nmemb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fread_t::clear_has_nmemb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fread_t::clear_nmemb() {
  nmemb_ = GOOGLE_ULONGLONG(0);
  clear_has_nmemb();
}
inline ::google::protobuf::uint64 fread_t::nmemb() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_t.nmemb)
  return nmemb_;
}
inline void fread_t::set_nmemb(::google::protobuf::uint64 value) {
  set_has_nmemb();
  nmemb_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fread_t.nmemb)
}

// required uint64 stream = 4;
inline bool fread_t::has_stream() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fread_t::set_has_stream() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fread_t::clear_has_stream() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fread_t::clear_stream() {
  stream_ = GOOGLE_ULONGLONG(0);
  clear_has_stream();
}
inline ::google::protobuf::uint64 fread_t::stream() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_t.stream)
  return stream_;
}
inline void fread_t::set_stream(::google::protobuf::uint64 value) {
  set_has_stream();
  stream_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fread_t.stream)
}

// required uint64 ret = 5;
inline bool fread_t::has_ret() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fread_t::set_has_ret() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fread_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fread_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 fread_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_t.ret)
  return ret_;
}
inline void fread_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fread_t.ret)
}

// -------------------------------------------------------------------

// strchr_t

// required uint64 s = 1;
inline bool strchr_t::has_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void strchr_t::set_has_s() {
  _has_bits_[0] |= 0x00000001u;
}
inline void strchr_t::clear_has_s() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void strchr_t::clear_s() {
  s_ = GOOGLE_ULONGLONG(0);
  clear_has_s();
}
inline ::google::protobuf::uint64 strchr_t::s() const {
  // @@protoc_insertion_point(field_get:libcall_types.strchr_t.s)
  return s_;
}
inline void strchr_t::set_s(::google::protobuf::uint64 value) {
  set_has_s();
  s_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strchr_t.s)
}

// required uint64 c = 2;
inline bool strchr_t::has_c() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void strchr_t::set_has_c() {
  _has_bits_[0] |= 0x00000002u;
}
inline void strchr_t::clear_has_c() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void strchr_t::clear_c() {
  c_ = GOOGLE_ULONGLONG(0);
  clear_has_c();
}
inline ::google::protobuf::uint64 strchr_t::c() const {
  // @@protoc_insertion_point(field_get:libcall_types.strchr_t.c)
  return c_;
}
inline void strchr_t::set_c(::google::protobuf::uint64 value) {
  set_has_c();
  c_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strchr_t.c)
}

// required uint64 size_max = 3;
inline bool strchr_t::has_size_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strchr_t::set_has_size_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void strchr_t::clear_has_size_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void strchr_t::clear_size_max() {
  size_max_ = GOOGLE_ULONGLONG(0);
  clear_has_size_max();
}
inline ::google::protobuf::uint64 strchr_t::size_max() const {
  // @@protoc_insertion_point(field_get:libcall_types.strchr_t.size_max)
  return size_max_;
}
inline void strchr_t::set_size_max(::google::protobuf::uint64 value) {
  set_has_size_max();
  size_max_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strchr_t.size_max)
}

// required uint64 ret = 4;
inline bool strchr_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void strchr_t::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void strchr_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void strchr_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 strchr_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strchr_t.ret)
  return ret_;
}
inline void strchr_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strchr_t.ret)
}

// -------------------------------------------------------------------

// strncpy_t

// required uint64 dst = 1;
inline bool strncpy_t::has_dst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void strncpy_t::set_has_dst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void strncpy_t::clear_has_dst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void strncpy_t::clear_dst() {
  dst_ = GOOGLE_ULONGLONG(0);
  clear_has_dst();
}
inline ::google::protobuf::uint64 strncpy_t::dst() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncpy_t.dst)
  return dst_;
}
inline void strncpy_t::set_dst(::google::protobuf::uint64 value) {
  set_has_dst();
  dst_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncpy_t.dst)
}

// required uint64 src = 2;
inline bool strncpy_t::has_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void strncpy_t::set_has_src() {
  _has_bits_[0] |= 0x00000002u;
}
inline void strncpy_t::clear_has_src() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void strncpy_t::clear_src() {
  src_ = GOOGLE_ULONGLONG(0);
  clear_has_src();
}
inline ::google::protobuf::uint64 strncpy_t::src() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncpy_t.src)
  return src_;
}
inline void strncpy_t::set_src(::google::protobuf::uint64 value) {
  set_has_src();
  src_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncpy_t.src)
}

// required uint64 n = 3;
inline bool strncpy_t::has_n() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strncpy_t::set_has_n() {
  _has_bits_[0] |= 0x00000004u;
}
inline void strncpy_t::clear_has_n() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void strncpy_t::clear_n() {
  n_ = GOOGLE_ULONGLONG(0);
  clear_has_n();
}
inline ::google::protobuf::uint64 strncpy_t::n() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncpy_t.n)
  return n_;
}
inline void strncpy_t::set_n(::google::protobuf::uint64 value) {
  set_has_n();
  n_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncpy_t.n)
}

// required uint64 ret = 4;
inline bool strncpy_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void strncpy_t::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void strncpy_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void strncpy_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 strncpy_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncpy_t.ret)
  return ret_;
}
inline void strncpy_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncpy_t.ret)
}

// -------------------------------------------------------------------

// fstat_t

// required uint64 fd = 1;
inline bool fstat_t::has_fd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fstat_t::set_has_fd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fstat_t::clear_has_fd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fstat_t::clear_fd() {
  fd_ = GOOGLE_ULONGLONG(0);
  clear_has_fd();
}
inline ::google::protobuf::uint64 fstat_t::fd() const {
  // @@protoc_insertion_point(field_get:libcall_types.fstat_t.fd)
  return fd_;
}
inline void fstat_t::set_fd(::google::protobuf::uint64 value) {
  set_has_fd();
  fd_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fstat_t.fd)
}

// required .common.memory_t buf = 2;
inline bool fstat_t::has_buf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fstat_t::set_has_buf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fstat_t::clear_has_buf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fstat_t::clear_buf() {
  if (buf_ != NULL) buf_->::common::memory_t::Clear();
  clear_has_buf();
}
inline const ::common::memory_t& fstat_t::buf() const {
  // @@protoc_insertion_point(field_get:libcall_types.fstat_t.buf)
  return buf_ != NULL ? *buf_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* fstat_t::mutable_buf() {
  set_has_buf();
  if (buf_ == NULL) {
    buf_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.fstat_t.buf)
  return buf_;
}
inline ::common::memory_t* fstat_t::release_buf() {
  // @@protoc_insertion_point(field_release:libcall_types.fstat_t.buf)
  clear_has_buf();
  ::common::memory_t* temp = buf_;
  buf_ = NULL;
  return temp;
}
inline void fstat_t::set_allocated_buf(::common::memory_t* buf) {
  delete buf_;
  buf_ = buf;
  if (buf) {
    set_has_buf();
  } else {
    clear_has_buf();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.fstat_t.buf)
}

// required uint64 ret = 3;
inline bool fstat_t::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fstat_t::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fstat_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fstat_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 fstat_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.fstat_t.ret)
  return ret_;
}
inline void fstat_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fstat_t.ret)
}

// -------------------------------------------------------------------

// fxstat64_t

// required uint64 vers = 1;
inline bool fxstat64_t::has_vers() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fxstat64_t::set_has_vers() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fxstat64_t::clear_has_vers() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fxstat64_t::clear_vers() {
  vers_ = GOOGLE_ULONGLONG(0);
  clear_has_vers();
}
inline ::google::protobuf::uint64 fxstat64_t::vers() const {
  // @@protoc_insertion_point(field_get:libcall_types.fxstat64_t.vers)
  return vers_;
}
inline void fxstat64_t::set_vers(::google::protobuf::uint64 value) {
  set_has_vers();
  vers_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fxstat64_t.vers)
}

// required uint64 fd = 2;
inline bool fxstat64_t::has_fd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fxstat64_t::set_has_fd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fxstat64_t::clear_has_fd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fxstat64_t::clear_fd() {
  fd_ = GOOGLE_ULONGLONG(0);
  clear_has_fd();
}
inline ::google::protobuf::uint64 fxstat64_t::fd() const {
  // @@protoc_insertion_point(field_get:libcall_types.fxstat64_t.fd)
  return fd_;
}
inline void fxstat64_t::set_fd(::google::protobuf::uint64 value) {
  set_has_fd();
  fd_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fxstat64_t.fd)
}

// required .common.memory_t buf = 3;
inline bool fxstat64_t::has_buf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fxstat64_t::set_has_buf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fxstat64_t::clear_has_buf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fxstat64_t::clear_buf() {
  if (buf_ != NULL) buf_->::common::memory_t::Clear();
  clear_has_buf();
}
inline const ::common::memory_t& fxstat64_t::buf() const {
  // @@protoc_insertion_point(field_get:libcall_types.fxstat64_t.buf)
  return buf_ != NULL ? *buf_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* fxstat64_t::mutable_buf() {
  set_has_buf();
  if (buf_ == NULL) {
    buf_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.fxstat64_t.buf)
  return buf_;
}
inline ::common::memory_t* fxstat64_t::release_buf() {
  // @@protoc_insertion_point(field_release:libcall_types.fxstat64_t.buf)
  clear_has_buf();
  ::common::memory_t* temp = buf_;
  buf_ = NULL;
  return temp;
}
inline void fxstat64_t::set_allocated_buf(::common::memory_t* buf) {
  delete buf_;
  buf_ = buf;
  if (buf) {
    set_has_buf();
  } else {
    clear_has_buf();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.fxstat64_t.buf)
}

// required uint64 ret = 4;
inline bool fxstat64_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fxstat64_t::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fxstat64_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fxstat64_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 fxstat64_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.fxstat64_t.ret)
  return ret_;
}
inline void fxstat64_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fxstat64_t.ret)
}

// -------------------------------------------------------------------

// realloc_t

// required uint64 ptr = 1;
inline bool realloc_t::has_ptr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void realloc_t::set_has_ptr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void realloc_t::clear_has_ptr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void realloc_t::clear_ptr() {
  ptr_ = GOOGLE_ULONGLONG(0);
  clear_has_ptr();
}
inline ::google::protobuf::uint64 realloc_t::ptr() const {
  // @@protoc_insertion_point(field_get:libcall_types.realloc_t.ptr)
  return ptr_;
}
inline void realloc_t::set_ptr(::google::protobuf::uint64 value) {
  set_has_ptr();
  ptr_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.realloc_t.ptr)
}

// required uint64 size = 2;
inline bool realloc_t::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void realloc_t::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void realloc_t::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void realloc_t::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 realloc_t::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.realloc_t.size)
  return size_;
}
inline void realloc_t::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.realloc_t.size)
}

// required uint64 ret = 3;
inline bool realloc_t::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void realloc_t::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void realloc_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void realloc_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 realloc_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.realloc_t.ret)
  return ret_;
}
inline void realloc_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.realloc_t.ret)
}

// -------------------------------------------------------------------

// mmap_t

// required uint64 addr = 1;
inline bool mmap_t::has_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mmap_t::set_has_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mmap_t::clear_has_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mmap_t::clear_addr() {
  addr_ = GOOGLE_ULONGLONG(0);
  clear_has_addr();
}
inline ::google::protobuf::uint64 mmap_t::addr() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_t.addr)
  return addr_;
}
inline void mmap_t::set_addr(::google::protobuf::uint64 value) {
  set_has_addr();
  addr_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_t.addr)
}

// required uint64 length = 2;
inline bool mmap_t::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mmap_t::set_has_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mmap_t::clear_has_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mmap_t::clear_length() {
  length_ = GOOGLE_ULONGLONG(0);
  clear_has_length();
}
inline ::google::protobuf::uint64 mmap_t::length() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_t.length)
  return length_;
}
inline void mmap_t::set_length(::google::protobuf::uint64 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_t.length)
}

// required uint64 prot = 3;
inline bool mmap_t::has_prot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mmap_t::set_has_prot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mmap_t::clear_has_prot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mmap_t::clear_prot() {
  prot_ = GOOGLE_ULONGLONG(0);
  clear_has_prot();
}
inline ::google::protobuf::uint64 mmap_t::prot() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_t.prot)
  return prot_;
}
inline void mmap_t::set_prot(::google::protobuf::uint64 value) {
  set_has_prot();
  prot_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_t.prot)
}

// required uint64 flags = 4;
inline bool mmap_t::has_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mmap_t::set_has_flags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void mmap_t::clear_has_flags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void mmap_t::clear_flags() {
  flags_ = GOOGLE_ULONGLONG(0);
  clear_has_flags();
}
inline ::google::protobuf::uint64 mmap_t::flags() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_t.flags)
  return flags_;
}
inline void mmap_t::set_flags(::google::protobuf::uint64 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_t.flags)
}

// required uint64 fd = 5;
inline bool mmap_t::has_fd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void mmap_t::set_has_fd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void mmap_t::clear_has_fd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void mmap_t::clear_fd() {
  fd_ = GOOGLE_ULONGLONG(0);
  clear_has_fd();
}
inline ::google::protobuf::uint64 mmap_t::fd() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_t.fd)
  return fd_;
}
inline void mmap_t::set_fd(::google::protobuf::uint64 value) {
  set_has_fd();
  fd_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_t.fd)
}

// required uint64 offset = 6;
inline bool mmap_t::has_offset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void mmap_t::set_has_offset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void mmap_t::clear_has_offset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void mmap_t::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 mmap_t::offset() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_t.offset)
  return offset_;
}
inline void mmap_t::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_t.offset)
}

// required .common.memory_t ret = 7;
inline bool mmap_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mmap_t::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mmap_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mmap_t::clear_ret() {
  if (ret_ != NULL) ret_->::common::memory_t::Clear();
  clear_has_ret();
}
inline const ::common::memory_t& mmap_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_t.ret)
  return ret_ != NULL ? *ret_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* mmap_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) {
    ret_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.mmap_t.ret)
  return ret_;
}
inline ::common::memory_t* mmap_t::release_ret() {
  // @@protoc_insertion_point(field_release:libcall_types.mmap_t.ret)
  clear_has_ret();
  ::common::memory_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void mmap_t::set_allocated_ret(::common::memory_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.mmap_t.ret)
}

// -------------------------------------------------------------------

// qsort_t

// required .common.memory_t base = 1;
inline bool qsort_t::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void qsort_t::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void qsort_t::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void qsort_t::clear_base() {
  if (base_ != NULL) base_->::common::memory_t::Clear();
  clear_has_base();
}
inline const ::common::memory_t& qsort_t::base() const {
  // @@protoc_insertion_point(field_get:libcall_types.qsort_t.base)
  return base_ != NULL ? *base_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* qsort_t::mutable_base() {
  set_has_base();
  if (base_ == NULL) {
    base_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.qsort_t.base)
  return base_;
}
inline ::common::memory_t* qsort_t::release_base() {
  // @@protoc_insertion_point(field_release:libcall_types.qsort_t.base)
  clear_has_base();
  ::common::memory_t* temp = base_;
  base_ = NULL;
  return temp;
}
inline void qsort_t::set_allocated_base(::common::memory_t* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.qsort_t.base)
}

// required uint64 nmemb = 2;
inline bool qsort_t::has_nmemb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void qsort_t::set_has_nmemb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void qsort_t::clear_has_nmemb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void qsort_t::clear_nmemb() {
  nmemb_ = GOOGLE_ULONGLONG(0);
  clear_has_nmemb();
}
inline ::google::protobuf::uint64 qsort_t::nmemb() const {
  // @@protoc_insertion_point(field_get:libcall_types.qsort_t.nmemb)
  return nmemb_;
}
inline void qsort_t::set_nmemb(::google::protobuf::uint64 value) {
  set_has_nmemb();
  nmemb_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.qsort_t.nmemb)
}

// required uint64 size = 3;
inline bool qsort_t::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void qsort_t::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void qsort_t::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void qsort_t::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 qsort_t::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.qsort_t.size)
  return size_;
}
inline void qsort_t::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.qsort_t.size)
}

// required uint64 compare = 4;
inline bool qsort_t::has_compare() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void qsort_t::set_has_compare() {
  _has_bits_[0] |= 0x00000008u;
}
inline void qsort_t::clear_has_compare() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void qsort_t::clear_compare() {
  compare_ = GOOGLE_ULONGLONG(0);
  clear_has_compare();
}
inline ::google::protobuf::uint64 qsort_t::compare() const {
  // @@protoc_insertion_point(field_get:libcall_types.qsort_t.compare)
  return compare_;
}
inline void qsort_t::set_compare(::google::protobuf::uint64 value) {
  set_has_compare();
  compare_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.qsort_t.compare)
}

// -------------------------------------------------------------------

// bsearch_t

// required .common.memory_t key = 1;
inline bool bsearch_t::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void bsearch_t::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void bsearch_t::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void bsearch_t::clear_key() {
  if (key_ != NULL) key_->::common::memory_t::Clear();
  clear_has_key();
}
inline const ::common::memory_t& bsearch_t::key() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_t.key)
  return key_ != NULL ? *key_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* bsearch_t::mutable_key() {
  set_has_key();
  if (key_ == NULL) {
    key_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.bsearch_t.key)
  return key_;
}
inline ::common::memory_t* bsearch_t::release_key() {
  // @@protoc_insertion_point(field_release:libcall_types.bsearch_t.key)
  clear_has_key();
  ::common::memory_t* temp = key_;
  key_ = NULL;
  return temp;
}
inline void bsearch_t::set_allocated_key(::common::memory_t* key) {
  delete key_;
  key_ = key;
  if (key) {
    set_has_key();
  } else {
    clear_has_key();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.bsearch_t.key)
}

// required .common.memory_t base = 2;
inline bool bsearch_t::has_base() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void bsearch_t::set_has_base() {
  _has_bits_[0] |= 0x00000002u;
}
inline void bsearch_t::clear_has_base() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void bsearch_t::clear_base() {
  if (base_ != NULL) base_->::common::memory_t::Clear();
  clear_has_base();
}
inline const ::common::memory_t& bsearch_t::base() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_t.base)
  return base_ != NULL ? *base_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* bsearch_t::mutable_base() {
  set_has_base();
  if (base_ == NULL) {
    base_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.bsearch_t.base)
  return base_;
}
inline ::common::memory_t* bsearch_t::release_base() {
  // @@protoc_insertion_point(field_release:libcall_types.bsearch_t.base)
  clear_has_base();
  ::common::memory_t* temp = base_;
  base_ = NULL;
  return temp;
}
inline void bsearch_t::set_allocated_base(::common::memory_t* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.bsearch_t.base)
}

// required uint64 nmemb = 3;
inline bool bsearch_t::has_nmemb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void bsearch_t::set_has_nmemb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void bsearch_t::clear_has_nmemb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void bsearch_t::clear_nmemb() {
  nmemb_ = GOOGLE_ULONGLONG(0);
  clear_has_nmemb();
}
inline ::google::protobuf::uint64 bsearch_t::nmemb() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_t.nmemb)
  return nmemb_;
}
inline void bsearch_t::set_nmemb(::google::protobuf::uint64 value) {
  set_has_nmemb();
  nmemb_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.bsearch_t.nmemb)
}

// required uint64 size = 4;
inline bool bsearch_t::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void bsearch_t::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void bsearch_t::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void bsearch_t::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 bsearch_t::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_t.size)
  return size_;
}
inline void bsearch_t::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.bsearch_t.size)
}

// required uint64 compare = 5;
inline bool bsearch_t::has_compare() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void bsearch_t::set_has_compare() {
  _has_bits_[0] |= 0x00000020u;
}
inline void bsearch_t::clear_has_compare() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void bsearch_t::clear_compare() {
  compare_ = GOOGLE_ULONGLONG(0);
  clear_has_compare();
}
inline ::google::protobuf::uint64 bsearch_t::compare() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_t.compare)
  return compare_;
}
inline void bsearch_t::set_compare(::google::protobuf::uint64 value) {
  set_has_compare();
  compare_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.bsearch_t.compare)
}

// required .common.memory_t ret = 6;
inline bool bsearch_t::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void bsearch_t::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void bsearch_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void bsearch_t::clear_ret() {
  if (ret_ != NULL) ret_->::common::memory_t::Clear();
  clear_has_ret();
}
inline const ::common::memory_t& bsearch_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_t.ret)
  return ret_ != NULL ? *ret_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* bsearch_t::mutable_ret() {
  set_has_ret();
  if (ret_ == NULL) {
    ret_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.bsearch_t.ret)
  return ret_;
}
inline ::common::memory_t* bsearch_t::release_ret() {
  // @@protoc_insertion_point(field_release:libcall_types.bsearch_t.ret)
  clear_has_ret();
  ::common::memory_t* temp = ret_;
  ret_ = NULL;
  return temp;
}
inline void bsearch_t::set_allocated_ret(::common::memory_t* ret) {
  delete ret_;
  ret_ = ret;
  if (ret) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.bsearch_t.ret)
}

// -------------------------------------------------------------------

// open_t

// required .common.memory_t pathname = 1;
inline bool open_t::has_pathname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void open_t::set_has_pathname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void open_t::clear_has_pathname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void open_t::clear_pathname() {
  if (pathname_ != NULL) pathname_->::common::memory_t::Clear();
  clear_has_pathname();
}
inline const ::common::memory_t& open_t::pathname() const {
  // @@protoc_insertion_point(field_get:libcall_types.open_t.pathname)
  return pathname_ != NULL ? *pathname_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* open_t::mutable_pathname() {
  set_has_pathname();
  if (pathname_ == NULL) {
    pathname_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.open_t.pathname)
  return pathname_;
}
inline ::common::memory_t* open_t::release_pathname() {
  // @@protoc_insertion_point(field_release:libcall_types.open_t.pathname)
  clear_has_pathname();
  ::common::memory_t* temp = pathname_;
  pathname_ = NULL;
  return temp;
}
inline void open_t::set_allocated_pathname(::common::memory_t* pathname) {
  delete pathname_;
  pathname_ = pathname;
  if (pathname) {
    set_has_pathname();
  } else {
    clear_has_pathname();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.open_t.pathname)
}

// required uint64 flags = 3;
inline bool open_t::has_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void open_t::set_has_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void open_t::clear_has_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void open_t::clear_flags() {
  flags_ = GOOGLE_ULONGLONG(0);
  clear_has_flags();
}
inline ::google::protobuf::uint64 open_t::flags() const {
  // @@protoc_insertion_point(field_get:libcall_types.open_t.flags)
  return flags_;
}
inline void open_t::set_flags(::google::protobuf::uint64 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.open_t.flags)
}

// required uint64 mode = 4;
inline bool open_t::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void open_t::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void open_t::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void open_t::clear_mode() {
  mode_ = GOOGLE_ULONGLONG(0);
  clear_has_mode();
}
inline ::google::protobuf::uint64 open_t::mode() const {
  // @@protoc_insertion_point(field_get:libcall_types.open_t.mode)
  return mode_;
}
inline void open_t::set_mode(::google::protobuf::uint64 value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.open_t.mode)
}

// required uint64 ret = 5;
inline bool open_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void open_t::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void open_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void open_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 open_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.open_t.ret)
  return ret_;
}
inline void open_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.open_t.ret)
}

// -------------------------------------------------------------------

// strcpy_t

// required .common.memory_t src = 1;
inline bool strcpy_t::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void strcpy_t::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void strcpy_t::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void strcpy_t::clear_src() {
  if (src_ != NULL) src_->::common::memory_t::Clear();
  clear_has_src();
}
inline const ::common::memory_t& strcpy_t::src() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcpy_t.src)
  return src_ != NULL ? *src_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* strcpy_t::mutable_src() {
  set_has_src();
  if (src_ == NULL) {
    src_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.strcpy_t.src)
  return src_;
}
inline ::common::memory_t* strcpy_t::release_src() {
  // @@protoc_insertion_point(field_release:libcall_types.strcpy_t.src)
  clear_has_src();
  ::common::memory_t* temp = src_;
  src_ = NULL;
  return temp;
}
inline void strcpy_t::set_allocated_src(::common::memory_t* src) {
  delete src_;
  src_ = src;
  if (src) {
    set_has_src();
  } else {
    clear_has_src();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.strcpy_t.src)
}

// required .common.memory_t dst = 2;
inline bool strcpy_t::has_dst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void strcpy_t::set_has_dst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void strcpy_t::clear_has_dst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void strcpy_t::clear_dst() {
  if (dst_ != NULL) dst_->::common::memory_t::Clear();
  clear_has_dst();
}
inline const ::common::memory_t& strcpy_t::dst() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcpy_t.dst)
  return dst_ != NULL ? *dst_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* strcpy_t::mutable_dst() {
  set_has_dst();
  if (dst_ == NULL) {
    dst_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.strcpy_t.dst)
  return dst_;
}
inline ::common::memory_t* strcpy_t::release_dst() {
  // @@protoc_insertion_point(field_release:libcall_types.strcpy_t.dst)
  clear_has_dst();
  ::common::memory_t* temp = dst_;
  dst_ = NULL;
  return temp;
}
inline void strcpy_t::set_allocated_dst(::common::memory_t* dst) {
  delete dst_;
  dst_ = dst;
  if (dst) {
    set_has_dst();
  } else {
    clear_has_dst();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.strcpy_t.dst)
}

// required uint64 ret = 3;
inline bool strcpy_t::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strcpy_t::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void strcpy_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void strcpy_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 strcpy_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcpy_t.ret)
  return ret_;
}
inline void strcpy_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strcpy_t.ret)
}

// -------------------------------------------------------------------

// strcmp_t

// required uint64 s1 = 1;
inline bool strcmp_t::has_s1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void strcmp_t::set_has_s1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void strcmp_t::clear_has_s1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void strcmp_t::clear_s1() {
  s1_ = GOOGLE_ULONGLONG(0);
  clear_has_s1();
}
inline ::google::protobuf::uint64 strcmp_t::s1() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcmp_t.s1)
  return s1_;
}
inline void strcmp_t::set_s1(::google::protobuf::uint64 value) {
  set_has_s1();
  s1_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strcmp_t.s1)
}

// required uint64 s2 = 2;
inline bool strcmp_t::has_s2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void strcmp_t::set_has_s2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void strcmp_t::clear_has_s2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void strcmp_t::clear_s2() {
  s2_ = GOOGLE_ULONGLONG(0);
  clear_has_s2();
}
inline ::google::protobuf::uint64 strcmp_t::s2() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcmp_t.s2)
  return s2_;
}
inline void strcmp_t::set_s2(::google::protobuf::uint64 value) {
  set_has_s2();
  s2_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strcmp_t.s2)
}

// required uint64 size_max_s1 = 3;
inline bool strcmp_t::has_size_max_s1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strcmp_t::set_has_size_max_s1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void strcmp_t::clear_has_size_max_s1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void strcmp_t::clear_size_max_s1() {
  size_max_s1_ = GOOGLE_ULONGLONG(0);
  clear_has_size_max_s1();
}
inline ::google::protobuf::uint64 strcmp_t::size_max_s1() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcmp_t.size_max_s1)
  return size_max_s1_;
}
inline void strcmp_t::set_size_max_s1(::google::protobuf::uint64 value) {
  set_has_size_max_s1();
  size_max_s1_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strcmp_t.size_max_s1)
}

// required uint64 size_max_s2 = 4;
inline bool strcmp_t::has_size_max_s2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void strcmp_t::set_has_size_max_s2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void strcmp_t::clear_has_size_max_s2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void strcmp_t::clear_size_max_s2() {
  size_max_s2_ = GOOGLE_ULONGLONG(0);
  clear_has_size_max_s2();
}
inline ::google::protobuf::uint64 strcmp_t::size_max_s2() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcmp_t.size_max_s2)
  return size_max_s2_;
}
inline void strcmp_t::set_size_max_s2(::google::protobuf::uint64 value) {
  set_has_size_max_s2();
  size_max_s2_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strcmp_t.size_max_s2)
}

// required uint64 ret = 5;
inline bool strcmp_t::has_ret() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void strcmp_t::set_has_ret() {
  _has_bits_[0] |= 0x00000010u;
}
inline void strcmp_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void strcmp_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 strcmp_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcmp_t.ret)
  return ret_;
}
inline void strcmp_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strcmp_t.ret)
}

// -------------------------------------------------------------------

// strncmp_t

// required uint64 s1 = 1;
inline bool strncmp_t::has_s1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void strncmp_t::set_has_s1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void strncmp_t::clear_has_s1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void strncmp_t::clear_s1() {
  s1_ = GOOGLE_ULONGLONG(0);
  clear_has_s1();
}
inline ::google::protobuf::uint64 strncmp_t::s1() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncmp_t.s1)
  return s1_;
}
inline void strncmp_t::set_s1(::google::protobuf::uint64 value) {
  set_has_s1();
  s1_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncmp_t.s1)
}

// required uint64 s2 = 2;
inline bool strncmp_t::has_s2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void strncmp_t::set_has_s2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void strncmp_t::clear_has_s2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void strncmp_t::clear_s2() {
  s2_ = GOOGLE_ULONGLONG(0);
  clear_has_s2();
}
inline ::google::protobuf::uint64 strncmp_t::s2() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncmp_t.s2)
  return s2_;
}
inline void strncmp_t::set_s2(::google::protobuf::uint64 value) {
  set_has_s2();
  s2_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncmp_t.s2)
}

// required uint64 n = 3;
inline bool strncmp_t::has_n() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strncmp_t::set_has_n() {
  _has_bits_[0] |= 0x00000004u;
}
inline void strncmp_t::clear_has_n() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void strncmp_t::clear_n() {
  n_ = GOOGLE_ULONGLONG(0);
  clear_has_n();
}
inline ::google::protobuf::uint64 strncmp_t::n() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncmp_t.n)
  return n_;
}
inline void strncmp_t::set_n(::google::protobuf::uint64 value) {
  set_has_n();
  n_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncmp_t.n)
}

// required uint64 ret = 4;
inline bool strncmp_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void strncmp_t::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void strncmp_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void strncmp_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 strncmp_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncmp_t.ret)
  return ret_;
}
inline void strncmp_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncmp_t.ret)
}

// -------------------------------------------------------------------

// memcmp_t

// required uint64 s1 = 1;
inline bool memcmp_t::has_s1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void memcmp_t::set_has_s1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void memcmp_t::clear_has_s1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void memcmp_t::clear_s1() {
  s1_ = GOOGLE_ULONGLONG(0);
  clear_has_s1();
}
inline ::google::protobuf::uint64 memcmp_t::s1() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcmp_t.s1)
  return s1_;
}
inline void memcmp_t::set_s1(::google::protobuf::uint64 value) {
  set_has_s1();
  s1_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcmp_t.s1)
}

// required uint64 s2 = 2;
inline bool memcmp_t::has_s2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void memcmp_t::set_has_s2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void memcmp_t::clear_has_s2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void memcmp_t::clear_s2() {
  s2_ = GOOGLE_ULONGLONG(0);
  clear_has_s2();
}
inline ::google::protobuf::uint64 memcmp_t::s2() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcmp_t.s2)
  return s2_;
}
inline void memcmp_t::set_s2(::google::protobuf::uint64 value) {
  set_has_s2();
  s2_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcmp_t.s2)
}

// required uint64 n = 3;
inline bool memcmp_t::has_n() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void memcmp_t::set_has_n() {
  _has_bits_[0] |= 0x00000004u;
}
inline void memcmp_t::clear_has_n() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void memcmp_t::clear_n() {
  n_ = GOOGLE_ULONGLONG(0);
  clear_has_n();
}
inline ::google::protobuf::uint64 memcmp_t::n() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcmp_t.n)
  return n_;
}
inline void memcmp_t::set_n(::google::protobuf::uint64 value) {
  set_has_n();
  n_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcmp_t.n)
}

// required uint64 ret = 4;
inline bool memcmp_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void memcmp_t::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void memcmp_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void memcmp_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 memcmp_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcmp_t.ret)
  return ret_;
}
inline void memcmp_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcmp_t.ret)
}

// -------------------------------------------------------------------

// printf_t

// required .common.memory_t format = 1;
inline bool printf_t::has_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void printf_t::set_has_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void printf_t::clear_has_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void printf_t::clear_format() {
  if (format_ != NULL) format_->::common::memory_t::Clear();
  clear_has_format();
}
inline const ::common::memory_t& printf_t::format() const {
  // @@protoc_insertion_point(field_get:libcall_types.printf_t.format)
  return format_ != NULL ? *format_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* printf_t::mutable_format() {
  set_has_format();
  if (format_ == NULL) {
    format_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.printf_t.format)
  return format_;
}
inline ::common::memory_t* printf_t::release_format() {
  // @@protoc_insertion_point(field_release:libcall_types.printf_t.format)
  clear_has_format();
  ::common::memory_t* temp = format_;
  format_ = NULL;
  return temp;
}
inline void printf_t::set_allocated_format(::common::memory_t* format) {
  delete format_;
  format_ = format;
  if (format) {
    set_has_format();
  } else {
    clear_has_format();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.printf_t.format)
}

// required uint64 ret = 2;
inline bool printf_t::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void printf_t::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void printf_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void printf_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 printf_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.printf_t.ret)
  return ret_;
}
inline void printf_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.printf_t.ret)
}

// -------------------------------------------------------------------

// atoi_t

// required .common.memory_t src = 1;
inline bool atoi_t::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void atoi_t::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void atoi_t::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void atoi_t::clear_src() {
  if (src_ != NULL) src_->::common::memory_t::Clear();
  clear_has_src();
}
inline const ::common::memory_t& atoi_t::src() const {
  // @@protoc_insertion_point(field_get:libcall_types.atoi_t.src)
  return src_ != NULL ? *src_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* atoi_t::mutable_src() {
  set_has_src();
  if (src_ == NULL) {
    src_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.atoi_t.src)
  return src_;
}
inline ::common::memory_t* atoi_t::release_src() {
  // @@protoc_insertion_point(field_release:libcall_types.atoi_t.src)
  clear_has_src();
  ::common::memory_t* temp = src_;
  src_ = NULL;
  return temp;
}
inline void atoi_t::set_allocated_src(::common::memory_t* src) {
  delete src_;
  src_ = src;
  if (src) {
    set_has_src();
  } else {
    clear_has_src();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.atoi_t.src)
}

// required uint64 ret = 3;
inline bool atoi_t::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void atoi_t::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void atoi_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void atoi_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 atoi_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.atoi_t.ret)
  return ret_;
}
inline void atoi_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.atoi_t.ret)
}

// -------------------------------------------------------------------

// malloc_t

// required uint64 size = 1;
inline bool malloc_t::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void malloc_t::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void malloc_t::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void malloc_t::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 malloc_t::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.malloc_t.size)
  return size_;
}
inline void malloc_t::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.malloc_t.size)
}

// required uint64 ret = 2;
inline bool malloc_t::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void malloc_t::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void malloc_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void malloc_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 malloc_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.malloc_t.ret)
  return ret_;
}
inline void malloc_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.malloc_t.ret)
}

// -------------------------------------------------------------------

// getmodulehandle_t

// required .common.memory_t module_name = 1;
inline bool getmodulehandle_t::has_module_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void getmodulehandle_t::set_has_module_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void getmodulehandle_t::clear_has_module_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void getmodulehandle_t::clear_module_name() {
  if (module_name_ != NULL) module_name_->::common::memory_t::Clear();
  clear_has_module_name();
}
inline const ::common::memory_t& getmodulehandle_t::module_name() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmodulehandle_t.module_name)
  return module_name_ != NULL ? *module_name_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* getmodulehandle_t::mutable_module_name() {
  set_has_module_name();
  if (module_name_ == NULL) {
    module_name_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmodulehandle_t.module_name)
  return module_name_;
}
inline ::common::memory_t* getmodulehandle_t::release_module_name() {
  // @@protoc_insertion_point(field_release:libcall_types.getmodulehandle_t.module_name)
  clear_has_module_name();
  ::common::memory_t* temp = module_name_;
  module_name_ = NULL;
  return temp;
}
inline void getmodulehandle_t::set_allocated_module_name(::common::memory_t* module_name) {
  delete module_name_;
  module_name_ = module_name;
  if (module_name) {
    set_has_module_name();
  } else {
    clear_has_module_name();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmodulehandle_t.module_name)
}

// required uint64 ret = 2;
inline bool getmodulehandle_t::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void getmodulehandle_t::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void getmodulehandle_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void getmodulehandle_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 getmodulehandle_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmodulehandle_t.ret)
  return ret_;
}
inline void getmodulehandle_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getmodulehandle_t.ret)
}

// -------------------------------------------------------------------

// getprocaddress_t

// required uint64 hmodule = 1;
inline bool getprocaddress_t::has_hmodule() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void getprocaddress_t::set_has_hmodule() {
  _has_bits_[0] |= 0x00000002u;
}
inline void getprocaddress_t::clear_has_hmodule() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void getprocaddress_t::clear_hmodule() {
  hmodule_ = GOOGLE_ULONGLONG(0);
  clear_has_hmodule();
}
inline ::google::protobuf::uint64 getprocaddress_t::hmodule() const {
  // @@protoc_insertion_point(field_get:libcall_types.getprocaddress_t.hmodule)
  return hmodule_;
}
inline void getprocaddress_t::set_hmodule(::google::protobuf::uint64 value) {
  set_has_hmodule();
  hmodule_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getprocaddress_t.hmodule)
}

// required .common.memory_t proc_name = 2;
inline bool getprocaddress_t::has_proc_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void getprocaddress_t::set_has_proc_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void getprocaddress_t::clear_has_proc_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void getprocaddress_t::clear_proc_name() {
  if (proc_name_ != NULL) proc_name_->::common::memory_t::Clear();
  clear_has_proc_name();
}
inline const ::common::memory_t& getprocaddress_t::proc_name() const {
  // @@protoc_insertion_point(field_get:libcall_types.getprocaddress_t.proc_name)
  return proc_name_ != NULL ? *proc_name_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* getprocaddress_t::mutable_proc_name() {
  set_has_proc_name();
  if (proc_name_ == NULL) {
    proc_name_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getprocaddress_t.proc_name)
  return proc_name_;
}
inline ::common::memory_t* getprocaddress_t::release_proc_name() {
  // @@protoc_insertion_point(field_release:libcall_types.getprocaddress_t.proc_name)
  clear_has_proc_name();
  ::common::memory_t* temp = proc_name_;
  proc_name_ = NULL;
  return temp;
}
inline void getprocaddress_t::set_allocated_proc_name(::common::memory_t* proc_name) {
  delete proc_name_;
  proc_name_ = proc_name;
  if (proc_name) {
    set_has_proc_name();
  } else {
    clear_has_proc_name();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getprocaddress_t.proc_name)
}

// required uint64 ret = 3;
inline bool getprocaddress_t::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void getprocaddress_t::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void getprocaddress_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void getprocaddress_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 getprocaddress_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.getprocaddress_t.ret)
  return ret_;
}
inline void getprocaddress_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getprocaddress_t.ret)
}

// -------------------------------------------------------------------

// getmainargs_t

// required .common.memory_t argc = 1;
inline bool getmainargs_t::has_argc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void getmainargs_t::set_has_argc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void getmainargs_t::clear_has_argc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void getmainargs_t::clear_argc() {
  if (argc_ != NULL) argc_->::common::memory_t::Clear();
  clear_has_argc();
}
inline const ::common::memory_t& getmainargs_t::argc() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_t.argc)
  return argc_ != NULL ? *argc_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* getmainargs_t::mutable_argc() {
  set_has_argc();
  if (argc_ == NULL) {
    argc_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmainargs_t.argc)
  return argc_;
}
inline ::common::memory_t* getmainargs_t::release_argc() {
  // @@protoc_insertion_point(field_release:libcall_types.getmainargs_t.argc)
  clear_has_argc();
  ::common::memory_t* temp = argc_;
  argc_ = NULL;
  return temp;
}
inline void getmainargs_t::set_allocated_argc(::common::memory_t* argc) {
  delete argc_;
  argc_ = argc;
  if (argc) {
    set_has_argc();
  } else {
    clear_has_argc();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmainargs_t.argc)
}

// required .common.memory_t argv = 2;
inline bool getmainargs_t::has_argv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void getmainargs_t::set_has_argv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void getmainargs_t::clear_has_argv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void getmainargs_t::clear_argv() {
  if (argv_ != NULL) argv_->::common::memory_t::Clear();
  clear_has_argv();
}
inline const ::common::memory_t& getmainargs_t::argv() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_t.argv)
  return argv_ != NULL ? *argv_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* getmainargs_t::mutable_argv() {
  set_has_argv();
  if (argv_ == NULL) {
    argv_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmainargs_t.argv)
  return argv_;
}
inline ::common::memory_t* getmainargs_t::release_argv() {
  // @@protoc_insertion_point(field_release:libcall_types.getmainargs_t.argv)
  clear_has_argv();
  ::common::memory_t* temp = argv_;
  argv_ = NULL;
  return temp;
}
inline void getmainargs_t::set_allocated_argv(::common::memory_t* argv) {
  delete argv_;
  argv_ = argv;
  if (argv) {
    set_has_argv();
  } else {
    clear_has_argv();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmainargs_t.argv)
}

// required .common.memory_t env = 3;
inline bool getmainargs_t::has_env() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void getmainargs_t::set_has_env() {
  _has_bits_[0] |= 0x00000004u;
}
inline void getmainargs_t::clear_has_env() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void getmainargs_t::clear_env() {
  if (env_ != NULL) env_->::common::memory_t::Clear();
  clear_has_env();
}
inline const ::common::memory_t& getmainargs_t::env() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_t.env)
  return env_ != NULL ? *env_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* getmainargs_t::mutable_env() {
  set_has_env();
  if (env_ == NULL) {
    env_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmainargs_t.env)
  return env_;
}
inline ::common::memory_t* getmainargs_t::release_env() {
  // @@protoc_insertion_point(field_release:libcall_types.getmainargs_t.env)
  clear_has_env();
  ::common::memory_t* temp = env_;
  env_ = NULL;
  return temp;
}
inline void getmainargs_t::set_allocated_env(::common::memory_t* env) {
  delete env_;
  env_ = env;
  if (env) {
    set_has_env();
  } else {
    clear_has_env();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmainargs_t.env)
}

// required uint64 dowildcard = 4;
inline bool getmainargs_t::has_dowildcard() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void getmainargs_t::set_has_dowildcard() {
  _has_bits_[0] |= 0x00000010u;
}
inline void getmainargs_t::clear_has_dowildcard() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void getmainargs_t::clear_dowildcard() {
  dowildcard_ = GOOGLE_ULONGLONG(0);
  clear_has_dowildcard();
}
inline ::google::protobuf::uint64 getmainargs_t::dowildcard() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_t.dowildcard)
  return dowildcard_;
}
inline void getmainargs_t::set_dowildcard(::google::protobuf::uint64 value) {
  set_has_dowildcard();
  dowildcard_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getmainargs_t.dowildcard)
}

// required .common.memory_t startinfo = 5;
inline bool getmainargs_t::has_startinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void getmainargs_t::set_has_startinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void getmainargs_t::clear_has_startinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void getmainargs_t::clear_startinfo() {
  if (startinfo_ != NULL) startinfo_->::common::memory_t::Clear();
  clear_has_startinfo();
}
inline const ::common::memory_t& getmainargs_t::startinfo() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_t.startinfo)
  return startinfo_ != NULL ? *startinfo_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* getmainargs_t::mutable_startinfo() {
  set_has_startinfo();
  if (startinfo_ == NULL) {
    startinfo_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmainargs_t.startinfo)
  return startinfo_;
}
inline ::common::memory_t* getmainargs_t::release_startinfo() {
  // @@protoc_insertion_point(field_release:libcall_types.getmainargs_t.startinfo)
  clear_has_startinfo();
  ::common::memory_t* temp = startinfo_;
  startinfo_ = NULL;
  return temp;
}
inline void getmainargs_t::set_allocated_startinfo(::common::memory_t* startinfo) {
  delete startinfo_;
  startinfo_ = startinfo;
  if (startinfo) {
    set_has_startinfo();
  } else {
    clear_has_startinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmainargs_t.startinfo)
}

// required uint64 ret = 6;
inline bool getmainargs_t::has_ret() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void getmainargs_t::set_has_ret() {
  _has_bits_[0] |= 0x00000020u;
}
inline void getmainargs_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void getmainargs_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 getmainargs_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_t.ret)
  return ret_;
}
inline void getmainargs_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getmainargs_t.ret)
}

// -------------------------------------------------------------------

// gethostname_t

// required .common.memory_t name = 1;
inline bool gethostname_t::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gethostname_t::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gethostname_t::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gethostname_t::clear_name() {
  if (name_ != NULL) name_->::common::memory_t::Clear();
  clear_has_name();
}
inline const ::common::memory_t& gethostname_t::name() const {
  // @@protoc_insertion_point(field_get:libcall_types.gethostname_t.name)
  return name_ != NULL ? *name_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* gethostname_t::mutable_name() {
  set_has_name();
  if (name_ == NULL) {
    name_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.gethostname_t.name)
  return name_;
}
inline ::common::memory_t* gethostname_t::release_name() {
  // @@protoc_insertion_point(field_release:libcall_types.gethostname_t.name)
  clear_has_name();
  ::common::memory_t* temp = name_;
  name_ = NULL;
  return temp;
}
inline void gethostname_t::set_allocated_name(::common::memory_t* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.gethostname_t.name)
}

// required uint64 namelen = 2;
inline bool gethostname_t::has_namelen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gethostname_t::set_has_namelen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gethostname_t::clear_has_namelen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gethostname_t::clear_namelen() {
  namelen_ = GOOGLE_ULONGLONG(0);
  clear_has_namelen();
}
inline ::google::protobuf::uint64 gethostname_t::namelen() const {
  // @@protoc_insertion_point(field_get:libcall_types.gethostname_t.namelen)
  return namelen_;
}
inline void gethostname_t::set_namelen(::google::protobuf::uint64 value) {
  set_has_namelen();
  namelen_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.gethostname_t.namelen)
}

// required uint64 ret = 3;
inline bool gethostname_t::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gethostname_t::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gethostname_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gethostname_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 gethostname_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.gethostname_t.ret)
  return ret_;
}
inline void gethostname_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.gethostname_t.ret)
}

// -------------------------------------------------------------------

// free_t

// required uint64 ptr = 1;
inline bool free_t::has_ptr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void free_t::set_has_ptr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void free_t::clear_has_ptr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void free_t::clear_ptr() {
  ptr_ = GOOGLE_ULONGLONG(0);
  clear_has_ptr();
}
inline ::google::protobuf::uint64 free_t::ptr() const {
  // @@protoc_insertion_point(field_get:libcall_types.free_t.ptr)
  return ptr_;
}
inline void free_t::set_ptr(::google::protobuf::uint64 value) {
  set_has_ptr();
  ptr_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.free_t.ptr)
}

// -------------------------------------------------------------------

// memcpy_t

// required .common.memory_t dest = 1;
inline bool memcpy_t::has_dest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void memcpy_t::set_has_dest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void memcpy_t::clear_has_dest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void memcpy_t::clear_dest() {
  if (dest_ != NULL) dest_->::common::memory_t::Clear();
  clear_has_dest();
}
inline const ::common::memory_t& memcpy_t::dest() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcpy_t.dest)
  return dest_ != NULL ? *dest_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* memcpy_t::mutable_dest() {
  set_has_dest();
  if (dest_ == NULL) {
    dest_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.memcpy_t.dest)
  return dest_;
}
inline ::common::memory_t* memcpy_t::release_dest() {
  // @@protoc_insertion_point(field_release:libcall_types.memcpy_t.dest)
  clear_has_dest();
  ::common::memory_t* temp = dest_;
  dest_ = NULL;
  return temp;
}
inline void memcpy_t::set_allocated_dest(::common::memory_t* dest) {
  delete dest_;
  dest_ = dest;
  if (dest) {
    set_has_dest();
  } else {
    clear_has_dest();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.memcpy_t.dest)
}

// required .common.memory_t src = 2;
inline bool memcpy_t::has_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void memcpy_t::set_has_src() {
  _has_bits_[0] |= 0x00000002u;
}
inline void memcpy_t::clear_has_src() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void memcpy_t::clear_src() {
  if (src_ != NULL) src_->::common::memory_t::Clear();
  clear_has_src();
}
inline const ::common::memory_t& memcpy_t::src() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcpy_t.src)
  return src_ != NULL ? *src_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* memcpy_t::mutable_src() {
  set_has_src();
  if (src_ == NULL) {
    src_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.memcpy_t.src)
  return src_;
}
inline ::common::memory_t* memcpy_t::release_src() {
  // @@protoc_insertion_point(field_release:libcall_types.memcpy_t.src)
  clear_has_src();
  ::common::memory_t* temp = src_;
  src_ = NULL;
  return temp;
}
inline void memcpy_t::set_allocated_src(::common::memory_t* src) {
  delete src_;
  src_ = src;
  if (src) {
    set_has_src();
  } else {
    clear_has_src();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.memcpy_t.src)
}

// required uint64 size = 3;
inline bool memcpy_t::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void memcpy_t::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void memcpy_t::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void memcpy_t::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 memcpy_t::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcpy_t.size)
  return size_;
}
inline void memcpy_t::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcpy_t.size)
}

// required uint64 ret = 4;
inline bool memcpy_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void memcpy_t::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void memcpy_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void memcpy_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 memcpy_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcpy_t.ret)
  return ret_;
}
inline void memcpy_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcpy_t.ret)
}

// -------------------------------------------------------------------

// memset_t

// required .common.memory_t s = 1;
inline bool memset_t::has_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void memset_t::set_has_s() {
  _has_bits_[0] |= 0x00000001u;
}
inline void memset_t::clear_has_s() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void memset_t::clear_s() {
  if (s_ != NULL) s_->::common::memory_t::Clear();
  clear_has_s();
}
inline const ::common::memory_t& memset_t::s() const {
  // @@protoc_insertion_point(field_get:libcall_types.memset_t.s)
  return s_ != NULL ? *s_
                         : *::common::memory_t::internal_default_instance();
}
inline ::common::memory_t* memset_t::mutable_s() {
  set_has_s();
  if (s_ == NULL) {
    s_ = new ::common::memory_t;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.memset_t.s)
  return s_;
}
inline ::common::memory_t* memset_t::release_s() {
  // @@protoc_insertion_point(field_release:libcall_types.memset_t.s)
  clear_has_s();
  ::common::memory_t* temp = s_;
  s_ = NULL;
  return temp;
}
inline void memset_t::set_allocated_s(::common::memory_t* s) {
  delete s_;
  s_ = s;
  if (s) {
    set_has_s();
  } else {
    clear_has_s();
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.memset_t.s)
}

// required uint64 c = 2;
inline bool memset_t::has_c() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void memset_t::set_has_c() {
  _has_bits_[0] |= 0x00000002u;
}
inline void memset_t::clear_has_c() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void memset_t::clear_c() {
  c_ = GOOGLE_ULONGLONG(0);
  clear_has_c();
}
inline ::google::protobuf::uint64 memset_t::c() const {
  // @@protoc_insertion_point(field_get:libcall_types.memset_t.c)
  return c_;
}
inline void memset_t::set_c(::google::protobuf::uint64 value) {
  set_has_c();
  c_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memset_t.c)
}

// required uint64 size = 3;
inline bool memset_t::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void memset_t::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void memset_t::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void memset_t::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 memset_t::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.memset_t.size)
  return size_;
}
inline void memset_t::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memset_t.size)
}

// required uint64 ret = 4;
inline bool memset_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void memset_t::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void memset_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void memset_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 memset_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.memset_t.ret)
  return ret_;
}
inline void memset_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memset_t.ret)
}

// -------------------------------------------------------------------

// fgetc_t

// required uint64 stream = 1;
inline bool fgetc_t::has_stream() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fgetc_t::set_has_stream() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fgetc_t::clear_has_stream() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fgetc_t::clear_stream() {
  stream_ = GOOGLE_ULONGLONG(0);
  clear_has_stream();
}
inline ::google::protobuf::uint64 fgetc_t::stream() const {
  // @@protoc_insertion_point(field_get:libcall_types.fgetc_t.stream)
  return stream_;
}
inline void fgetc_t::set_stream(::google::protobuf::uint64 value) {
  set_has_stream();
  stream_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fgetc_t.stream)
}

// required uint64 ret = 2;
inline bool fgetc_t::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fgetc_t::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fgetc_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fgetc_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 fgetc_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.fgetc_t.ret)
  return ret_;
}
inline void fgetc_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fgetc_t.ret)
}

// -------------------------------------------------------------------

// lseek_t

// required uint64 fd = 1;
inline bool lseek_t::has_fd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lseek_t::set_has_fd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lseek_t::clear_has_fd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lseek_t::clear_fd() {
  fd_ = GOOGLE_ULONGLONG(0);
  clear_has_fd();
}
inline ::google::protobuf::uint64 lseek_t::fd() const {
  // @@protoc_insertion_point(field_get:libcall_types.lseek_t.fd)
  return fd_;
}
inline void lseek_t::set_fd(::google::protobuf::uint64 value) {
  set_has_fd();
  fd_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.lseek_t.fd)
}

// required uint64 offset = 2;
inline bool lseek_t::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lseek_t::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lseek_t::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lseek_t::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 lseek_t::offset() const {
  // @@protoc_insertion_point(field_get:libcall_types.lseek_t.offset)
  return offset_;
}
inline void lseek_t::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.lseek_t.offset)
}

// required uint64 whence = 3;
inline bool lseek_t::has_whence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lseek_t::set_has_whence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void lseek_t::clear_has_whence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void lseek_t::clear_whence() {
  whence_ = GOOGLE_ULONGLONG(0);
  clear_has_whence();
}
inline ::google::protobuf::uint64 lseek_t::whence() const {
  // @@protoc_insertion_point(field_get:libcall_types.lseek_t.whence)
  return whence_;
}
inline void lseek_t::set_whence(::google::protobuf::uint64 value) {
  set_has_whence();
  whence_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.lseek_t.whence)
}

// required uint64 ret = 4;
inline bool lseek_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lseek_t::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void lseek_t::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void lseek_t::clear_ret() {
  ret_ = GOOGLE_ULONGLONG(0);
  clear_has_ret();
}
inline ::google::protobuf::uint64 lseek_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.lseek_t.ret)
  return ret_;
}
inline void lseek_t::set_ret(::google::protobuf::uint64 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.lseek_t.ret)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace libcall_types

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::libcall_types::lib_ident> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::libcall_types::lib_ident>() {
  return ::libcall_types::lib_ident_descriptor();
}
template <> struct is_proto_enum< ::libcall_types::fscanf_enum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::libcall_types::fscanf_enum>() {
  return ::libcall_types::fscanf_enum_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_libcall_2eproto__INCLUDED
