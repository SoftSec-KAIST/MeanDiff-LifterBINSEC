// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dba.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "dba.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace dba {
class bitvectorDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<bitvector> {
} _bitvector_default_instance_;
class dbacodeaddressDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<dbacodeaddress> {
} _dbacodeaddress_default_instance_;
class codeaddressDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<codeaddress> {
} _codeaddress_default_instance_;
class dbatagDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<dbatag> {
} _dbatag_default_instance_;
class dbastopstateDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<dbastopstate> {
} _dbastopstate_default_instance_;
class dbaexprDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<dbaexpr> {
} _dbaexpr_default_instance_;
class dbacondDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<dbacond> {
} _dbacond_default_instance_;
class dbaLhsDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<dbaLhs> {
} _dbaLhs_default_instance_;
class dbainstrDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<dbainstr> {
} _dbainstr_default_instance_;
class dba_listDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<dba_list> {
} _dba_list_default_instance_;

namespace protobuf_dba_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[10];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[10];

}  // namespace

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(bitvector, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(bitvector, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(bitvector, bv_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(bitvector, size_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbacodeaddress, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbacodeaddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbacodeaddress, bitvector_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbacodeaddress, dbaoffset_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(codeaddress, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(codeaddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(codeaddress, typeid__),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(codeaddress, offset_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(codeaddress, address_),
  1,
  2,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbatag, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbatag, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbatag, typeid__),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbatag, address_),
  1,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbastopstate, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbastopstate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbastopstate, typeid__),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbastopstate, infos_),
  1,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaexpr, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaexpr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaexpr, typeid__),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaexpr, name_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaexpr, size_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaexpr, endian_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaexpr, bitvector_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaexpr, expr1_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaexpr, expr2_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaexpr, unaryop_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaexpr, binaryop_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaexpr, low_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaexpr, high_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaexpr, cond_),
  8,
  0,
  5,
  9,
  1,
  2,
  3,
  10,
  11,
  6,
  7,
  4,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbacond, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbacond, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbacond, typeid__),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbacond, expr_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbacond, cond1_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbacond, cond2_),
  3,
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaLhs, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaLhs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaLhs, typeid__),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaLhs, name_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaLhs, size_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaLhs, low_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaLhs, high_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaLhs, endian_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbaLhs, expr_),
  5,
  0,
  2,
  3,
  4,
  6,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbainstr, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbainstr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbainstr, typeid__),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbainstr, location_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbainstr, lhs_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbainstr, expr_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbainstr, offset_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbainstr, address_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbainstr, tags_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbainstr, cond_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbainstr, stopinfos_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dbainstr, exprs_),
  8,
  0,
  1,
  2,
  7,
  3,
  4,
  5,
  6,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dba_list, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dba_list, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(dba_list, instrs_),
  ~0u,
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, 6, sizeof(bitvector)},
  { 8, 14, sizeof(dbacodeaddress)},
  { 16, 23, sizeof(codeaddress)},
  { 26, 32, sizeof(dbatag)},
  { 34, 40, sizeof(dbastopstate)},
  { 42, 58, sizeof(dbaexpr)},
  { 70, 78, sizeof(dbacond)},
  { 82, 93, sizeof(dbaLhs)},
  { 100, 114, sizeof(dbainstr)},
  { 124, 129, sizeof(dba_list)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_bitvector_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_dbacodeaddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_codeaddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_dbatag_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_dbastopstate_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_dbaexpr_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_dbacond_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_dbaLhs_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_dbainstr_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_dba_list_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "dba.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 10);
}

}  // namespace

void TableStruct::Shutdown() {
  _bitvector_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _dbacodeaddress_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _codeaddress_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
  _dbatag_default_instance_.Shutdown();
  delete file_level_metadata[3].reflection;
  _dbastopstate_default_instance_.Shutdown();
  delete file_level_metadata[4].reflection;
  _dbaexpr_default_instance_.Shutdown();
  delete file_level_metadata[5].reflection;
  _dbacond_default_instance_.Shutdown();
  delete file_level_metadata[6].reflection;
  _dbaLhs_default_instance_.Shutdown();
  delete file_level_metadata[7].reflection;
  _dbainstr_default_instance_.Shutdown();
  delete file_level_metadata[8].reflection;
  _dba_list_default_instance_.Shutdown();
  delete file_level_metadata[9].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  _bitvector_default_instance_.DefaultConstruct();
  _dbacodeaddress_default_instance_.DefaultConstruct();
  _codeaddress_default_instance_.DefaultConstruct();
  _dbatag_default_instance_.DefaultConstruct();
  _dbastopstate_default_instance_.DefaultConstruct();
  _dbaexpr_default_instance_.DefaultConstruct();
  _dbacond_default_instance_.DefaultConstruct();
  _dbaLhs_default_instance_.DefaultConstruct();
  _dbainstr_default_instance_.DefaultConstruct();
  _dba_list_default_instance_.DefaultConstruct();
  _dbacodeaddress_default_instance_.get_mutable()->bitvector_ = const_cast< ::dba::bitvector*>(
      ::dba::bitvector::internal_default_instance());
  _codeaddress_default_instance_.get_mutable()->address_ = const_cast< ::dba::dbacodeaddress*>(
      ::dba::dbacodeaddress::internal_default_instance());
  _dbatag_default_instance_.get_mutable()->address_ = const_cast< ::dba::dbacodeaddress*>(
      ::dba::dbacodeaddress::internal_default_instance());
  _dbaexpr_default_instance_.get_mutable()->bitvector_ = const_cast< ::dba::bitvector*>(
      ::dba::bitvector::internal_default_instance());
  _dbaexpr_default_instance_.get_mutable()->expr1_ = const_cast< ::dba::dbaexpr*>(
      ::dba::dbaexpr::internal_default_instance());
  _dbaexpr_default_instance_.get_mutable()->expr2_ = const_cast< ::dba::dbaexpr*>(
      ::dba::dbaexpr::internal_default_instance());
  _dbaexpr_default_instance_.get_mutable()->cond_ = const_cast< ::dba::dbacond*>(
      ::dba::dbacond::internal_default_instance());
  _dbacond_default_instance_.get_mutable()->expr_ = const_cast< ::dba::dbaexpr*>(
      ::dba::dbaexpr::internal_default_instance());
  _dbacond_default_instance_.get_mutable()->cond1_ = const_cast< ::dba::dbacond*>(
      ::dba::dbacond::internal_default_instance());
  _dbacond_default_instance_.get_mutable()->cond2_ = const_cast< ::dba::dbacond*>(
      ::dba::dbacond::internal_default_instance());
  _dbaLhs_default_instance_.get_mutable()->expr_ = const_cast< ::dba::dbaexpr*>(
      ::dba::dbaexpr::internal_default_instance());
  _dbainstr_default_instance_.get_mutable()->location_ = const_cast< ::dba::dbacodeaddress*>(
      ::dba::dbacodeaddress::internal_default_instance());
  _dbainstr_default_instance_.get_mutable()->lhs_ = const_cast< ::dba::dbaLhs*>(
      ::dba::dbaLhs::internal_default_instance());
  _dbainstr_default_instance_.get_mutable()->expr_ = const_cast< ::dba::dbaexpr*>(
      ::dba::dbaexpr::internal_default_instance());
  _dbainstr_default_instance_.get_mutable()->address_ = const_cast< ::dba::codeaddress*>(
      ::dba::codeaddress::internal_default_instance());
  _dbainstr_default_instance_.get_mutable()->tags_ = const_cast< ::dba::dbatag*>(
      ::dba::dbatag::internal_default_instance());
  _dbainstr_default_instance_.get_mutable()->cond_ = const_cast< ::dba::dbacond*>(
      ::dba::dbacond::internal_default_instance());
  _dbainstr_default_instance_.get_mutable()->stopinfos_ = const_cast< ::dba::dbastopstate*>(
      ::dba::dbastopstate::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n\tdba.proto\022\003dba\"%\n\tbitvector\022\n\n\002bv\030\001 \002("
      "\004\022\014\n\004size\030\002 \002(\r\"F\n\016dbacodeaddress\022!\n\tbit"
      "vector\030\001 \002(\0132\016.dba.bitvector\022\021\n\tdbaoffse"
      "t\030\002 \002(\r\"\247\001\n\013codeaddress\0223\n\006typeid\030\001 \002(\0162"
      "#.dba.codeaddress.typeid_codeaddress\022\016\n\006"
      "offset\030\002 \001(\r\022$\n\007address\030\003 \001(\0132\023.dba.dbac"
      "odeaddress\"-\n\022typeid_codeaddress\022\t\n\005Loca"
      "l\020\000\022\014\n\010NonLocal\020\001\"\206\001\n\006dbatag\022)\n\006typeid\030\001"
      " \002(\0162\031.dba.dbatag.typeid_dbatag\022$\n\007addre"
      "ss\030\002 \001(\0132\023.dba.dbacodeaddress\"+\n\rtypeid_"
      "dbatag\022\013\n\007DbaCall\020\001\022\r\n\tDbaReturn\020\002\"\223\001\n\014d"
      "bastopstate\0221\n\006typeid\030\001 \002(\0162!.dba.dbasto"
      "pstate.typeid_dbastate\022\r\n\005infos\030\002 \001(\t\"A\n"
      "\017typeid_dbastate\022\006\n\002Ok\020\001\022\006\n\002Ko\020\002\022\r\n\tUnde"
      "fined\020\003\022\017\n\013Unsupported\020\004\"\313\007\n\007dbaexpr\022+\n\006"
      "typeid\030\001 \002(\0162\033.dba.dbaexpr.typeid_dbaexp"
      "r\022\014\n\004name\030\002 \001(\t\022\014\n\004size\030\003 \001(\r\022\037\n\006endian\030"
      "\004 \001(\0162\017.dba.endianness\022!\n\tbitvector\030\005 \001("
      "\0132\016.dba.bitvector\022\033\n\005expr1\030\006 \001(\0132\014.dba.d"
      "baexpr\022\033\n\005expr2\030\007 \001(\0132\014.dba.dbaexpr\022&\n\007u"
      "naryop\030\t \001(\0162\025.dba.dbaexpr.dbaunary\022(\n\010b"
      "inaryop\030\n \001(\0162\026.dba.dbaexpr.dbabinary\022\013\n"
      "\003low\030\013 \001(\r\022\014\n\004high\030\014 \001(\r\022\032\n\004cond\030\r \001(\0132\014"
      ".dba.dbacond\"\301\001\n\016typeid_dbaexpr\022\016\n\nDbaEx"
      "prVar\020\001\022\013\n\007DbaLoad\020\002\022\016\n\nDbaExprCst\020\003\022\020\n\014"
      "DbaExprUnary\020\004\022\021\n\rDbaExprBinary\020\005\022\023\n\017Dba"
      "ExprRestrict\020\006\022\017\n\013DbaExprExtU\020\007\022\017\n\013DbaEx"
      "prExtS\020\010\022\016\n\nDbaExprIte\020\t\022\026\n\022DbaExprAlter"
      "native\020\n\".\n\010dbaunary\022\021\n\rDbaUnaryMinus\020\001\022"
      "\017\n\013DbaUnaryNot\020\002\"\373\002\n\tdbabinary\022\013\n\007DbaPlu"
      "s\020\001\022\014\n\010DbaMinus\020\002\022\014\n\010DbaMultU\020\003\022\014\n\010DbaMu"
      "ltS\020\004\022\013\n\007DbaDivU\020\006\022\013\n\007DbaDivS\020\007\022\013\n\007DbaMo"
      "dU\020\010\022\013\n\007DbaModS\020\t\022\t\n\005DbaOr\020\n\022\n\n\006DbaAnd\020\013"
      "\022\n\n\006DbaXor\020\014\022\r\n\tDbaConcat\020\r\022\016\n\nDbaLShift"
      "U\020\016\022\016\n\nDbaRShiftU\020\017\022\016\n\nDbaRShiftS\020\020\022\021\n\rD"
      "baLeftRotate\020\021\022\022\n\016DbaRightRotate\020\022\022\t\n\005Db"
      "aEq\020\023\022\013\n\007DbaDiff\020\024\022\013\n\007DbaLeqU\020\025\022\n\n\006DbaLt"
      "U\020\026\022\013\n\007DbaGeqU\020\027\022\n\n\006DbaGtU\020\030\022\013\n\007DbaLeqS\020"
      "\031\022\n\n\006DbaLtS\020\032\022\013\n\007DbaGeqS\020\033\022\n\n\006DbaGtS\020\034\"\371"
      "\001\n\007dbacond\022+\n\006typeid\030\001 \002(\0162\033.dba.dbacond"
      ".typeid_dbacond\022\032\n\004expr\030\002 \001(\0132\014.dba.dbae"
      "xpr\022\033\n\005cond1\030\003 \001(\0132\014.dba.dbacond\022\033\n\005cond"
      "2\030\004 \001(\0132\014.dba.dbacond\"k\n\016typeid_dbacond\022"
      "\017\n\013DbaCondReif\020\001\022\016\n\nDbaCondNot\020\002\022\016\n\nDbaC"
      "ondAnd\020\003\022\r\n\tDbaCondOr\020\004\022\013\n\007DbaTrue\020\005\022\014\n\010"
      "DbaFalse\020\006\"\354\001\n\006dbaLhs\022)\n\006typeid\030\001 \002(\0162\031."
      "dba.dbaLhs.typeid_dbalhs\022\014\n\004name\030\002 \001(\t\022\014"
      "\n\004size\030\003 \001(\r\022\013\n\003low\030\004 \001(\r\022\014\n\004high\030\005 \001(\r\022"
      "\037\n\006endian\030\006 \001(\0162\017.dba.endianness\022\032\n\004expr"
      "\030\007 \001(\0132\014.dba.dbaexpr\"C\n\rtypeid_dbalhs\022\r\n"
      "\tDbaLhsVar\020\001\022\025\n\021DbaLhsVarRestrict\020\002\022\014\n\010D"
      "baStore\020\003\"\260\004\n\010dbainstr\022.\n\006typeid\030\001 \002(\0162\036"
      ".dba.dbainstr.typeid_instrkind\022%\n\010locati"
      "on\030\002 \002(\0132\023.dba.dbacodeaddress\022\030\n\003lhs\030\003 \001"
      "(\0132\013.dba.dbaLhs\022\032\n\004expr\030\004 \001(\0132\014.dba.dbae"
      "xpr\022\016\n\006offset\030\005 \001(\r\022!\n\007address\030\006 \001(\0132\020.d"
      "ba.codeaddress\022\031\n\004tags\030\007 \001(\0132\013.dba.dbata"
      "g\022\032\n\004cond\030\010 \001(\0132\014.dba.dbacond\022$\n\tstopinf"
      "os\030\t \001(\0132\021.dba.dbastopstate\022\033\n\005exprs\030\n \003"
      "(\0132\014.dba.dbaexpr\"\351\001\n\020typeid_instrkind\022\017\n"
      "\013DbaIkAssign\020\001\022\016\n\nDbaIkSJump\020\002\022\016\n\nDbaIkD"
      "Jump\020\003\022\013\n\007DbaIkIf\020\004\022\r\n\tDbaIkStop\020\005\022\017\n\013Db"
      "aIkAssert\020\006\022\017\n\013DbaIkAssume\020\007\022\025\n\021DbaIkNon"
      "detAssume\020\010\022\017\n\013DbaIkNondet\020\t\022\016\n\nDbaIkUnd"
      "ef\020\n\022\017\n\013DbaIkMalloc\020\013\022\r\n\tDbaIkFree\020\014\022\016\n\n"
      "DbaIkPrint\020\r\")\n\010dba_list\022\035\n\006instrs\030\001 \003(\013"
      "2\r.dba.dbainstr*!\n\nendianness\022\n\n\006Little\020"
      "\001\022\007\n\003Big\020\002"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 2690);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "dba.proto", &protobuf_RegisterTypes);
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_dba_2eproto

const ::google::protobuf::EnumDescriptor* codeaddress_typeid_codeaddress_descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_enum_descriptors[0];
}
bool codeaddress_typeid_codeaddress_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const codeaddress_typeid_codeaddress codeaddress::Local;
const codeaddress_typeid_codeaddress codeaddress::NonLocal;
const codeaddress_typeid_codeaddress codeaddress::typeid_codeaddress_MIN;
const codeaddress_typeid_codeaddress codeaddress::typeid_codeaddress_MAX;
const int codeaddress::typeid_codeaddress_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* dbatag_typeid_dbatag_descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_enum_descriptors[1];
}
bool dbatag_typeid_dbatag_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const dbatag_typeid_dbatag dbatag::DbaCall;
const dbatag_typeid_dbatag dbatag::DbaReturn;
const dbatag_typeid_dbatag dbatag::typeid_dbatag_MIN;
const dbatag_typeid_dbatag dbatag::typeid_dbatag_MAX;
const int dbatag::typeid_dbatag_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* dbastopstate_typeid_dbastate_descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_enum_descriptors[2];
}
bool dbastopstate_typeid_dbastate_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const dbastopstate_typeid_dbastate dbastopstate::Ok;
const dbastopstate_typeid_dbastate dbastopstate::Ko;
const dbastopstate_typeid_dbastate dbastopstate::Undefined;
const dbastopstate_typeid_dbastate dbastopstate::Unsupported;
const dbastopstate_typeid_dbastate dbastopstate::typeid_dbastate_MIN;
const dbastopstate_typeid_dbastate dbastopstate::typeid_dbastate_MAX;
const int dbastopstate::typeid_dbastate_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* dbaexpr_typeid_dbaexpr_descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_enum_descriptors[3];
}
bool dbaexpr_typeid_dbaexpr_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const dbaexpr_typeid_dbaexpr dbaexpr::DbaExprVar;
const dbaexpr_typeid_dbaexpr dbaexpr::DbaLoad;
const dbaexpr_typeid_dbaexpr dbaexpr::DbaExprCst;
const dbaexpr_typeid_dbaexpr dbaexpr::DbaExprUnary;
const dbaexpr_typeid_dbaexpr dbaexpr::DbaExprBinary;
const dbaexpr_typeid_dbaexpr dbaexpr::DbaExprRestrict;
const dbaexpr_typeid_dbaexpr dbaexpr::DbaExprExtU;
const dbaexpr_typeid_dbaexpr dbaexpr::DbaExprExtS;
const dbaexpr_typeid_dbaexpr dbaexpr::DbaExprIte;
const dbaexpr_typeid_dbaexpr dbaexpr::DbaExprAlternative;
const dbaexpr_typeid_dbaexpr dbaexpr::typeid_dbaexpr_MIN;
const dbaexpr_typeid_dbaexpr dbaexpr::typeid_dbaexpr_MAX;
const int dbaexpr::typeid_dbaexpr_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* dbaexpr_dbaunary_descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_enum_descriptors[4];
}
bool dbaexpr_dbaunary_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const dbaexpr_dbaunary dbaexpr::DbaUnaryMinus;
const dbaexpr_dbaunary dbaexpr::DbaUnaryNot;
const dbaexpr_dbaunary dbaexpr::dbaunary_MIN;
const dbaexpr_dbaunary dbaexpr::dbaunary_MAX;
const int dbaexpr::dbaunary_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* dbaexpr_dbabinary_descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_enum_descriptors[5];
}
bool dbaexpr_dbabinary_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const dbaexpr_dbabinary dbaexpr::DbaPlus;
const dbaexpr_dbabinary dbaexpr::DbaMinus;
const dbaexpr_dbabinary dbaexpr::DbaMultU;
const dbaexpr_dbabinary dbaexpr::DbaMultS;
const dbaexpr_dbabinary dbaexpr::DbaDivU;
const dbaexpr_dbabinary dbaexpr::DbaDivS;
const dbaexpr_dbabinary dbaexpr::DbaModU;
const dbaexpr_dbabinary dbaexpr::DbaModS;
const dbaexpr_dbabinary dbaexpr::DbaOr;
const dbaexpr_dbabinary dbaexpr::DbaAnd;
const dbaexpr_dbabinary dbaexpr::DbaXor;
const dbaexpr_dbabinary dbaexpr::DbaConcat;
const dbaexpr_dbabinary dbaexpr::DbaLShiftU;
const dbaexpr_dbabinary dbaexpr::DbaRShiftU;
const dbaexpr_dbabinary dbaexpr::DbaRShiftS;
const dbaexpr_dbabinary dbaexpr::DbaLeftRotate;
const dbaexpr_dbabinary dbaexpr::DbaRightRotate;
const dbaexpr_dbabinary dbaexpr::DbaEq;
const dbaexpr_dbabinary dbaexpr::DbaDiff;
const dbaexpr_dbabinary dbaexpr::DbaLeqU;
const dbaexpr_dbabinary dbaexpr::DbaLtU;
const dbaexpr_dbabinary dbaexpr::DbaGeqU;
const dbaexpr_dbabinary dbaexpr::DbaGtU;
const dbaexpr_dbabinary dbaexpr::DbaLeqS;
const dbaexpr_dbabinary dbaexpr::DbaLtS;
const dbaexpr_dbabinary dbaexpr::DbaGeqS;
const dbaexpr_dbabinary dbaexpr::DbaGtS;
const dbaexpr_dbabinary dbaexpr::dbabinary_MIN;
const dbaexpr_dbabinary dbaexpr::dbabinary_MAX;
const int dbaexpr::dbabinary_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* dbacond_typeid_dbacond_descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_enum_descriptors[6];
}
bool dbacond_typeid_dbacond_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const dbacond_typeid_dbacond dbacond::DbaCondReif;
const dbacond_typeid_dbacond dbacond::DbaCondNot;
const dbacond_typeid_dbacond dbacond::DbaCondAnd;
const dbacond_typeid_dbacond dbacond::DbaCondOr;
const dbacond_typeid_dbacond dbacond::DbaTrue;
const dbacond_typeid_dbacond dbacond::DbaFalse;
const dbacond_typeid_dbacond dbacond::typeid_dbacond_MIN;
const dbacond_typeid_dbacond dbacond::typeid_dbacond_MAX;
const int dbacond::typeid_dbacond_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* dbaLhs_typeid_dbalhs_descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_enum_descriptors[7];
}
bool dbaLhs_typeid_dbalhs_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const dbaLhs_typeid_dbalhs dbaLhs::DbaLhsVar;
const dbaLhs_typeid_dbalhs dbaLhs::DbaLhsVarRestrict;
const dbaLhs_typeid_dbalhs dbaLhs::DbaStore;
const dbaLhs_typeid_dbalhs dbaLhs::typeid_dbalhs_MIN;
const dbaLhs_typeid_dbalhs dbaLhs::typeid_dbalhs_MAX;
const int dbaLhs::typeid_dbalhs_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* dbainstr_typeid_instrkind_descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_enum_descriptors[8];
}
bool dbainstr_typeid_instrkind_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const dbainstr_typeid_instrkind dbainstr::DbaIkAssign;
const dbainstr_typeid_instrkind dbainstr::DbaIkSJump;
const dbainstr_typeid_instrkind dbainstr::DbaIkDJump;
const dbainstr_typeid_instrkind dbainstr::DbaIkIf;
const dbainstr_typeid_instrkind dbainstr::DbaIkStop;
const dbainstr_typeid_instrkind dbainstr::DbaIkAssert;
const dbainstr_typeid_instrkind dbainstr::DbaIkAssume;
const dbainstr_typeid_instrkind dbainstr::DbaIkNondetAssume;
const dbainstr_typeid_instrkind dbainstr::DbaIkNondet;
const dbainstr_typeid_instrkind dbainstr::DbaIkUndef;
const dbainstr_typeid_instrkind dbainstr::DbaIkMalloc;
const dbainstr_typeid_instrkind dbainstr::DbaIkFree;
const dbainstr_typeid_instrkind dbainstr::DbaIkPrint;
const dbainstr_typeid_instrkind dbainstr::typeid_instrkind_MIN;
const dbainstr_typeid_instrkind dbainstr::typeid_instrkind_MAX;
const int dbainstr::typeid_instrkind_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* endianness_descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_enum_descriptors[9];
}
bool endianness_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int bitvector::kBvFieldNumber;
const int bitvector::kSizeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

bitvector::bitvector()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_dba_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.bitvector)
}
bitvector::bitvector(const bitvector& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&bv_, &from.bv_,
    reinterpret_cast<char*>(&size_) -
    reinterpret_cast<char*>(&bv_) + sizeof(size_));
  // @@protoc_insertion_point(copy_constructor:dba.bitvector)
}

void bitvector::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&bv_, 0, reinterpret_cast<char*>(&size_) -
    reinterpret_cast<char*>(&bv_) + sizeof(size_));
}

bitvector::~bitvector() {
  // @@protoc_insertion_point(destructor:dba.bitvector)
  SharedDtor();
}

void bitvector::SharedDtor() {
}

void bitvector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* bitvector::descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[0].descriptor;
}

const bitvector& bitvector::default_instance() {
  protobuf_dba_2eproto::InitDefaults();
  return *internal_default_instance();
}

bitvector* bitvector::New(::google::protobuf::Arena* arena) const {
  bitvector* n = new bitvector;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void bitvector::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.bitvector)
  if (_has_bits_[0 / 32] & 3u) {
    ::memset(&bv_, 0, reinterpret_cast<char*>(&size_) -
      reinterpret_cast<char*>(&bv_) + sizeof(size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool bitvector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.bitvector)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 bv = 1;
      case 1: {
        if (tag == 8u) {
          set_has_bv();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bv_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 size = 2;
      case 2: {
        if (tag == 16u) {
          set_has_size();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.bitvector)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.bitvector)
  return false;
#undef DO_
}

void bitvector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.bitvector)
  // required uint64 bv = 1;
  if (has_bv()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->bv(), output);
  }

  // required uint32 size = 2;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->size(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.bitvector)
}

::google::protobuf::uint8* bitvector::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:dba.bitvector)
  // required uint64 bv = 1;
  if (has_bv()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->bv(), target);
  }

  // required uint32 size = 2;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->size(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.bitvector)
  return target;
}

size_t bitvector::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:dba.bitvector)
  size_t total_size = 0;

  if (has_bv()) {
    // required uint64 bv = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->bv());
  }

  if (has_size()) {
    // required uint32 size = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->size());
  }

  return total_size;
}
size_t bitvector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.bitvector)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 bv = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->bv());

    // required uint32 size = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->size());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void bitvector::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.bitvector)
  GOOGLE_DCHECK_NE(&from, this);
  const bitvector* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const bitvector>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.bitvector)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.bitvector)
    MergeFrom(*source);
  }
}

void bitvector::MergeFrom(const bitvector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.bitvector)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._has_bits_[0 / 32] & 3u) {
    if (from.has_bv()) {
      set_bv(from.bv());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
}

void bitvector::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.bitvector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void bitvector::CopyFrom(const bitvector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.bitvector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool bitvector::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void bitvector::Swap(bitvector* other) {
  if (other == this) return;
  InternalSwap(other);
}
void bitvector::InternalSwap(bitvector* other) {
  std::swap(bv_, other->bv_);
  std::swap(size_, other->size_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata bitvector::GetMetadata() const {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[0];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// bitvector

// required uint64 bv = 1;
bool bitvector::has_bv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void bitvector::set_has_bv() {
  _has_bits_[0] |= 0x00000001u;
}
void bitvector::clear_has_bv() {
  _has_bits_[0] &= ~0x00000001u;
}
void bitvector::clear_bv() {
  bv_ = GOOGLE_ULONGLONG(0);
  clear_has_bv();
}
::google::protobuf::uint64 bitvector::bv() const {
  // @@protoc_insertion_point(field_get:dba.bitvector.bv)
  return bv_;
}
void bitvector::set_bv(::google::protobuf::uint64 value) {
  set_has_bv();
  bv_ = value;
  // @@protoc_insertion_point(field_set:dba.bitvector.bv)
}

// required uint32 size = 2;
bool bitvector::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void bitvector::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
void bitvector::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
void bitvector::clear_size() {
  size_ = 0u;
  clear_has_size();
}
::google::protobuf::uint32 bitvector::size() const {
  // @@protoc_insertion_point(field_get:dba.bitvector.size)
  return size_;
}
void bitvector::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:dba.bitvector.size)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int dbacodeaddress::kBitvectorFieldNumber;
const int dbacodeaddress::kDbaoffsetFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

dbacodeaddress::dbacodeaddress()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_dba_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.dbacodeaddress)
}
dbacodeaddress::dbacodeaddress(const dbacodeaddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_bitvector()) {
    bitvector_ = new ::dba::bitvector(*from.bitvector_);
  } else {
    bitvector_ = NULL;
  }
  dbaoffset_ = from.dbaoffset_;
  // @@protoc_insertion_point(copy_constructor:dba.dbacodeaddress)
}

void dbacodeaddress::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&bitvector_, 0, reinterpret_cast<char*>(&dbaoffset_) -
    reinterpret_cast<char*>(&bitvector_) + sizeof(dbaoffset_));
}

dbacodeaddress::~dbacodeaddress() {
  // @@protoc_insertion_point(destructor:dba.dbacodeaddress)
  SharedDtor();
}

void dbacodeaddress::SharedDtor() {
  if (this != internal_default_instance()) {
    delete bitvector_;
  }
}

void dbacodeaddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* dbacodeaddress::descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[1].descriptor;
}

const dbacodeaddress& dbacodeaddress::default_instance() {
  protobuf_dba_2eproto::InitDefaults();
  return *internal_default_instance();
}

dbacodeaddress* dbacodeaddress::New(::google::protobuf::Arena* arena) const {
  dbacodeaddress* n = new dbacodeaddress;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void dbacodeaddress::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.dbacodeaddress)
  if (has_bitvector()) {
    GOOGLE_DCHECK(bitvector_ != NULL);
    bitvector_->::dba::bitvector::Clear();
  }
  dbaoffset_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool dbacodeaddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.dbacodeaddress)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .dba.bitvector bitvector = 1;
      case 1: {
        if (tag == 10u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bitvector()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 dbaoffset = 2;
      case 2: {
        if (tag == 16u) {
          set_has_dbaoffset();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dbaoffset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.dbacodeaddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.dbacodeaddress)
  return false;
#undef DO_
}

void dbacodeaddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.dbacodeaddress)
  // required .dba.bitvector bitvector = 1;
  if (has_bitvector()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->bitvector_, output);
  }

  // required uint32 dbaoffset = 2;
  if (has_dbaoffset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->dbaoffset(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.dbacodeaddress)
}

::google::protobuf::uint8* dbacodeaddress::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:dba.dbacodeaddress)
  // required .dba.bitvector bitvector = 1;
  if (has_bitvector()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->bitvector_, false, target);
  }

  // required uint32 dbaoffset = 2;
  if (has_dbaoffset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->dbaoffset(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.dbacodeaddress)
  return target;
}

size_t dbacodeaddress::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:dba.dbacodeaddress)
  size_t total_size = 0;

  if (has_bitvector()) {
    // required .dba.bitvector bitvector = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->bitvector_);
  }

  if (has_dbaoffset()) {
    // required uint32 dbaoffset = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->dbaoffset());
  }

  return total_size;
}
size_t dbacodeaddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.dbacodeaddress)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .dba.bitvector bitvector = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->bitvector_);

    // required uint32 dbaoffset = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->dbaoffset());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void dbacodeaddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.dbacodeaddress)
  GOOGLE_DCHECK_NE(&from, this);
  const dbacodeaddress* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const dbacodeaddress>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.dbacodeaddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.dbacodeaddress)
    MergeFrom(*source);
  }
}

void dbacodeaddress::MergeFrom(const dbacodeaddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.dbacodeaddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._has_bits_[0 / 32] & 3u) {
    if (from.has_bitvector()) {
      mutable_bitvector()->::dba::bitvector::MergeFrom(from.bitvector());
    }
    if (from.has_dbaoffset()) {
      set_dbaoffset(from.dbaoffset());
    }
  }
}

void dbacodeaddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.dbacodeaddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void dbacodeaddress::CopyFrom(const dbacodeaddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.dbacodeaddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool dbacodeaddress::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  if (has_bitvector()) {
    if (!this->bitvector_->IsInitialized()) return false;
  }
  return true;
}

void dbacodeaddress::Swap(dbacodeaddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void dbacodeaddress::InternalSwap(dbacodeaddress* other) {
  std::swap(bitvector_, other->bitvector_);
  std::swap(dbaoffset_, other->dbaoffset_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata dbacodeaddress::GetMetadata() const {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[1];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// dbacodeaddress

// required .dba.bitvector bitvector = 1;
bool dbacodeaddress::has_bitvector() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void dbacodeaddress::set_has_bitvector() {
  _has_bits_[0] |= 0x00000001u;
}
void dbacodeaddress::clear_has_bitvector() {
  _has_bits_[0] &= ~0x00000001u;
}
void dbacodeaddress::clear_bitvector() {
  if (bitvector_ != NULL) bitvector_->::dba::bitvector::Clear();
  clear_has_bitvector();
}
const ::dba::bitvector& dbacodeaddress::bitvector() const {
  // @@protoc_insertion_point(field_get:dba.dbacodeaddress.bitvector)
  return bitvector_ != NULL ? *bitvector_
                         : *::dba::bitvector::internal_default_instance();
}
::dba::bitvector* dbacodeaddress::mutable_bitvector() {
  set_has_bitvector();
  if (bitvector_ == NULL) {
    bitvector_ = new ::dba::bitvector;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbacodeaddress.bitvector)
  return bitvector_;
}
::dba::bitvector* dbacodeaddress::release_bitvector() {
  // @@protoc_insertion_point(field_release:dba.dbacodeaddress.bitvector)
  clear_has_bitvector();
  ::dba::bitvector* temp = bitvector_;
  bitvector_ = NULL;
  return temp;
}
void dbacodeaddress::set_allocated_bitvector(::dba::bitvector* bitvector) {
  delete bitvector_;
  bitvector_ = bitvector;
  if (bitvector) {
    set_has_bitvector();
  } else {
    clear_has_bitvector();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbacodeaddress.bitvector)
}

// required uint32 dbaoffset = 2;
bool dbacodeaddress::has_dbaoffset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void dbacodeaddress::set_has_dbaoffset() {
  _has_bits_[0] |= 0x00000002u;
}
void dbacodeaddress::clear_has_dbaoffset() {
  _has_bits_[0] &= ~0x00000002u;
}
void dbacodeaddress::clear_dbaoffset() {
  dbaoffset_ = 0u;
  clear_has_dbaoffset();
}
::google::protobuf::uint32 dbacodeaddress::dbaoffset() const {
  // @@protoc_insertion_point(field_get:dba.dbacodeaddress.dbaoffset)
  return dbaoffset_;
}
void dbacodeaddress::set_dbaoffset(::google::protobuf::uint32 value) {
  set_has_dbaoffset();
  dbaoffset_ = value;
  // @@protoc_insertion_point(field_set:dba.dbacodeaddress.dbaoffset)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int codeaddress::kTypeidFieldNumber;
const int codeaddress::kOffsetFieldNumber;
const int codeaddress::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

codeaddress::codeaddress()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_dba_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.codeaddress)
}
codeaddress::codeaddress(const codeaddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_address()) {
    address_ = new ::dba::dbacodeaddress(*from.address_);
  } else {
    address_ = NULL;
  }
  ::memcpy(&typeid__, &from.typeid__,
    reinterpret_cast<char*>(&offset_) -
    reinterpret_cast<char*>(&typeid__) + sizeof(offset_));
  // @@protoc_insertion_point(copy_constructor:dba.codeaddress)
}

void codeaddress::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&address_, 0, reinterpret_cast<char*>(&offset_) -
    reinterpret_cast<char*>(&address_) + sizeof(offset_));
}

codeaddress::~codeaddress() {
  // @@protoc_insertion_point(destructor:dba.codeaddress)
  SharedDtor();
}

void codeaddress::SharedDtor() {
  if (this != internal_default_instance()) {
    delete address_;
  }
}

void codeaddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* codeaddress::descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[2].descriptor;
}

const codeaddress& codeaddress::default_instance() {
  protobuf_dba_2eproto::InitDefaults();
  return *internal_default_instance();
}

codeaddress* codeaddress::New(::google::protobuf::Arena* arena) const {
  codeaddress* n = new codeaddress;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void codeaddress::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.codeaddress)
  if (has_address()) {
    GOOGLE_DCHECK(address_ != NULL);
    address_->::dba::dbacodeaddress::Clear();
  }
  if (_has_bits_[0 / 32] & 6u) {
    ::memset(&typeid__, 0, reinterpret_cast<char*>(&offset_) -
      reinterpret_cast<char*>(&typeid__) + sizeof(offset_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool codeaddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.codeaddress)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .dba.codeaddress.typeid_codeaddress typeid = 1;
      case 1: {
        if (tag == 8u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::codeaddress_typeid_codeaddress_IsValid(value)) {
            set_typeid_(static_cast< ::dba::codeaddress_typeid_codeaddress >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 offset = 2;
      case 2: {
        if (tag == 16u) {
          set_has_offset();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbacodeaddress address = 3;
      case 3: {
        if (tag == 26u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_address()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.codeaddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.codeaddress)
  return false;
#undef DO_
}

void codeaddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.codeaddress)
  // required .dba.codeaddress.typeid_codeaddress typeid = 1;
  if (has_typeid_()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  // optional uint32 offset = 2;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->offset(), output);
  }

  // optional .dba.dbacodeaddress address = 3;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->address_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.codeaddress)
}

::google::protobuf::uint8* codeaddress::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:dba.codeaddress)
  // required .dba.codeaddress.typeid_codeaddress typeid = 1;
  if (has_typeid_()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  // optional uint32 offset = 2;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->offset(), target);
  }

  // optional .dba.dbacodeaddress address = 3;
  if (has_address()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->address_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.codeaddress)
  return target;
}

size_t codeaddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.codeaddress)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .dba.codeaddress.typeid_codeaddress typeid = 1;
  if (has_typeid_()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->typeid_());
  }
  // optional .dba.dbacodeaddress address = 3;
  if (has_address()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->address_);
  }

  // optional uint32 offset = 2;
  if (has_offset()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->offset());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void codeaddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.codeaddress)
  GOOGLE_DCHECK_NE(&from, this);
  const codeaddress* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const codeaddress>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.codeaddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.codeaddress)
    MergeFrom(*source);
  }
}

void codeaddress::MergeFrom(const codeaddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.codeaddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._has_bits_[0 / 32] & 7u) {
    if (from.has_address()) {
      mutable_address()->::dba::dbacodeaddress::MergeFrom(from.address());
    }
    if (from.has_typeid_()) {
      set_typeid_(from.typeid_());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
  }
}

void codeaddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.codeaddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void codeaddress::CopyFrom(const codeaddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.codeaddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool codeaddress::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (has_address()) {
    if (!this->address_->IsInitialized()) return false;
  }
  return true;
}

void codeaddress::Swap(codeaddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void codeaddress::InternalSwap(codeaddress* other) {
  std::swap(address_, other->address_);
  std::swap(typeid__, other->typeid__);
  std::swap(offset_, other->offset_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata codeaddress::GetMetadata() const {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[2];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// codeaddress

// required .dba.codeaddress.typeid_codeaddress typeid = 1;
bool codeaddress::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void codeaddress::set_has_typeid_() {
  _has_bits_[0] |= 0x00000002u;
}
void codeaddress::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000002u;
}
void codeaddress::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
::dba::codeaddress_typeid_codeaddress codeaddress::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.codeaddress.typeid)
  return static_cast< ::dba::codeaddress_typeid_codeaddress >(typeid__);
}
void codeaddress::set_typeid_(::dba::codeaddress_typeid_codeaddress value) {
  assert(::dba::codeaddress_typeid_codeaddress_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.codeaddress.typeid)
}

// optional uint32 offset = 2;
bool codeaddress::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void codeaddress::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
void codeaddress::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
void codeaddress::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
::google::protobuf::uint32 codeaddress::offset() const {
  // @@protoc_insertion_point(field_get:dba.codeaddress.offset)
  return offset_;
}
void codeaddress::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:dba.codeaddress.offset)
}

// optional .dba.dbacodeaddress address = 3;
bool codeaddress::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void codeaddress::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
void codeaddress::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
void codeaddress::clear_address() {
  if (address_ != NULL) address_->::dba::dbacodeaddress::Clear();
  clear_has_address();
}
const ::dba::dbacodeaddress& codeaddress::address() const {
  // @@protoc_insertion_point(field_get:dba.codeaddress.address)
  return address_ != NULL ? *address_
                         : *::dba::dbacodeaddress::internal_default_instance();
}
::dba::dbacodeaddress* codeaddress::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    address_ = new ::dba::dbacodeaddress;
  }
  // @@protoc_insertion_point(field_mutable:dba.codeaddress.address)
  return address_;
}
::dba::dbacodeaddress* codeaddress::release_address() {
  // @@protoc_insertion_point(field_release:dba.codeaddress.address)
  clear_has_address();
  ::dba::dbacodeaddress* temp = address_;
  address_ = NULL;
  return temp;
}
void codeaddress::set_allocated_address(::dba::dbacodeaddress* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.codeaddress.address)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int dbatag::kTypeidFieldNumber;
const int dbatag::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

dbatag::dbatag()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_dba_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.dbatag)
}
dbatag::dbatag(const dbatag& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_address()) {
    address_ = new ::dba::dbacodeaddress(*from.address_);
  } else {
    address_ = NULL;
  }
  typeid__ = from.typeid__;
  // @@protoc_insertion_point(copy_constructor:dba.dbatag)
}

void dbatag::SharedCtor() {
  _cached_size_ = 0;
  address_ = NULL;
  typeid__ = 1;
}

dbatag::~dbatag() {
  // @@protoc_insertion_point(destructor:dba.dbatag)
  SharedDtor();
}

void dbatag::SharedDtor() {
  if (this != internal_default_instance()) {
    delete address_;
  }
}

void dbatag::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* dbatag::descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[3].descriptor;
}

const dbatag& dbatag::default_instance() {
  protobuf_dba_2eproto::InitDefaults();
  return *internal_default_instance();
}

dbatag* dbatag::New(::google::protobuf::Arena* arena) const {
  dbatag* n = new dbatag;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void dbatag::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.dbatag)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_address()) {
      GOOGLE_DCHECK(address_ != NULL);
      address_->::dba::dbacodeaddress::Clear();
    }
    typeid__ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool dbatag::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.dbatag)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .dba.dbatag.typeid_dbatag typeid = 1;
      case 1: {
        if (tag == 8u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::dbatag_typeid_dbatag_IsValid(value)) {
            set_typeid_(static_cast< ::dba::dbatag_typeid_dbatag >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbacodeaddress address = 2;
      case 2: {
        if (tag == 18u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_address()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.dbatag)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.dbatag)
  return false;
#undef DO_
}

void dbatag::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.dbatag)
  // required .dba.dbatag.typeid_dbatag typeid = 1;
  if (has_typeid_()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  // optional .dba.dbacodeaddress address = 2;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->address_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.dbatag)
}

::google::protobuf::uint8* dbatag::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:dba.dbatag)
  // required .dba.dbatag.typeid_dbatag typeid = 1;
  if (has_typeid_()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  // optional .dba.dbacodeaddress address = 2;
  if (has_address()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->address_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.dbatag)
  return target;
}

size_t dbatag::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.dbatag)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .dba.dbatag.typeid_dbatag typeid = 1;
  if (has_typeid_()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->typeid_());
  }
  // optional .dba.dbacodeaddress address = 2;
  if (has_address()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->address_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void dbatag::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.dbatag)
  GOOGLE_DCHECK_NE(&from, this);
  const dbatag* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const dbatag>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.dbatag)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.dbatag)
    MergeFrom(*source);
  }
}

void dbatag::MergeFrom(const dbatag& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.dbatag)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._has_bits_[0 / 32] & 3u) {
    if (from.has_address()) {
      mutable_address()->::dba::dbacodeaddress::MergeFrom(from.address());
    }
    if (from.has_typeid_()) {
      set_typeid_(from.typeid_());
    }
  }
}

void dbatag::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.dbatag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void dbatag::CopyFrom(const dbatag& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.dbatag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool dbatag::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (has_address()) {
    if (!this->address_->IsInitialized()) return false;
  }
  return true;
}

void dbatag::Swap(dbatag* other) {
  if (other == this) return;
  InternalSwap(other);
}
void dbatag::InternalSwap(dbatag* other) {
  std::swap(address_, other->address_);
  std::swap(typeid__, other->typeid__);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata dbatag::GetMetadata() const {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[3];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// dbatag

// required .dba.dbatag.typeid_dbatag typeid = 1;
bool dbatag::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void dbatag::set_has_typeid_() {
  _has_bits_[0] |= 0x00000002u;
}
void dbatag::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000002u;
}
void dbatag::clear_typeid_() {
  typeid__ = 1;
  clear_has_typeid_();
}
::dba::dbatag_typeid_dbatag dbatag::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbatag.typeid)
  return static_cast< ::dba::dbatag_typeid_dbatag >(typeid__);
}
void dbatag::set_typeid_(::dba::dbatag_typeid_dbatag value) {
  assert(::dba::dbatag_typeid_dbatag_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbatag.typeid)
}

// optional .dba.dbacodeaddress address = 2;
bool dbatag::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void dbatag::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
void dbatag::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
void dbatag::clear_address() {
  if (address_ != NULL) address_->::dba::dbacodeaddress::Clear();
  clear_has_address();
}
const ::dba::dbacodeaddress& dbatag::address() const {
  // @@protoc_insertion_point(field_get:dba.dbatag.address)
  return address_ != NULL ? *address_
                         : *::dba::dbacodeaddress::internal_default_instance();
}
::dba::dbacodeaddress* dbatag::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    address_ = new ::dba::dbacodeaddress;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbatag.address)
  return address_;
}
::dba::dbacodeaddress* dbatag::release_address() {
  // @@protoc_insertion_point(field_release:dba.dbatag.address)
  clear_has_address();
  ::dba::dbacodeaddress* temp = address_;
  address_ = NULL;
  return temp;
}
void dbatag::set_allocated_address(::dba::dbacodeaddress* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbatag.address)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int dbastopstate::kTypeidFieldNumber;
const int dbastopstate::kInfosFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

dbastopstate::dbastopstate()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_dba_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.dbastopstate)
}
dbastopstate::dbastopstate(const dbastopstate& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  infos_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_infos()) {
    infos_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.infos_);
  }
  typeid__ = from.typeid__;
  // @@protoc_insertion_point(copy_constructor:dba.dbastopstate)
}

void dbastopstate::SharedCtor() {
  _cached_size_ = 0;
  infos_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  typeid__ = 1;
}

dbastopstate::~dbastopstate() {
  // @@protoc_insertion_point(destructor:dba.dbastopstate)
  SharedDtor();
}

void dbastopstate::SharedDtor() {
  infos_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void dbastopstate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* dbastopstate::descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[4].descriptor;
}

const dbastopstate& dbastopstate::default_instance() {
  protobuf_dba_2eproto::InitDefaults();
  return *internal_default_instance();
}

dbastopstate* dbastopstate::New(::google::protobuf::Arena* arena) const {
  dbastopstate* n = new dbastopstate;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void dbastopstate::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.dbastopstate)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_infos()) {
      GOOGLE_DCHECK(!infos_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*infos_.UnsafeRawStringPointer())->clear();
    }
    typeid__ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool dbastopstate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.dbastopstate)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .dba.dbastopstate.typeid_dbastate typeid = 1;
      case 1: {
        if (tag == 8u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::dbastopstate_typeid_dbastate_IsValid(value)) {
            set_typeid_(static_cast< ::dba::dbastopstate_typeid_dbastate >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string infos = 2;
      case 2: {
        if (tag == 18u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_infos()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->infos().data(), this->infos().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "dba.dbastopstate.infos");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.dbastopstate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.dbastopstate)
  return false;
#undef DO_
}

void dbastopstate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.dbastopstate)
  // required .dba.dbastopstate.typeid_dbastate typeid = 1;
  if (has_typeid_()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  // optional string infos = 2;
  if (has_infos()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->infos().data(), this->infos().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "dba.dbastopstate.infos");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->infos(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.dbastopstate)
}

::google::protobuf::uint8* dbastopstate::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:dba.dbastopstate)
  // required .dba.dbastopstate.typeid_dbastate typeid = 1;
  if (has_typeid_()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  // optional string infos = 2;
  if (has_infos()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->infos().data(), this->infos().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "dba.dbastopstate.infos");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->infos(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.dbastopstate)
  return target;
}

size_t dbastopstate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.dbastopstate)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .dba.dbastopstate.typeid_dbastate typeid = 1;
  if (has_typeid_()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->typeid_());
  }
  // optional string infos = 2;
  if (has_infos()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->infos());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void dbastopstate::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.dbastopstate)
  GOOGLE_DCHECK_NE(&from, this);
  const dbastopstate* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const dbastopstate>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.dbastopstate)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.dbastopstate)
    MergeFrom(*source);
  }
}

void dbastopstate::MergeFrom(const dbastopstate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.dbastopstate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._has_bits_[0 / 32] & 3u) {
    if (from.has_infos()) {
      set_has_infos();
      infos_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.infos_);
    }
    if (from.has_typeid_()) {
      set_typeid_(from.typeid_());
    }
  }
}

void dbastopstate::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.dbastopstate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void dbastopstate::CopyFrom(const dbastopstate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.dbastopstate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool dbastopstate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  return true;
}

void dbastopstate::Swap(dbastopstate* other) {
  if (other == this) return;
  InternalSwap(other);
}
void dbastopstate::InternalSwap(dbastopstate* other) {
  infos_.Swap(&other->infos_);
  std::swap(typeid__, other->typeid__);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata dbastopstate::GetMetadata() const {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[4];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// dbastopstate

// required .dba.dbastopstate.typeid_dbastate typeid = 1;
bool dbastopstate::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void dbastopstate::set_has_typeid_() {
  _has_bits_[0] |= 0x00000002u;
}
void dbastopstate::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000002u;
}
void dbastopstate::clear_typeid_() {
  typeid__ = 1;
  clear_has_typeid_();
}
::dba::dbastopstate_typeid_dbastate dbastopstate::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbastopstate.typeid)
  return static_cast< ::dba::dbastopstate_typeid_dbastate >(typeid__);
}
void dbastopstate::set_typeid_(::dba::dbastopstate_typeid_dbastate value) {
  assert(::dba::dbastopstate_typeid_dbastate_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbastopstate.typeid)
}

// optional string infos = 2;
bool dbastopstate::has_infos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void dbastopstate::set_has_infos() {
  _has_bits_[0] |= 0x00000001u;
}
void dbastopstate::clear_has_infos() {
  _has_bits_[0] &= ~0x00000001u;
}
void dbastopstate::clear_infos() {
  infos_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_infos();
}
const ::std::string& dbastopstate::infos() const {
  // @@protoc_insertion_point(field_get:dba.dbastopstate.infos)
  return infos_.GetNoArena();
}
void dbastopstate::set_infos(const ::std::string& value) {
  set_has_infos();
  infos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dba.dbastopstate.infos)
}
#if LANG_CXX11
void dbastopstate::set_infos(::std::string&& value) {
  set_has_infos();
  infos_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dba.dbastopstate.infos)
}
#endif
void dbastopstate::set_infos(const char* value) {
  set_has_infos();
  infos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dba.dbastopstate.infos)
}
void dbastopstate::set_infos(const char* value, size_t size) {
  set_has_infos();
  infos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dba.dbastopstate.infos)
}
::std::string* dbastopstate::mutable_infos() {
  set_has_infos();
  // @@protoc_insertion_point(field_mutable:dba.dbastopstate.infos)
  return infos_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* dbastopstate::release_infos() {
  // @@protoc_insertion_point(field_release:dba.dbastopstate.infos)
  clear_has_infos();
  return infos_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void dbastopstate::set_allocated_infos(::std::string* infos) {
  if (infos != NULL) {
    set_has_infos();
  } else {
    clear_has_infos();
  }
  infos_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), infos);
  // @@protoc_insertion_point(field_set_allocated:dba.dbastopstate.infos)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int dbaexpr::kTypeidFieldNumber;
const int dbaexpr::kNameFieldNumber;
const int dbaexpr::kSizeFieldNumber;
const int dbaexpr::kEndianFieldNumber;
const int dbaexpr::kBitvectorFieldNumber;
const int dbaexpr::kExpr1FieldNumber;
const int dbaexpr::kExpr2FieldNumber;
const int dbaexpr::kUnaryopFieldNumber;
const int dbaexpr::kBinaryopFieldNumber;
const int dbaexpr::kLowFieldNumber;
const int dbaexpr::kHighFieldNumber;
const int dbaexpr::kCondFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

dbaexpr::dbaexpr()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_dba_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.dbaexpr)
}
dbaexpr::dbaexpr(const dbaexpr& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.has_bitvector()) {
    bitvector_ = new ::dba::bitvector(*from.bitvector_);
  } else {
    bitvector_ = NULL;
  }
  if (from.has_expr1()) {
    expr1_ = new ::dba::dbaexpr(*from.expr1_);
  } else {
    expr1_ = NULL;
  }
  if (from.has_expr2()) {
    expr2_ = new ::dba::dbaexpr(*from.expr2_);
  } else {
    expr2_ = NULL;
  }
  if (from.has_cond()) {
    cond_ = new ::dba::dbacond(*from.cond_);
  } else {
    cond_ = NULL;
  }
  ::memcpy(&size_, &from.size_,
    reinterpret_cast<char*>(&binaryop_) -
    reinterpret_cast<char*>(&size_) + sizeof(binaryop_));
  // @@protoc_insertion_point(copy_constructor:dba.dbaexpr)
}

void dbaexpr::SharedCtor() {
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&bitvector_, 0, reinterpret_cast<char*>(&high_) -
    reinterpret_cast<char*>(&bitvector_) + sizeof(high_));
  typeid__ = 1;
  endian_ = 1;
  unaryop_ = 1;
  binaryop_ = 1;
}

dbaexpr::~dbaexpr() {
  // @@protoc_insertion_point(destructor:dba.dbaexpr)
  SharedDtor();
}

void dbaexpr::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete bitvector_;
  }
  if (this != internal_default_instance()) {
    delete expr1_;
  }
  if (this != internal_default_instance()) {
    delete expr2_;
  }
  if (this != internal_default_instance()) {
    delete cond_;
  }
}

void dbaexpr::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* dbaexpr::descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[5].descriptor;
}

const dbaexpr& dbaexpr::default_instance() {
  protobuf_dba_2eproto::InitDefaults();
  return *internal_default_instance();
}

dbaexpr* dbaexpr::New(::google::protobuf::Arena* arena) const {
  dbaexpr* n = new dbaexpr;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void dbaexpr::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.dbaexpr)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_name()) {
      GOOGLE_DCHECK(!name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*name_.UnsafeRawStringPointer())->clear();
    }
    if (has_bitvector()) {
      GOOGLE_DCHECK(bitvector_ != NULL);
      bitvector_->::dba::bitvector::Clear();
    }
    if (has_expr1()) {
      GOOGLE_DCHECK(expr1_ != NULL);
      expr1_->::dba::dbaexpr::Clear();
    }
    if (has_expr2()) {
      GOOGLE_DCHECK(expr2_ != NULL);
      expr2_->::dba::dbaexpr::Clear();
    }
    if (has_cond()) {
      GOOGLE_DCHECK(cond_ != NULL);
      cond_->::dba::dbacond::Clear();
    }
  }
  if (_has_bits_[0 / 32] & 224u) {
    ::memset(&size_, 0, reinterpret_cast<char*>(&high_) -
      reinterpret_cast<char*>(&size_) + sizeof(high_));
  }
  if (_has_bits_[8 / 32] & 3840u) {
    typeid__ = 1;
    endian_ = 1;
    unaryop_ = 1;
    binaryop_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool dbaexpr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.dbaexpr)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .dba.dbaexpr.typeid_dbaexpr typeid = 1;
      case 1: {
        if (tag == 8u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::dbaexpr_typeid_dbaexpr_IsValid(value)) {
            set_typeid_(static_cast< ::dba::dbaexpr_typeid_dbaexpr >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string name = 2;
      case 2: {
        if (tag == 18u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "dba.dbaexpr.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 size = 3;
      case 3: {
        if (tag == 24u) {
          set_has_size();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.endianness endian = 4;
      case 4: {
        if (tag == 32u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::endianness_IsValid(value)) {
            set_endian(static_cast< ::dba::endianness >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.bitvector bitvector = 5;
      case 5: {
        if (tag == 42u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bitvector()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbaexpr expr1 = 6;
      case 6: {
        if (tag == 50u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_expr1()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbaexpr expr2 = 7;
      case 7: {
        if (tag == 58u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_expr2()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbaexpr.dbaunary unaryop = 9;
      case 9: {
        if (tag == 72u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::dbaexpr_dbaunary_IsValid(value)) {
            set_unaryop(static_cast< ::dba::dbaexpr_dbaunary >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbaexpr.dbabinary binaryop = 10;
      case 10: {
        if (tag == 80u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::dbaexpr_dbabinary_IsValid(value)) {
            set_binaryop(static_cast< ::dba::dbaexpr_dbabinary >(value));
          } else {
            mutable_unknown_fields()->AddVarint(10, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 low = 11;
      case 11: {
        if (tag == 88u) {
          set_has_low();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &low_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 high = 12;
      case 12: {
        if (tag == 96u) {
          set_has_high();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &high_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbacond cond = 13;
      case 13: {
        if (tag == 106u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cond()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.dbaexpr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.dbaexpr)
  return false;
#undef DO_
}

void dbaexpr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.dbaexpr)
  // required .dba.dbaexpr.typeid_dbaexpr typeid = 1;
  if (has_typeid_()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "dba.dbaexpr.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional uint32 size = 3;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->size(), output);
  }

  // optional .dba.endianness endian = 4;
  if (has_endian()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->endian(), output);
  }

  // optional .dba.bitvector bitvector = 5;
  if (has_bitvector()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->bitvector_, output);
  }

  // optional .dba.dbaexpr expr1 = 6;
  if (has_expr1()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->expr1_, output);
  }

  // optional .dba.dbaexpr expr2 = 7;
  if (has_expr2()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->expr2_, output);
  }

  // optional .dba.dbaexpr.dbaunary unaryop = 9;
  if (has_unaryop()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->unaryop(), output);
  }

  // optional .dba.dbaexpr.dbabinary binaryop = 10;
  if (has_binaryop()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->binaryop(), output);
  }

  // optional uint32 low = 11;
  if (has_low()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->low(), output);
  }

  // optional uint32 high = 12;
  if (has_high()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->high(), output);
  }

  // optional .dba.dbacond cond = 13;
  if (has_cond()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *this->cond_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.dbaexpr)
}

::google::protobuf::uint8* dbaexpr::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:dba.dbaexpr)
  // required .dba.dbaexpr.typeid_dbaexpr typeid = 1;
  if (has_typeid_()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "dba.dbaexpr.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional uint32 size = 3;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->size(), target);
  }

  // optional .dba.endianness endian = 4;
  if (has_endian()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->endian(), target);
  }

  // optional .dba.bitvector bitvector = 5;
  if (has_bitvector()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->bitvector_, false, target);
  }

  // optional .dba.dbaexpr expr1 = 6;
  if (has_expr1()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->expr1_, false, target);
  }

  // optional .dba.dbaexpr expr2 = 7;
  if (has_expr2()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->expr2_, false, target);
  }

  // optional .dba.dbaexpr.dbaunary unaryop = 9;
  if (has_unaryop()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->unaryop(), target);
  }

  // optional .dba.dbaexpr.dbabinary binaryop = 10;
  if (has_binaryop()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      10, this->binaryop(), target);
  }

  // optional uint32 low = 11;
  if (has_low()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->low(), target);
  }

  // optional uint32 high = 12;
  if (has_high()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->high(), target);
  }

  // optional .dba.dbacond cond = 13;
  if (has_cond()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        13, *this->cond_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.dbaexpr)
  return target;
}

size_t dbaexpr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.dbaexpr)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .dba.dbaexpr.typeid_dbaexpr typeid = 1;
  if (has_typeid_()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->typeid_());
  }
  if (_has_bits_[0 / 32] & 255u) {
    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .dba.bitvector bitvector = 5;
    if (has_bitvector()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->bitvector_);
    }

    // optional .dba.dbaexpr expr1 = 6;
    if (has_expr1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->expr1_);
    }

    // optional .dba.dbaexpr expr2 = 7;
    if (has_expr2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->expr2_);
    }

    // optional .dba.dbacond cond = 13;
    if (has_cond()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->cond_);
    }

    // optional uint32 size = 3;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->size());
    }

    // optional uint32 low = 11;
    if (has_low()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->low());
    }

    // optional uint32 high = 12;
    if (has_high()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->high());
    }

  }
  if (_has_bits_[8 / 32] & 3584u) {
    // optional .dba.endianness endian = 4;
    if (has_endian()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->endian());
    }

    // optional .dba.dbaexpr.dbaunary unaryop = 9;
    if (has_unaryop()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->unaryop());
    }

    // optional .dba.dbaexpr.dbabinary binaryop = 10;
    if (has_binaryop()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->binaryop());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void dbaexpr::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.dbaexpr)
  GOOGLE_DCHECK_NE(&from, this);
  const dbaexpr* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const dbaexpr>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.dbaexpr)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.dbaexpr)
    MergeFrom(*source);
  }
}

void dbaexpr::MergeFrom(const dbaexpr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.dbaexpr)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._has_bits_[0 / 32] & 255u) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_bitvector()) {
      mutable_bitvector()->::dba::bitvector::MergeFrom(from.bitvector());
    }
    if (from.has_expr1()) {
      mutable_expr1()->::dba::dbaexpr::MergeFrom(from.expr1());
    }
    if (from.has_expr2()) {
      mutable_expr2()->::dba::dbaexpr::MergeFrom(from.expr2());
    }
    if (from.has_cond()) {
      mutable_cond()->::dba::dbacond::MergeFrom(from.cond());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_low()) {
      set_low(from.low());
    }
    if (from.has_high()) {
      set_high(from.high());
    }
  }
  if (from._has_bits_[8 / 32] & 3840u) {
    if (from.has_typeid_()) {
      set_typeid_(from.typeid_());
    }
    if (from.has_endian()) {
      set_endian(from.endian());
    }
    if (from.has_unaryop()) {
      set_unaryop(from.unaryop());
    }
    if (from.has_binaryop()) {
      set_binaryop(from.binaryop());
    }
  }
}

void dbaexpr::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.dbaexpr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void dbaexpr::CopyFrom(const dbaexpr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.dbaexpr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool dbaexpr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000100) != 0x00000100) return false;
  if (has_bitvector()) {
    if (!this->bitvector_->IsInitialized()) return false;
  }
  if (has_expr1()) {
    if (!this->expr1_->IsInitialized()) return false;
  }
  if (has_expr2()) {
    if (!this->expr2_->IsInitialized()) return false;
  }
  if (has_cond()) {
    if (!this->cond_->IsInitialized()) return false;
  }
  return true;
}

void dbaexpr::Swap(dbaexpr* other) {
  if (other == this) return;
  InternalSwap(other);
}
void dbaexpr::InternalSwap(dbaexpr* other) {
  name_.Swap(&other->name_);
  std::swap(bitvector_, other->bitvector_);
  std::swap(expr1_, other->expr1_);
  std::swap(expr2_, other->expr2_);
  std::swap(cond_, other->cond_);
  std::swap(size_, other->size_);
  std::swap(low_, other->low_);
  std::swap(high_, other->high_);
  std::swap(typeid__, other->typeid__);
  std::swap(endian_, other->endian_);
  std::swap(unaryop_, other->unaryop_);
  std::swap(binaryop_, other->binaryop_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata dbaexpr::GetMetadata() const {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[5];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// dbaexpr

// required .dba.dbaexpr.typeid_dbaexpr typeid = 1;
bool dbaexpr::has_typeid_() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void dbaexpr::set_has_typeid_() {
  _has_bits_[0] |= 0x00000100u;
}
void dbaexpr::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000100u;
}
void dbaexpr::clear_typeid_() {
  typeid__ = 1;
  clear_has_typeid_();
}
::dba::dbaexpr_typeid_dbaexpr dbaexpr::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.typeid)
  return static_cast< ::dba::dbaexpr_typeid_dbaexpr >(typeid__);
}
void dbaexpr::set_typeid_(::dba::dbaexpr_typeid_dbaexpr value) {
  assert(::dba::dbaexpr_typeid_dbaexpr_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.typeid)
}

// optional string name = 2;
bool dbaexpr::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void dbaexpr::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void dbaexpr::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void dbaexpr::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
const ::std::string& dbaexpr::name() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.name)
  return name_.GetNoArena();
}
void dbaexpr::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dba.dbaexpr.name)
}
#if LANG_CXX11
void dbaexpr::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dba.dbaexpr.name)
}
#endif
void dbaexpr::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dba.dbaexpr.name)
}
void dbaexpr::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dba.dbaexpr.name)
}
::std::string* dbaexpr::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:dba.dbaexpr.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* dbaexpr::release_name() {
  // @@protoc_insertion_point(field_release:dba.dbaexpr.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void dbaexpr::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dba.dbaexpr.name)
}

// optional uint32 size = 3;
bool dbaexpr::has_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void dbaexpr::set_has_size() {
  _has_bits_[0] |= 0x00000020u;
}
void dbaexpr::clear_has_size() {
  _has_bits_[0] &= ~0x00000020u;
}
void dbaexpr::clear_size() {
  size_ = 0u;
  clear_has_size();
}
::google::protobuf::uint32 dbaexpr::size() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.size)
  return size_;
}
void dbaexpr::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.size)
}

// optional .dba.endianness endian = 4;
bool dbaexpr::has_endian() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void dbaexpr::set_has_endian() {
  _has_bits_[0] |= 0x00000200u;
}
void dbaexpr::clear_has_endian() {
  _has_bits_[0] &= ~0x00000200u;
}
void dbaexpr::clear_endian() {
  endian_ = 1;
  clear_has_endian();
}
::dba::endianness dbaexpr::endian() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.endian)
  return static_cast< ::dba::endianness >(endian_);
}
void dbaexpr::set_endian(::dba::endianness value) {
  assert(::dba::endianness_IsValid(value));
  set_has_endian();
  endian_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.endian)
}

// optional .dba.bitvector bitvector = 5;
bool dbaexpr::has_bitvector() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void dbaexpr::set_has_bitvector() {
  _has_bits_[0] |= 0x00000002u;
}
void dbaexpr::clear_has_bitvector() {
  _has_bits_[0] &= ~0x00000002u;
}
void dbaexpr::clear_bitvector() {
  if (bitvector_ != NULL) bitvector_->::dba::bitvector::Clear();
  clear_has_bitvector();
}
const ::dba::bitvector& dbaexpr::bitvector() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.bitvector)
  return bitvector_ != NULL ? *bitvector_
                         : *::dba::bitvector::internal_default_instance();
}
::dba::bitvector* dbaexpr::mutable_bitvector() {
  set_has_bitvector();
  if (bitvector_ == NULL) {
    bitvector_ = new ::dba::bitvector;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbaexpr.bitvector)
  return bitvector_;
}
::dba::bitvector* dbaexpr::release_bitvector() {
  // @@protoc_insertion_point(field_release:dba.dbaexpr.bitvector)
  clear_has_bitvector();
  ::dba::bitvector* temp = bitvector_;
  bitvector_ = NULL;
  return temp;
}
void dbaexpr::set_allocated_bitvector(::dba::bitvector* bitvector) {
  delete bitvector_;
  bitvector_ = bitvector;
  if (bitvector) {
    set_has_bitvector();
  } else {
    clear_has_bitvector();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbaexpr.bitvector)
}

// optional .dba.dbaexpr expr1 = 6;
bool dbaexpr::has_expr1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void dbaexpr::set_has_expr1() {
  _has_bits_[0] |= 0x00000004u;
}
void dbaexpr::clear_has_expr1() {
  _has_bits_[0] &= ~0x00000004u;
}
void dbaexpr::clear_expr1() {
  if (expr1_ != NULL) expr1_->::dba::dbaexpr::Clear();
  clear_has_expr1();
}
const ::dba::dbaexpr& dbaexpr::expr1() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.expr1)
  return expr1_ != NULL ? *expr1_
                         : *::dba::dbaexpr::internal_default_instance();
}
::dba::dbaexpr* dbaexpr::mutable_expr1() {
  set_has_expr1();
  if (expr1_ == NULL) {
    expr1_ = new ::dba::dbaexpr;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbaexpr.expr1)
  return expr1_;
}
::dba::dbaexpr* dbaexpr::release_expr1() {
  // @@protoc_insertion_point(field_release:dba.dbaexpr.expr1)
  clear_has_expr1();
  ::dba::dbaexpr* temp = expr1_;
  expr1_ = NULL;
  return temp;
}
void dbaexpr::set_allocated_expr1(::dba::dbaexpr* expr1) {
  delete expr1_;
  expr1_ = expr1;
  if (expr1) {
    set_has_expr1();
  } else {
    clear_has_expr1();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbaexpr.expr1)
}

// optional .dba.dbaexpr expr2 = 7;
bool dbaexpr::has_expr2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void dbaexpr::set_has_expr2() {
  _has_bits_[0] |= 0x00000008u;
}
void dbaexpr::clear_has_expr2() {
  _has_bits_[0] &= ~0x00000008u;
}
void dbaexpr::clear_expr2() {
  if (expr2_ != NULL) expr2_->::dba::dbaexpr::Clear();
  clear_has_expr2();
}
const ::dba::dbaexpr& dbaexpr::expr2() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.expr2)
  return expr2_ != NULL ? *expr2_
                         : *::dba::dbaexpr::internal_default_instance();
}
::dba::dbaexpr* dbaexpr::mutable_expr2() {
  set_has_expr2();
  if (expr2_ == NULL) {
    expr2_ = new ::dba::dbaexpr;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbaexpr.expr2)
  return expr2_;
}
::dba::dbaexpr* dbaexpr::release_expr2() {
  // @@protoc_insertion_point(field_release:dba.dbaexpr.expr2)
  clear_has_expr2();
  ::dba::dbaexpr* temp = expr2_;
  expr2_ = NULL;
  return temp;
}
void dbaexpr::set_allocated_expr2(::dba::dbaexpr* expr2) {
  delete expr2_;
  expr2_ = expr2;
  if (expr2) {
    set_has_expr2();
  } else {
    clear_has_expr2();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbaexpr.expr2)
}

// optional .dba.dbaexpr.dbaunary unaryop = 9;
bool dbaexpr::has_unaryop() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void dbaexpr::set_has_unaryop() {
  _has_bits_[0] |= 0x00000400u;
}
void dbaexpr::clear_has_unaryop() {
  _has_bits_[0] &= ~0x00000400u;
}
void dbaexpr::clear_unaryop() {
  unaryop_ = 1;
  clear_has_unaryop();
}
::dba::dbaexpr_dbaunary dbaexpr::unaryop() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.unaryop)
  return static_cast< ::dba::dbaexpr_dbaunary >(unaryop_);
}
void dbaexpr::set_unaryop(::dba::dbaexpr_dbaunary value) {
  assert(::dba::dbaexpr_dbaunary_IsValid(value));
  set_has_unaryop();
  unaryop_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.unaryop)
}

// optional .dba.dbaexpr.dbabinary binaryop = 10;
bool dbaexpr::has_binaryop() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void dbaexpr::set_has_binaryop() {
  _has_bits_[0] |= 0x00000800u;
}
void dbaexpr::clear_has_binaryop() {
  _has_bits_[0] &= ~0x00000800u;
}
void dbaexpr::clear_binaryop() {
  binaryop_ = 1;
  clear_has_binaryop();
}
::dba::dbaexpr_dbabinary dbaexpr::binaryop() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.binaryop)
  return static_cast< ::dba::dbaexpr_dbabinary >(binaryop_);
}
void dbaexpr::set_binaryop(::dba::dbaexpr_dbabinary value) {
  assert(::dba::dbaexpr_dbabinary_IsValid(value));
  set_has_binaryop();
  binaryop_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.binaryop)
}

// optional uint32 low = 11;
bool dbaexpr::has_low() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void dbaexpr::set_has_low() {
  _has_bits_[0] |= 0x00000040u;
}
void dbaexpr::clear_has_low() {
  _has_bits_[0] &= ~0x00000040u;
}
void dbaexpr::clear_low() {
  low_ = 0u;
  clear_has_low();
}
::google::protobuf::uint32 dbaexpr::low() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.low)
  return low_;
}
void dbaexpr::set_low(::google::protobuf::uint32 value) {
  set_has_low();
  low_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.low)
}

// optional uint32 high = 12;
bool dbaexpr::has_high() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void dbaexpr::set_has_high() {
  _has_bits_[0] |= 0x00000080u;
}
void dbaexpr::clear_has_high() {
  _has_bits_[0] &= ~0x00000080u;
}
void dbaexpr::clear_high() {
  high_ = 0u;
  clear_has_high();
}
::google::protobuf::uint32 dbaexpr::high() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.high)
  return high_;
}
void dbaexpr::set_high(::google::protobuf::uint32 value) {
  set_has_high();
  high_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.high)
}

// optional .dba.dbacond cond = 13;
bool dbaexpr::has_cond() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void dbaexpr::set_has_cond() {
  _has_bits_[0] |= 0x00000010u;
}
void dbaexpr::clear_has_cond() {
  _has_bits_[0] &= ~0x00000010u;
}
void dbaexpr::clear_cond() {
  if (cond_ != NULL) cond_->::dba::dbacond::Clear();
  clear_has_cond();
}
const ::dba::dbacond& dbaexpr::cond() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.cond)
  return cond_ != NULL ? *cond_
                         : *::dba::dbacond::internal_default_instance();
}
::dba::dbacond* dbaexpr::mutable_cond() {
  set_has_cond();
  if (cond_ == NULL) {
    cond_ = new ::dba::dbacond;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbaexpr.cond)
  return cond_;
}
::dba::dbacond* dbaexpr::release_cond() {
  // @@protoc_insertion_point(field_release:dba.dbaexpr.cond)
  clear_has_cond();
  ::dba::dbacond* temp = cond_;
  cond_ = NULL;
  return temp;
}
void dbaexpr::set_allocated_cond(::dba::dbacond* cond) {
  delete cond_;
  cond_ = cond;
  if (cond) {
    set_has_cond();
  } else {
    clear_has_cond();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbaexpr.cond)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int dbacond::kTypeidFieldNumber;
const int dbacond::kExprFieldNumber;
const int dbacond::kCond1FieldNumber;
const int dbacond::kCond2FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

dbacond::dbacond()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_dba_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.dbacond)
}
dbacond::dbacond(const dbacond& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_expr()) {
    expr_ = new ::dba::dbaexpr(*from.expr_);
  } else {
    expr_ = NULL;
  }
  if (from.has_cond1()) {
    cond1_ = new ::dba::dbacond(*from.cond1_);
  } else {
    cond1_ = NULL;
  }
  if (from.has_cond2()) {
    cond2_ = new ::dba::dbacond(*from.cond2_);
  } else {
    cond2_ = NULL;
  }
  typeid__ = from.typeid__;
  // @@protoc_insertion_point(copy_constructor:dba.dbacond)
}

void dbacond::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&expr_, 0, reinterpret_cast<char*>(&cond2_) -
    reinterpret_cast<char*>(&expr_) + sizeof(cond2_));
  typeid__ = 1;
}

dbacond::~dbacond() {
  // @@protoc_insertion_point(destructor:dba.dbacond)
  SharedDtor();
}

void dbacond::SharedDtor() {
  if (this != internal_default_instance()) {
    delete expr_;
  }
  if (this != internal_default_instance()) {
    delete cond1_;
  }
  if (this != internal_default_instance()) {
    delete cond2_;
  }
}

void dbacond::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* dbacond::descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[6].descriptor;
}

const dbacond& dbacond::default_instance() {
  protobuf_dba_2eproto::InitDefaults();
  return *internal_default_instance();
}

dbacond* dbacond::New(::google::protobuf::Arena* arena) const {
  dbacond* n = new dbacond;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void dbacond::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.dbacond)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_expr()) {
      GOOGLE_DCHECK(expr_ != NULL);
      expr_->::dba::dbaexpr::Clear();
    }
    if (has_cond1()) {
      GOOGLE_DCHECK(cond1_ != NULL);
      cond1_->::dba::dbacond::Clear();
    }
    if (has_cond2()) {
      GOOGLE_DCHECK(cond2_ != NULL);
      cond2_->::dba::dbacond::Clear();
    }
    typeid__ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool dbacond::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.dbacond)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .dba.dbacond.typeid_dbacond typeid = 1;
      case 1: {
        if (tag == 8u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::dbacond_typeid_dbacond_IsValid(value)) {
            set_typeid_(static_cast< ::dba::dbacond_typeid_dbacond >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbaexpr expr = 2;
      case 2: {
        if (tag == 18u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_expr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbacond cond1 = 3;
      case 3: {
        if (tag == 26u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cond1()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbacond cond2 = 4;
      case 4: {
        if (tag == 34u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cond2()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.dbacond)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.dbacond)
  return false;
#undef DO_
}

void dbacond::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.dbacond)
  // required .dba.dbacond.typeid_dbacond typeid = 1;
  if (has_typeid_()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  // optional .dba.dbaexpr expr = 2;
  if (has_expr()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->expr_, output);
  }

  // optional .dba.dbacond cond1 = 3;
  if (has_cond1()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->cond1_, output);
  }

  // optional .dba.dbacond cond2 = 4;
  if (has_cond2()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->cond2_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.dbacond)
}

::google::protobuf::uint8* dbacond::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:dba.dbacond)
  // required .dba.dbacond.typeid_dbacond typeid = 1;
  if (has_typeid_()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  // optional .dba.dbaexpr expr = 2;
  if (has_expr()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->expr_, false, target);
  }

  // optional .dba.dbacond cond1 = 3;
  if (has_cond1()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->cond1_, false, target);
  }

  // optional .dba.dbacond cond2 = 4;
  if (has_cond2()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->cond2_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.dbacond)
  return target;
}

size_t dbacond::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.dbacond)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .dba.dbacond.typeid_dbacond typeid = 1;
  if (has_typeid_()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->typeid_());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional .dba.dbaexpr expr = 2;
    if (has_expr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->expr_);
    }

    // optional .dba.dbacond cond1 = 3;
    if (has_cond1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->cond1_);
    }

    // optional .dba.dbacond cond2 = 4;
    if (has_cond2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->cond2_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void dbacond::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.dbacond)
  GOOGLE_DCHECK_NE(&from, this);
  const dbacond* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const dbacond>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.dbacond)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.dbacond)
    MergeFrom(*source);
  }
}

void dbacond::MergeFrom(const dbacond& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.dbacond)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._has_bits_[0 / 32] & 15u) {
    if (from.has_expr()) {
      mutable_expr()->::dba::dbaexpr::MergeFrom(from.expr());
    }
    if (from.has_cond1()) {
      mutable_cond1()->::dba::dbacond::MergeFrom(from.cond1());
    }
    if (from.has_cond2()) {
      mutable_cond2()->::dba::dbacond::MergeFrom(from.cond2());
    }
    if (from.has_typeid_()) {
      set_typeid_(from.typeid_());
    }
  }
}

void dbacond::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.dbacond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void dbacond::CopyFrom(const dbacond& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.dbacond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool dbacond::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000008) != 0x00000008) return false;
  if (has_expr()) {
    if (!this->expr_->IsInitialized()) return false;
  }
  if (has_cond1()) {
    if (!this->cond1_->IsInitialized()) return false;
  }
  if (has_cond2()) {
    if (!this->cond2_->IsInitialized()) return false;
  }
  return true;
}

void dbacond::Swap(dbacond* other) {
  if (other == this) return;
  InternalSwap(other);
}
void dbacond::InternalSwap(dbacond* other) {
  std::swap(expr_, other->expr_);
  std::swap(cond1_, other->cond1_);
  std::swap(cond2_, other->cond2_);
  std::swap(typeid__, other->typeid__);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata dbacond::GetMetadata() const {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[6];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// dbacond

// required .dba.dbacond.typeid_dbacond typeid = 1;
bool dbacond::has_typeid_() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void dbacond::set_has_typeid_() {
  _has_bits_[0] |= 0x00000008u;
}
void dbacond::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000008u;
}
void dbacond::clear_typeid_() {
  typeid__ = 1;
  clear_has_typeid_();
}
::dba::dbacond_typeid_dbacond dbacond::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbacond.typeid)
  return static_cast< ::dba::dbacond_typeid_dbacond >(typeid__);
}
void dbacond::set_typeid_(::dba::dbacond_typeid_dbacond value) {
  assert(::dba::dbacond_typeid_dbacond_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbacond.typeid)
}

// optional .dba.dbaexpr expr = 2;
bool dbacond::has_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void dbacond::set_has_expr() {
  _has_bits_[0] |= 0x00000001u;
}
void dbacond::clear_has_expr() {
  _has_bits_[0] &= ~0x00000001u;
}
void dbacond::clear_expr() {
  if (expr_ != NULL) expr_->::dba::dbaexpr::Clear();
  clear_has_expr();
}
const ::dba::dbaexpr& dbacond::expr() const {
  // @@protoc_insertion_point(field_get:dba.dbacond.expr)
  return expr_ != NULL ? *expr_
                         : *::dba::dbaexpr::internal_default_instance();
}
::dba::dbaexpr* dbacond::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) {
    expr_ = new ::dba::dbaexpr;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbacond.expr)
  return expr_;
}
::dba::dbaexpr* dbacond::release_expr() {
  // @@protoc_insertion_point(field_release:dba.dbacond.expr)
  clear_has_expr();
  ::dba::dbaexpr* temp = expr_;
  expr_ = NULL;
  return temp;
}
void dbacond::set_allocated_expr(::dba::dbaexpr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbacond.expr)
}

// optional .dba.dbacond cond1 = 3;
bool dbacond::has_cond1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void dbacond::set_has_cond1() {
  _has_bits_[0] |= 0x00000002u;
}
void dbacond::clear_has_cond1() {
  _has_bits_[0] &= ~0x00000002u;
}
void dbacond::clear_cond1() {
  if (cond1_ != NULL) cond1_->::dba::dbacond::Clear();
  clear_has_cond1();
}
const ::dba::dbacond& dbacond::cond1() const {
  // @@protoc_insertion_point(field_get:dba.dbacond.cond1)
  return cond1_ != NULL ? *cond1_
                         : *::dba::dbacond::internal_default_instance();
}
::dba::dbacond* dbacond::mutable_cond1() {
  set_has_cond1();
  if (cond1_ == NULL) {
    cond1_ = new ::dba::dbacond;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbacond.cond1)
  return cond1_;
}
::dba::dbacond* dbacond::release_cond1() {
  // @@protoc_insertion_point(field_release:dba.dbacond.cond1)
  clear_has_cond1();
  ::dba::dbacond* temp = cond1_;
  cond1_ = NULL;
  return temp;
}
void dbacond::set_allocated_cond1(::dba::dbacond* cond1) {
  delete cond1_;
  cond1_ = cond1;
  if (cond1) {
    set_has_cond1();
  } else {
    clear_has_cond1();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbacond.cond1)
}

// optional .dba.dbacond cond2 = 4;
bool dbacond::has_cond2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void dbacond::set_has_cond2() {
  _has_bits_[0] |= 0x00000004u;
}
void dbacond::clear_has_cond2() {
  _has_bits_[0] &= ~0x00000004u;
}
void dbacond::clear_cond2() {
  if (cond2_ != NULL) cond2_->::dba::dbacond::Clear();
  clear_has_cond2();
}
const ::dba::dbacond& dbacond::cond2() const {
  // @@protoc_insertion_point(field_get:dba.dbacond.cond2)
  return cond2_ != NULL ? *cond2_
                         : *::dba::dbacond::internal_default_instance();
}
::dba::dbacond* dbacond::mutable_cond2() {
  set_has_cond2();
  if (cond2_ == NULL) {
    cond2_ = new ::dba::dbacond;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbacond.cond2)
  return cond2_;
}
::dba::dbacond* dbacond::release_cond2() {
  // @@protoc_insertion_point(field_release:dba.dbacond.cond2)
  clear_has_cond2();
  ::dba::dbacond* temp = cond2_;
  cond2_ = NULL;
  return temp;
}
void dbacond::set_allocated_cond2(::dba::dbacond* cond2) {
  delete cond2_;
  cond2_ = cond2;
  if (cond2) {
    set_has_cond2();
  } else {
    clear_has_cond2();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbacond.cond2)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int dbaLhs::kTypeidFieldNumber;
const int dbaLhs::kNameFieldNumber;
const int dbaLhs::kSizeFieldNumber;
const int dbaLhs::kLowFieldNumber;
const int dbaLhs::kHighFieldNumber;
const int dbaLhs::kEndianFieldNumber;
const int dbaLhs::kExprFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

dbaLhs::dbaLhs()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_dba_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.dbaLhs)
}
dbaLhs::dbaLhs(const dbaLhs& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.has_expr()) {
    expr_ = new ::dba::dbaexpr(*from.expr_);
  } else {
    expr_ = NULL;
  }
  ::memcpy(&size_, &from.size_,
    reinterpret_cast<char*>(&endian_) -
    reinterpret_cast<char*>(&size_) + sizeof(endian_));
  // @@protoc_insertion_point(copy_constructor:dba.dbaLhs)
}

void dbaLhs::SharedCtor() {
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&expr_, 0, reinterpret_cast<char*>(&high_) -
    reinterpret_cast<char*>(&expr_) + sizeof(high_));
  typeid__ = 1;
  endian_ = 1;
}

dbaLhs::~dbaLhs() {
  // @@protoc_insertion_point(destructor:dba.dbaLhs)
  SharedDtor();
}

void dbaLhs::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete expr_;
  }
}

void dbaLhs::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* dbaLhs::descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[7].descriptor;
}

const dbaLhs& dbaLhs::default_instance() {
  protobuf_dba_2eproto::InitDefaults();
  return *internal_default_instance();
}

dbaLhs* dbaLhs::New(::google::protobuf::Arena* arena) const {
  dbaLhs* n = new dbaLhs;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void dbaLhs::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.dbaLhs)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_name()) {
      GOOGLE_DCHECK(!name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*name_.UnsafeRawStringPointer())->clear();
    }
    if (has_expr()) {
      GOOGLE_DCHECK(expr_ != NULL);
      expr_->::dba::dbaexpr::Clear();
    }
  }
  if (_has_bits_[0 / 32] & 124u) {
    ::memset(&size_, 0, reinterpret_cast<char*>(&high_) -
      reinterpret_cast<char*>(&size_) + sizeof(high_));
    typeid__ = 1;
    endian_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool dbaLhs::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.dbaLhs)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .dba.dbaLhs.typeid_dbalhs typeid = 1;
      case 1: {
        if (tag == 8u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::dbaLhs_typeid_dbalhs_IsValid(value)) {
            set_typeid_(static_cast< ::dba::dbaLhs_typeid_dbalhs >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string name = 2;
      case 2: {
        if (tag == 18u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "dba.dbaLhs.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 size = 3;
      case 3: {
        if (tag == 24u) {
          set_has_size();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 low = 4;
      case 4: {
        if (tag == 32u) {
          set_has_low();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &low_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 high = 5;
      case 5: {
        if (tag == 40u) {
          set_has_high();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &high_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.endianness endian = 6;
      case 6: {
        if (tag == 48u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::endianness_IsValid(value)) {
            set_endian(static_cast< ::dba::endianness >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbaexpr expr = 7;
      case 7: {
        if (tag == 58u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_expr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.dbaLhs)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.dbaLhs)
  return false;
#undef DO_
}

void dbaLhs::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.dbaLhs)
  // required .dba.dbaLhs.typeid_dbalhs typeid = 1;
  if (has_typeid_()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "dba.dbaLhs.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional uint32 size = 3;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->size(), output);
  }

  // optional uint32 low = 4;
  if (has_low()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->low(), output);
  }

  // optional uint32 high = 5;
  if (has_high()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->high(), output);
  }

  // optional .dba.endianness endian = 6;
  if (has_endian()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->endian(), output);
  }

  // optional .dba.dbaexpr expr = 7;
  if (has_expr()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->expr_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.dbaLhs)
}

::google::protobuf::uint8* dbaLhs::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:dba.dbaLhs)
  // required .dba.dbaLhs.typeid_dbalhs typeid = 1;
  if (has_typeid_()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "dba.dbaLhs.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional uint32 size = 3;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->size(), target);
  }

  // optional uint32 low = 4;
  if (has_low()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->low(), target);
  }

  // optional uint32 high = 5;
  if (has_high()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->high(), target);
  }

  // optional .dba.endianness endian = 6;
  if (has_endian()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->endian(), target);
  }

  // optional .dba.dbaexpr expr = 7;
  if (has_expr()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->expr_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.dbaLhs)
  return target;
}

size_t dbaLhs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.dbaLhs)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .dba.dbaLhs.typeid_dbalhs typeid = 1;
  if (has_typeid_()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->typeid_());
  }
  if (_has_bits_[0 / 32] & 31u) {
    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .dba.dbaexpr expr = 7;
    if (has_expr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->expr_);
    }

    // optional uint32 size = 3;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->size());
    }

    // optional uint32 low = 4;
    if (has_low()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->low());
    }

    // optional uint32 high = 5;
    if (has_high()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->high());
    }

  }
  // optional .dba.endianness endian = 6;
  if (has_endian()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->endian());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void dbaLhs::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.dbaLhs)
  GOOGLE_DCHECK_NE(&from, this);
  const dbaLhs* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const dbaLhs>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.dbaLhs)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.dbaLhs)
    MergeFrom(*source);
  }
}

void dbaLhs::MergeFrom(const dbaLhs& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.dbaLhs)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._has_bits_[0 / 32] & 127u) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_expr()) {
      mutable_expr()->::dba::dbaexpr::MergeFrom(from.expr());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_low()) {
      set_low(from.low());
    }
    if (from.has_high()) {
      set_high(from.high());
    }
    if (from.has_typeid_()) {
      set_typeid_(from.typeid_());
    }
    if (from.has_endian()) {
      set_endian(from.endian());
    }
  }
}

void dbaLhs::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.dbaLhs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void dbaLhs::CopyFrom(const dbaLhs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.dbaLhs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool dbaLhs::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000020) != 0x00000020) return false;
  if (has_expr()) {
    if (!this->expr_->IsInitialized()) return false;
  }
  return true;
}

void dbaLhs::Swap(dbaLhs* other) {
  if (other == this) return;
  InternalSwap(other);
}
void dbaLhs::InternalSwap(dbaLhs* other) {
  name_.Swap(&other->name_);
  std::swap(expr_, other->expr_);
  std::swap(size_, other->size_);
  std::swap(low_, other->low_);
  std::swap(high_, other->high_);
  std::swap(typeid__, other->typeid__);
  std::swap(endian_, other->endian_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata dbaLhs::GetMetadata() const {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[7];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// dbaLhs

// required .dba.dbaLhs.typeid_dbalhs typeid = 1;
bool dbaLhs::has_typeid_() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void dbaLhs::set_has_typeid_() {
  _has_bits_[0] |= 0x00000020u;
}
void dbaLhs::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000020u;
}
void dbaLhs::clear_typeid_() {
  typeid__ = 1;
  clear_has_typeid_();
}
::dba::dbaLhs_typeid_dbalhs dbaLhs::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.typeid)
  return static_cast< ::dba::dbaLhs_typeid_dbalhs >(typeid__);
}
void dbaLhs::set_typeid_(::dba::dbaLhs_typeid_dbalhs value) {
  assert(::dba::dbaLhs_typeid_dbalhs_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbaLhs.typeid)
}

// optional string name = 2;
bool dbaLhs::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void dbaLhs::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void dbaLhs::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void dbaLhs::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
const ::std::string& dbaLhs::name() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.name)
  return name_.GetNoArena();
}
void dbaLhs::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dba.dbaLhs.name)
}
#if LANG_CXX11
void dbaLhs::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dba.dbaLhs.name)
}
#endif
void dbaLhs::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dba.dbaLhs.name)
}
void dbaLhs::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dba.dbaLhs.name)
}
::std::string* dbaLhs::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:dba.dbaLhs.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* dbaLhs::release_name() {
  // @@protoc_insertion_point(field_release:dba.dbaLhs.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void dbaLhs::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dba.dbaLhs.name)
}

// optional uint32 size = 3;
bool dbaLhs::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void dbaLhs::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
void dbaLhs::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
void dbaLhs::clear_size() {
  size_ = 0u;
  clear_has_size();
}
::google::protobuf::uint32 dbaLhs::size() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.size)
  return size_;
}
void dbaLhs::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaLhs.size)
}

// optional uint32 low = 4;
bool dbaLhs::has_low() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void dbaLhs::set_has_low() {
  _has_bits_[0] |= 0x00000008u;
}
void dbaLhs::clear_has_low() {
  _has_bits_[0] &= ~0x00000008u;
}
void dbaLhs::clear_low() {
  low_ = 0u;
  clear_has_low();
}
::google::protobuf::uint32 dbaLhs::low() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.low)
  return low_;
}
void dbaLhs::set_low(::google::protobuf::uint32 value) {
  set_has_low();
  low_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaLhs.low)
}

// optional uint32 high = 5;
bool dbaLhs::has_high() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void dbaLhs::set_has_high() {
  _has_bits_[0] |= 0x00000010u;
}
void dbaLhs::clear_has_high() {
  _has_bits_[0] &= ~0x00000010u;
}
void dbaLhs::clear_high() {
  high_ = 0u;
  clear_has_high();
}
::google::protobuf::uint32 dbaLhs::high() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.high)
  return high_;
}
void dbaLhs::set_high(::google::protobuf::uint32 value) {
  set_has_high();
  high_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaLhs.high)
}

// optional .dba.endianness endian = 6;
bool dbaLhs::has_endian() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void dbaLhs::set_has_endian() {
  _has_bits_[0] |= 0x00000040u;
}
void dbaLhs::clear_has_endian() {
  _has_bits_[0] &= ~0x00000040u;
}
void dbaLhs::clear_endian() {
  endian_ = 1;
  clear_has_endian();
}
::dba::endianness dbaLhs::endian() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.endian)
  return static_cast< ::dba::endianness >(endian_);
}
void dbaLhs::set_endian(::dba::endianness value) {
  assert(::dba::endianness_IsValid(value));
  set_has_endian();
  endian_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaLhs.endian)
}

// optional .dba.dbaexpr expr = 7;
bool dbaLhs::has_expr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void dbaLhs::set_has_expr() {
  _has_bits_[0] |= 0x00000002u;
}
void dbaLhs::clear_has_expr() {
  _has_bits_[0] &= ~0x00000002u;
}
void dbaLhs::clear_expr() {
  if (expr_ != NULL) expr_->::dba::dbaexpr::Clear();
  clear_has_expr();
}
const ::dba::dbaexpr& dbaLhs::expr() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.expr)
  return expr_ != NULL ? *expr_
                         : *::dba::dbaexpr::internal_default_instance();
}
::dba::dbaexpr* dbaLhs::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) {
    expr_ = new ::dba::dbaexpr;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbaLhs.expr)
  return expr_;
}
::dba::dbaexpr* dbaLhs::release_expr() {
  // @@protoc_insertion_point(field_release:dba.dbaLhs.expr)
  clear_has_expr();
  ::dba::dbaexpr* temp = expr_;
  expr_ = NULL;
  return temp;
}
void dbaLhs::set_allocated_expr(::dba::dbaexpr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbaLhs.expr)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int dbainstr::kTypeidFieldNumber;
const int dbainstr::kLocationFieldNumber;
const int dbainstr::kLhsFieldNumber;
const int dbainstr::kExprFieldNumber;
const int dbainstr::kOffsetFieldNumber;
const int dbainstr::kAddressFieldNumber;
const int dbainstr::kTagsFieldNumber;
const int dbainstr::kCondFieldNumber;
const int dbainstr::kStopinfosFieldNumber;
const int dbainstr::kExprsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

dbainstr::dbainstr()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_dba_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.dbainstr)
}
dbainstr::dbainstr(const dbainstr& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      exprs_(from.exprs_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_location()) {
    location_ = new ::dba::dbacodeaddress(*from.location_);
  } else {
    location_ = NULL;
  }
  if (from.has_lhs()) {
    lhs_ = new ::dba::dbaLhs(*from.lhs_);
  } else {
    lhs_ = NULL;
  }
  if (from.has_expr()) {
    expr_ = new ::dba::dbaexpr(*from.expr_);
  } else {
    expr_ = NULL;
  }
  if (from.has_address()) {
    address_ = new ::dba::codeaddress(*from.address_);
  } else {
    address_ = NULL;
  }
  if (from.has_tags()) {
    tags_ = new ::dba::dbatag(*from.tags_);
  } else {
    tags_ = NULL;
  }
  if (from.has_cond()) {
    cond_ = new ::dba::dbacond(*from.cond_);
  } else {
    cond_ = NULL;
  }
  if (from.has_stopinfos()) {
    stopinfos_ = new ::dba::dbastopstate(*from.stopinfos_);
  } else {
    stopinfos_ = NULL;
  }
  ::memcpy(&offset_, &from.offset_,
    reinterpret_cast<char*>(&typeid__) -
    reinterpret_cast<char*>(&offset_) + sizeof(typeid__));
  // @@protoc_insertion_point(copy_constructor:dba.dbainstr)
}

void dbainstr::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&location_, 0, reinterpret_cast<char*>(&offset_) -
    reinterpret_cast<char*>(&location_) + sizeof(offset_));
  typeid__ = 1;
}

dbainstr::~dbainstr() {
  // @@protoc_insertion_point(destructor:dba.dbainstr)
  SharedDtor();
}

void dbainstr::SharedDtor() {
  if (this != internal_default_instance()) {
    delete location_;
  }
  if (this != internal_default_instance()) {
    delete lhs_;
  }
  if (this != internal_default_instance()) {
    delete expr_;
  }
  if (this != internal_default_instance()) {
    delete address_;
  }
  if (this != internal_default_instance()) {
    delete tags_;
  }
  if (this != internal_default_instance()) {
    delete cond_;
  }
  if (this != internal_default_instance()) {
    delete stopinfos_;
  }
}

void dbainstr::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* dbainstr::descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[8].descriptor;
}

const dbainstr& dbainstr::default_instance() {
  protobuf_dba_2eproto::InitDefaults();
  return *internal_default_instance();
}

dbainstr* dbainstr::New(::google::protobuf::Arena* arena) const {
  dbainstr* n = new dbainstr;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void dbainstr::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.dbainstr)
  exprs_.Clear();
  if (_has_bits_[0 / 32] & 127u) {
    if (has_location()) {
      GOOGLE_DCHECK(location_ != NULL);
      location_->::dba::dbacodeaddress::Clear();
    }
    if (has_lhs()) {
      GOOGLE_DCHECK(lhs_ != NULL);
      lhs_->::dba::dbaLhs::Clear();
    }
    if (has_expr()) {
      GOOGLE_DCHECK(expr_ != NULL);
      expr_->::dba::dbaexpr::Clear();
    }
    if (has_address()) {
      GOOGLE_DCHECK(address_ != NULL);
      address_->::dba::codeaddress::Clear();
    }
    if (has_tags()) {
      GOOGLE_DCHECK(tags_ != NULL);
      tags_->::dba::dbatag::Clear();
    }
    if (has_cond()) {
      GOOGLE_DCHECK(cond_ != NULL);
      cond_->::dba::dbacond::Clear();
    }
    if (has_stopinfos()) {
      GOOGLE_DCHECK(stopinfos_ != NULL);
      stopinfos_->::dba::dbastopstate::Clear();
    }
  }
  offset_ = 0u;
  typeid__ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool dbainstr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.dbainstr)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .dba.dbainstr.typeid_instrkind typeid = 1;
      case 1: {
        if (tag == 8u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::dbainstr_typeid_instrkind_IsValid(value)) {
            set_typeid_(static_cast< ::dba::dbainstr_typeid_instrkind >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .dba.dbacodeaddress location = 2;
      case 2: {
        if (tag == 18u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbaLhs lhs = 3;
      case 3: {
        if (tag == 26u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lhs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbaexpr expr = 4;
      case 4: {
        if (tag == 34u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_expr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 offset = 5;
      case 5: {
        if (tag == 40u) {
          set_has_offset();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.codeaddress address = 6;
      case 6: {
        if (tag == 50u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_address()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbatag tags = 7;
      case 7: {
        if (tag == 58u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tags()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbacond cond = 8;
      case 8: {
        if (tag == 66u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cond()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbastopstate stopinfos = 9;
      case 9: {
        if (tag == 74u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stopinfos()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .dba.dbaexpr exprs = 10;
      case 10: {
        if (tag == 82u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_exprs()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.dbainstr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.dbainstr)
  return false;
#undef DO_
}

void dbainstr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.dbainstr)
  // required .dba.dbainstr.typeid_instrkind typeid = 1;
  if (has_typeid_()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  // required .dba.dbacodeaddress location = 2;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->location_, output);
  }

  // optional .dba.dbaLhs lhs = 3;
  if (has_lhs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->lhs_, output);
  }

  // optional .dba.dbaexpr expr = 4;
  if (has_expr()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->expr_, output);
  }

  // optional uint32 offset = 5;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->offset(), output);
  }

  // optional .dba.codeaddress address = 6;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->address_, output);
  }

  // optional .dba.dbatag tags = 7;
  if (has_tags()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->tags_, output);
  }

  // optional .dba.dbacond cond = 8;
  if (has_cond()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->cond_, output);
  }

  // optional .dba.dbastopstate stopinfos = 9;
  if (has_stopinfos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->stopinfos_, output);
  }

  // repeated .dba.dbaexpr exprs = 10;
  for (unsigned int i = 0, n = this->exprs_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->exprs(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.dbainstr)
}

::google::protobuf::uint8* dbainstr::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:dba.dbainstr)
  // required .dba.dbainstr.typeid_instrkind typeid = 1;
  if (has_typeid_()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  // required .dba.dbacodeaddress location = 2;
  if (has_location()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->location_, false, target);
  }

  // optional .dba.dbaLhs lhs = 3;
  if (has_lhs()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->lhs_, false, target);
  }

  // optional .dba.dbaexpr expr = 4;
  if (has_expr()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->expr_, false, target);
  }

  // optional uint32 offset = 5;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->offset(), target);
  }

  // optional .dba.codeaddress address = 6;
  if (has_address()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->address_, false, target);
  }

  // optional .dba.dbatag tags = 7;
  if (has_tags()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->tags_, false, target);
  }

  // optional .dba.dbacond cond = 8;
  if (has_cond()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *this->cond_, false, target);
  }

  // optional .dba.dbastopstate stopinfos = 9;
  if (has_stopinfos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, *this->stopinfos_, false, target);
  }

  // repeated .dba.dbaexpr exprs = 10;
  for (unsigned int i = 0, n = this->exprs_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        10, this->exprs(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.dbainstr)
  return target;
}

size_t dbainstr::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:dba.dbainstr)
  size_t total_size = 0;

  if (has_location()) {
    // required .dba.dbacodeaddress location = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->location_);
  }

  if (has_typeid_()) {
    // required .dba.dbainstr.typeid_instrkind typeid = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->typeid_());
  }

  return total_size;
}
size_t dbainstr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.dbainstr)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000101) ^ 0x00000101) == 0) {  // All required fields are present.
    // required .dba.dbacodeaddress location = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->location_);

    // required .dba.dbainstr.typeid_instrkind typeid = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->typeid_());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated .dba.dbaexpr exprs = 10;
  {
    unsigned int count = this->exprs_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exprs(i));
    }
  }

  if (_has_bits_[0 / 32] & 254u) {
    // optional .dba.dbaLhs lhs = 3;
    if (has_lhs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->lhs_);
    }

    // optional .dba.dbaexpr expr = 4;
    if (has_expr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->expr_);
    }

    // optional .dba.codeaddress address = 6;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->address_);
    }

    // optional .dba.dbatag tags = 7;
    if (has_tags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->tags_);
    }

    // optional .dba.dbacond cond = 8;
    if (has_cond()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->cond_);
    }

    // optional .dba.dbastopstate stopinfos = 9;
    if (has_stopinfos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->stopinfos_);
    }

    // optional uint32 offset = 5;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->offset());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void dbainstr::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.dbainstr)
  GOOGLE_DCHECK_NE(&from, this);
  const dbainstr* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const dbainstr>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.dbainstr)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.dbainstr)
    MergeFrom(*source);
  }
}

void dbainstr::MergeFrom(const dbainstr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.dbainstr)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  exprs_.MergeFrom(from.exprs_);
  if (from._has_bits_[0 / 32] & 255u) {
    if (from.has_location()) {
      mutable_location()->::dba::dbacodeaddress::MergeFrom(from.location());
    }
    if (from.has_lhs()) {
      mutable_lhs()->::dba::dbaLhs::MergeFrom(from.lhs());
    }
    if (from.has_expr()) {
      mutable_expr()->::dba::dbaexpr::MergeFrom(from.expr());
    }
    if (from.has_address()) {
      mutable_address()->::dba::codeaddress::MergeFrom(from.address());
    }
    if (from.has_tags()) {
      mutable_tags()->::dba::dbatag::MergeFrom(from.tags());
    }
    if (from.has_cond()) {
      mutable_cond()->::dba::dbacond::MergeFrom(from.cond());
    }
    if (from.has_stopinfos()) {
      mutable_stopinfos()->::dba::dbastopstate::MergeFrom(from.stopinfos());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
  }
  if (from.has_typeid_()) {
    set_typeid_(from.typeid_());
  }
}

void dbainstr::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.dbainstr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void dbainstr::CopyFrom(const dbainstr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.dbainstr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool dbainstr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000101) != 0x00000101) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->exprs())) return false;
  if (has_location()) {
    if (!this->location_->IsInitialized()) return false;
  }
  if (has_lhs()) {
    if (!this->lhs_->IsInitialized()) return false;
  }
  if (has_expr()) {
    if (!this->expr_->IsInitialized()) return false;
  }
  if (has_address()) {
    if (!this->address_->IsInitialized()) return false;
  }
  if (has_tags()) {
    if (!this->tags_->IsInitialized()) return false;
  }
  if (has_cond()) {
    if (!this->cond_->IsInitialized()) return false;
  }
  if (has_stopinfos()) {
    if (!this->stopinfos_->IsInitialized()) return false;
  }
  return true;
}

void dbainstr::Swap(dbainstr* other) {
  if (other == this) return;
  InternalSwap(other);
}
void dbainstr::InternalSwap(dbainstr* other) {
  exprs_.UnsafeArenaSwap(&other->exprs_);
  std::swap(location_, other->location_);
  std::swap(lhs_, other->lhs_);
  std::swap(expr_, other->expr_);
  std::swap(address_, other->address_);
  std::swap(tags_, other->tags_);
  std::swap(cond_, other->cond_);
  std::swap(stopinfos_, other->stopinfos_);
  std::swap(offset_, other->offset_);
  std::swap(typeid__, other->typeid__);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata dbainstr::GetMetadata() const {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[8];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// dbainstr

// required .dba.dbainstr.typeid_instrkind typeid = 1;
bool dbainstr::has_typeid_() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void dbainstr::set_has_typeid_() {
  _has_bits_[0] |= 0x00000100u;
}
void dbainstr::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000100u;
}
void dbainstr::clear_typeid_() {
  typeid__ = 1;
  clear_has_typeid_();
}
::dba::dbainstr_typeid_instrkind dbainstr::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.typeid)
  return static_cast< ::dba::dbainstr_typeid_instrkind >(typeid__);
}
void dbainstr::set_typeid_(::dba::dbainstr_typeid_instrkind value) {
  assert(::dba::dbainstr_typeid_instrkind_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbainstr.typeid)
}

// required .dba.dbacodeaddress location = 2;
bool dbainstr::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void dbainstr::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
void dbainstr::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
void dbainstr::clear_location() {
  if (location_ != NULL) location_->::dba::dbacodeaddress::Clear();
  clear_has_location();
}
const ::dba::dbacodeaddress& dbainstr::location() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.location)
  return location_ != NULL ? *location_
                         : *::dba::dbacodeaddress::internal_default_instance();
}
::dba::dbacodeaddress* dbainstr::mutable_location() {
  set_has_location();
  if (location_ == NULL) {
    location_ = new ::dba::dbacodeaddress;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.location)
  return location_;
}
::dba::dbacodeaddress* dbainstr::release_location() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.location)
  clear_has_location();
  ::dba::dbacodeaddress* temp = location_;
  location_ = NULL;
  return temp;
}
void dbainstr::set_allocated_location(::dba::dbacodeaddress* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.location)
}

// optional .dba.dbaLhs lhs = 3;
bool dbainstr::has_lhs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void dbainstr::set_has_lhs() {
  _has_bits_[0] |= 0x00000002u;
}
void dbainstr::clear_has_lhs() {
  _has_bits_[0] &= ~0x00000002u;
}
void dbainstr::clear_lhs() {
  if (lhs_ != NULL) lhs_->::dba::dbaLhs::Clear();
  clear_has_lhs();
}
const ::dba::dbaLhs& dbainstr::lhs() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.lhs)
  return lhs_ != NULL ? *lhs_
                         : *::dba::dbaLhs::internal_default_instance();
}
::dba::dbaLhs* dbainstr::mutable_lhs() {
  set_has_lhs();
  if (lhs_ == NULL) {
    lhs_ = new ::dba::dbaLhs;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.lhs)
  return lhs_;
}
::dba::dbaLhs* dbainstr::release_lhs() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.lhs)
  clear_has_lhs();
  ::dba::dbaLhs* temp = lhs_;
  lhs_ = NULL;
  return temp;
}
void dbainstr::set_allocated_lhs(::dba::dbaLhs* lhs) {
  delete lhs_;
  lhs_ = lhs;
  if (lhs) {
    set_has_lhs();
  } else {
    clear_has_lhs();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.lhs)
}

// optional .dba.dbaexpr expr = 4;
bool dbainstr::has_expr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void dbainstr::set_has_expr() {
  _has_bits_[0] |= 0x00000004u;
}
void dbainstr::clear_has_expr() {
  _has_bits_[0] &= ~0x00000004u;
}
void dbainstr::clear_expr() {
  if (expr_ != NULL) expr_->::dba::dbaexpr::Clear();
  clear_has_expr();
}
const ::dba::dbaexpr& dbainstr::expr() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.expr)
  return expr_ != NULL ? *expr_
                         : *::dba::dbaexpr::internal_default_instance();
}
::dba::dbaexpr* dbainstr::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) {
    expr_ = new ::dba::dbaexpr;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.expr)
  return expr_;
}
::dba::dbaexpr* dbainstr::release_expr() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.expr)
  clear_has_expr();
  ::dba::dbaexpr* temp = expr_;
  expr_ = NULL;
  return temp;
}
void dbainstr::set_allocated_expr(::dba::dbaexpr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.expr)
}

// optional uint32 offset = 5;
bool dbainstr::has_offset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void dbainstr::set_has_offset() {
  _has_bits_[0] |= 0x00000080u;
}
void dbainstr::clear_has_offset() {
  _has_bits_[0] &= ~0x00000080u;
}
void dbainstr::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
::google::protobuf::uint32 dbainstr::offset() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.offset)
  return offset_;
}
void dbainstr::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:dba.dbainstr.offset)
}

// optional .dba.codeaddress address = 6;
bool dbainstr::has_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void dbainstr::set_has_address() {
  _has_bits_[0] |= 0x00000008u;
}
void dbainstr::clear_has_address() {
  _has_bits_[0] &= ~0x00000008u;
}
void dbainstr::clear_address() {
  if (address_ != NULL) address_->::dba::codeaddress::Clear();
  clear_has_address();
}
const ::dba::codeaddress& dbainstr::address() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.address)
  return address_ != NULL ? *address_
                         : *::dba::codeaddress::internal_default_instance();
}
::dba::codeaddress* dbainstr::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    address_ = new ::dba::codeaddress;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.address)
  return address_;
}
::dba::codeaddress* dbainstr::release_address() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.address)
  clear_has_address();
  ::dba::codeaddress* temp = address_;
  address_ = NULL;
  return temp;
}
void dbainstr::set_allocated_address(::dba::codeaddress* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.address)
}

// optional .dba.dbatag tags = 7;
bool dbainstr::has_tags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void dbainstr::set_has_tags() {
  _has_bits_[0] |= 0x00000010u;
}
void dbainstr::clear_has_tags() {
  _has_bits_[0] &= ~0x00000010u;
}
void dbainstr::clear_tags() {
  if (tags_ != NULL) tags_->::dba::dbatag::Clear();
  clear_has_tags();
}
const ::dba::dbatag& dbainstr::tags() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.tags)
  return tags_ != NULL ? *tags_
                         : *::dba::dbatag::internal_default_instance();
}
::dba::dbatag* dbainstr::mutable_tags() {
  set_has_tags();
  if (tags_ == NULL) {
    tags_ = new ::dba::dbatag;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.tags)
  return tags_;
}
::dba::dbatag* dbainstr::release_tags() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.tags)
  clear_has_tags();
  ::dba::dbatag* temp = tags_;
  tags_ = NULL;
  return temp;
}
void dbainstr::set_allocated_tags(::dba::dbatag* tags) {
  delete tags_;
  tags_ = tags;
  if (tags) {
    set_has_tags();
  } else {
    clear_has_tags();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.tags)
}

// optional .dba.dbacond cond = 8;
bool dbainstr::has_cond() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void dbainstr::set_has_cond() {
  _has_bits_[0] |= 0x00000020u;
}
void dbainstr::clear_has_cond() {
  _has_bits_[0] &= ~0x00000020u;
}
void dbainstr::clear_cond() {
  if (cond_ != NULL) cond_->::dba::dbacond::Clear();
  clear_has_cond();
}
const ::dba::dbacond& dbainstr::cond() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.cond)
  return cond_ != NULL ? *cond_
                         : *::dba::dbacond::internal_default_instance();
}
::dba::dbacond* dbainstr::mutable_cond() {
  set_has_cond();
  if (cond_ == NULL) {
    cond_ = new ::dba::dbacond;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.cond)
  return cond_;
}
::dba::dbacond* dbainstr::release_cond() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.cond)
  clear_has_cond();
  ::dba::dbacond* temp = cond_;
  cond_ = NULL;
  return temp;
}
void dbainstr::set_allocated_cond(::dba::dbacond* cond) {
  delete cond_;
  cond_ = cond;
  if (cond) {
    set_has_cond();
  } else {
    clear_has_cond();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.cond)
}

// optional .dba.dbastopstate stopinfos = 9;
bool dbainstr::has_stopinfos() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void dbainstr::set_has_stopinfos() {
  _has_bits_[0] |= 0x00000040u;
}
void dbainstr::clear_has_stopinfos() {
  _has_bits_[0] &= ~0x00000040u;
}
void dbainstr::clear_stopinfos() {
  if (stopinfos_ != NULL) stopinfos_->::dba::dbastopstate::Clear();
  clear_has_stopinfos();
}
const ::dba::dbastopstate& dbainstr::stopinfos() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.stopinfos)
  return stopinfos_ != NULL ? *stopinfos_
                         : *::dba::dbastopstate::internal_default_instance();
}
::dba::dbastopstate* dbainstr::mutable_stopinfos() {
  set_has_stopinfos();
  if (stopinfos_ == NULL) {
    stopinfos_ = new ::dba::dbastopstate;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.stopinfos)
  return stopinfos_;
}
::dba::dbastopstate* dbainstr::release_stopinfos() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.stopinfos)
  clear_has_stopinfos();
  ::dba::dbastopstate* temp = stopinfos_;
  stopinfos_ = NULL;
  return temp;
}
void dbainstr::set_allocated_stopinfos(::dba::dbastopstate* stopinfos) {
  delete stopinfos_;
  stopinfos_ = stopinfos;
  if (stopinfos) {
    set_has_stopinfos();
  } else {
    clear_has_stopinfos();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.stopinfos)
}

// repeated .dba.dbaexpr exprs = 10;
int dbainstr::exprs_size() const {
  return exprs_.size();
}
void dbainstr::clear_exprs() {
  exprs_.Clear();
}
const ::dba::dbaexpr& dbainstr::exprs(int index) const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.exprs)
  return exprs_.Get(index);
}
::dba::dbaexpr* dbainstr::mutable_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.exprs)
  return exprs_.Mutable(index);
}
::dba::dbaexpr* dbainstr::add_exprs() {
  // @@protoc_insertion_point(field_add:dba.dbainstr.exprs)
  return exprs_.Add();
}
::google::protobuf::RepeatedPtrField< ::dba::dbaexpr >*
dbainstr::mutable_exprs() {
  // @@protoc_insertion_point(field_mutable_list:dba.dbainstr.exprs)
  return &exprs_;
}
const ::google::protobuf::RepeatedPtrField< ::dba::dbaexpr >&
dbainstr::exprs() const {
  // @@protoc_insertion_point(field_list:dba.dbainstr.exprs)
  return exprs_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int dba_list::kInstrsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

dba_list::dba_list()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_dba_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.dba_list)
}
dba_list::dba_list(const dba_list& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      instrs_(from.instrs_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:dba.dba_list)
}

void dba_list::SharedCtor() {
  _cached_size_ = 0;
}

dba_list::~dba_list() {
  // @@protoc_insertion_point(destructor:dba.dba_list)
  SharedDtor();
}

void dba_list::SharedDtor() {
}

void dba_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* dba_list::descriptor() {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[9].descriptor;
}

const dba_list& dba_list::default_instance() {
  protobuf_dba_2eproto::InitDefaults();
  return *internal_default_instance();
}

dba_list* dba_list::New(::google::protobuf::Arena* arena) const {
  dba_list* n = new dba_list;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void dba_list::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.dba_list)
  instrs_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool dba_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.dba_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .dba.dbainstr instrs = 1;
      case 1: {
        if (tag == 10u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_instrs()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.dba_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.dba_list)
  return false;
#undef DO_
}

void dba_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.dba_list)
  // repeated .dba.dbainstr instrs = 1;
  for (unsigned int i = 0, n = this->instrs_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->instrs(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.dba_list)
}

::google::protobuf::uint8* dba_list::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:dba.dba_list)
  // repeated .dba.dbainstr instrs = 1;
  for (unsigned int i = 0, n = this->instrs_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->instrs(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.dba_list)
  return target;
}

size_t dba_list::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.dba_list)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated .dba.dbainstr instrs = 1;
  {
    unsigned int count = this->instrs_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->instrs(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void dba_list::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.dba_list)
  GOOGLE_DCHECK_NE(&from, this);
  const dba_list* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const dba_list>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.dba_list)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.dba_list)
    MergeFrom(*source);
  }
}

void dba_list::MergeFrom(const dba_list& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.dba_list)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  instrs_.MergeFrom(from.instrs_);
}

void dba_list::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.dba_list)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void dba_list::CopyFrom(const dba_list& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.dba_list)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool dba_list::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->instrs())) return false;
  return true;
}

void dba_list::Swap(dba_list* other) {
  if (other == this) return;
  InternalSwap(other);
}
void dba_list::InternalSwap(dba_list* other) {
  instrs_.UnsafeArenaSwap(&other->instrs_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata dba_list::GetMetadata() const {
  protobuf_dba_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_dba_2eproto::file_level_metadata[9];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// dba_list

// repeated .dba.dbainstr instrs = 1;
int dba_list::instrs_size() const {
  return instrs_.size();
}
void dba_list::clear_instrs() {
  instrs_.Clear();
}
const ::dba::dbainstr& dba_list::instrs(int index) const {
  // @@protoc_insertion_point(field_get:dba.dba_list.instrs)
  return instrs_.Get(index);
}
::dba::dbainstr* dba_list::mutable_instrs(int index) {
  // @@protoc_insertion_point(field_mutable:dba.dba_list.instrs)
  return instrs_.Mutable(index);
}
::dba::dbainstr* dba_list::add_instrs() {
  // @@protoc_insertion_point(field_add:dba.dba_list.instrs)
  return instrs_.Add();
}
::google::protobuf::RepeatedPtrField< ::dba::dbainstr >*
dba_list::mutable_instrs() {
  // @@protoc_insertion_point(field_mutable_list:dba.dba_list.instrs)
  return &instrs_;
}
const ::google::protobuf::RepeatedPtrField< ::dba::dbainstr >&
dba_list::instrs() const {
  // @@protoc_insertion_point(field_list:dba.dba_list.instrs)
  return instrs_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace dba

// @@protoc_insertion_point(global_scope)
