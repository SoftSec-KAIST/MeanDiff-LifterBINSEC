// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dba.proto

#ifndef PROTOBUF_dba_2eproto__INCLUDED
#define PROTOBUF_dba_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace dba {
class bitvector;
class bitvectorDefaultTypeInternal;
extern bitvectorDefaultTypeInternal _bitvector_default_instance_;
class codeaddress;
class codeaddressDefaultTypeInternal;
extern codeaddressDefaultTypeInternal _codeaddress_default_instance_;
class dbaLhs;
class dbaLhsDefaultTypeInternal;
extern dbaLhsDefaultTypeInternal _dbaLhs_default_instance_;
class dba_list;
class dba_listDefaultTypeInternal;
extern dba_listDefaultTypeInternal _dba_list_default_instance_;
class dbacodeaddress;
class dbacodeaddressDefaultTypeInternal;
extern dbacodeaddressDefaultTypeInternal _dbacodeaddress_default_instance_;
class dbacond;
class dbacondDefaultTypeInternal;
extern dbacondDefaultTypeInternal _dbacond_default_instance_;
class dbaexpr;
class dbaexprDefaultTypeInternal;
extern dbaexprDefaultTypeInternal _dbaexpr_default_instance_;
class dbainstr;
class dbainstrDefaultTypeInternal;
extern dbainstrDefaultTypeInternal _dbainstr_default_instance_;
class dbastopstate;
class dbastopstateDefaultTypeInternal;
extern dbastopstateDefaultTypeInternal _dbastopstate_default_instance_;
class dbatag;
class dbatagDefaultTypeInternal;
extern dbatagDefaultTypeInternal _dbatag_default_instance_;
}  // namespace dba

namespace dba {

namespace protobuf_dba_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_dba_2eproto

enum codeaddress_typeid_codeaddress {
  codeaddress_typeid_codeaddress_Local = 0,
  codeaddress_typeid_codeaddress_NonLocal = 1
};
bool codeaddress_typeid_codeaddress_IsValid(int value);
const codeaddress_typeid_codeaddress codeaddress_typeid_codeaddress_typeid_codeaddress_MIN = codeaddress_typeid_codeaddress_Local;
const codeaddress_typeid_codeaddress codeaddress_typeid_codeaddress_typeid_codeaddress_MAX = codeaddress_typeid_codeaddress_NonLocal;
const int codeaddress_typeid_codeaddress_typeid_codeaddress_ARRAYSIZE = codeaddress_typeid_codeaddress_typeid_codeaddress_MAX + 1;

const ::google::protobuf::EnumDescriptor* codeaddress_typeid_codeaddress_descriptor();
inline const ::std::string& codeaddress_typeid_codeaddress_Name(codeaddress_typeid_codeaddress value) {
  return ::google::protobuf::internal::NameOfEnum(
    codeaddress_typeid_codeaddress_descriptor(), value);
}
inline bool codeaddress_typeid_codeaddress_Parse(
    const ::std::string& name, codeaddress_typeid_codeaddress* value) {
  return ::google::protobuf::internal::ParseNamedEnum<codeaddress_typeid_codeaddress>(
    codeaddress_typeid_codeaddress_descriptor(), name, value);
}
enum dbatag_typeid_dbatag {
  dbatag_typeid_dbatag_DbaCall = 1,
  dbatag_typeid_dbatag_DbaReturn = 2
};
bool dbatag_typeid_dbatag_IsValid(int value);
const dbatag_typeid_dbatag dbatag_typeid_dbatag_typeid_dbatag_MIN = dbatag_typeid_dbatag_DbaCall;
const dbatag_typeid_dbatag dbatag_typeid_dbatag_typeid_dbatag_MAX = dbatag_typeid_dbatag_DbaReturn;
const int dbatag_typeid_dbatag_typeid_dbatag_ARRAYSIZE = dbatag_typeid_dbatag_typeid_dbatag_MAX + 1;

const ::google::protobuf::EnumDescriptor* dbatag_typeid_dbatag_descriptor();
inline const ::std::string& dbatag_typeid_dbatag_Name(dbatag_typeid_dbatag value) {
  return ::google::protobuf::internal::NameOfEnum(
    dbatag_typeid_dbatag_descriptor(), value);
}
inline bool dbatag_typeid_dbatag_Parse(
    const ::std::string& name, dbatag_typeid_dbatag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<dbatag_typeid_dbatag>(
    dbatag_typeid_dbatag_descriptor(), name, value);
}
enum dbastopstate_typeid_dbastate {
  dbastopstate_typeid_dbastate_Ok = 1,
  dbastopstate_typeid_dbastate_Ko = 2,
  dbastopstate_typeid_dbastate_Undefined = 3,
  dbastopstate_typeid_dbastate_Unsupported = 4
};
bool dbastopstate_typeid_dbastate_IsValid(int value);
const dbastopstate_typeid_dbastate dbastopstate_typeid_dbastate_typeid_dbastate_MIN = dbastopstate_typeid_dbastate_Ok;
const dbastopstate_typeid_dbastate dbastopstate_typeid_dbastate_typeid_dbastate_MAX = dbastopstate_typeid_dbastate_Unsupported;
const int dbastopstate_typeid_dbastate_typeid_dbastate_ARRAYSIZE = dbastopstate_typeid_dbastate_typeid_dbastate_MAX + 1;

const ::google::protobuf::EnumDescriptor* dbastopstate_typeid_dbastate_descriptor();
inline const ::std::string& dbastopstate_typeid_dbastate_Name(dbastopstate_typeid_dbastate value) {
  return ::google::protobuf::internal::NameOfEnum(
    dbastopstate_typeid_dbastate_descriptor(), value);
}
inline bool dbastopstate_typeid_dbastate_Parse(
    const ::std::string& name, dbastopstate_typeid_dbastate* value) {
  return ::google::protobuf::internal::ParseNamedEnum<dbastopstate_typeid_dbastate>(
    dbastopstate_typeid_dbastate_descriptor(), name, value);
}
enum dbaexpr_typeid_dbaexpr {
  dbaexpr_typeid_dbaexpr_DbaExprVar = 1,
  dbaexpr_typeid_dbaexpr_DbaLoad = 2,
  dbaexpr_typeid_dbaexpr_DbaExprCst = 3,
  dbaexpr_typeid_dbaexpr_DbaExprUnary = 4,
  dbaexpr_typeid_dbaexpr_DbaExprBinary = 5,
  dbaexpr_typeid_dbaexpr_DbaExprRestrict = 6,
  dbaexpr_typeid_dbaexpr_DbaExprExtU = 7,
  dbaexpr_typeid_dbaexpr_DbaExprExtS = 8,
  dbaexpr_typeid_dbaexpr_DbaExprIte = 9,
  dbaexpr_typeid_dbaexpr_DbaExprAlternative = 10
};
bool dbaexpr_typeid_dbaexpr_IsValid(int value);
const dbaexpr_typeid_dbaexpr dbaexpr_typeid_dbaexpr_typeid_dbaexpr_MIN = dbaexpr_typeid_dbaexpr_DbaExprVar;
const dbaexpr_typeid_dbaexpr dbaexpr_typeid_dbaexpr_typeid_dbaexpr_MAX = dbaexpr_typeid_dbaexpr_DbaExprAlternative;
const int dbaexpr_typeid_dbaexpr_typeid_dbaexpr_ARRAYSIZE = dbaexpr_typeid_dbaexpr_typeid_dbaexpr_MAX + 1;

const ::google::protobuf::EnumDescriptor* dbaexpr_typeid_dbaexpr_descriptor();
inline const ::std::string& dbaexpr_typeid_dbaexpr_Name(dbaexpr_typeid_dbaexpr value) {
  return ::google::protobuf::internal::NameOfEnum(
    dbaexpr_typeid_dbaexpr_descriptor(), value);
}
inline bool dbaexpr_typeid_dbaexpr_Parse(
    const ::std::string& name, dbaexpr_typeid_dbaexpr* value) {
  return ::google::protobuf::internal::ParseNamedEnum<dbaexpr_typeid_dbaexpr>(
    dbaexpr_typeid_dbaexpr_descriptor(), name, value);
}
enum dbaexpr_dbaunary {
  dbaexpr_dbaunary_DbaUnaryMinus = 1,
  dbaexpr_dbaunary_DbaUnaryNot = 2
};
bool dbaexpr_dbaunary_IsValid(int value);
const dbaexpr_dbaunary dbaexpr_dbaunary_dbaunary_MIN = dbaexpr_dbaunary_DbaUnaryMinus;
const dbaexpr_dbaunary dbaexpr_dbaunary_dbaunary_MAX = dbaexpr_dbaunary_DbaUnaryNot;
const int dbaexpr_dbaunary_dbaunary_ARRAYSIZE = dbaexpr_dbaunary_dbaunary_MAX + 1;

const ::google::protobuf::EnumDescriptor* dbaexpr_dbaunary_descriptor();
inline const ::std::string& dbaexpr_dbaunary_Name(dbaexpr_dbaunary value) {
  return ::google::protobuf::internal::NameOfEnum(
    dbaexpr_dbaunary_descriptor(), value);
}
inline bool dbaexpr_dbaunary_Parse(
    const ::std::string& name, dbaexpr_dbaunary* value) {
  return ::google::protobuf::internal::ParseNamedEnum<dbaexpr_dbaunary>(
    dbaexpr_dbaunary_descriptor(), name, value);
}
enum dbaexpr_dbabinary {
  dbaexpr_dbabinary_DbaPlus = 1,
  dbaexpr_dbabinary_DbaMinus = 2,
  dbaexpr_dbabinary_DbaMultU = 3,
  dbaexpr_dbabinary_DbaMultS = 4,
  dbaexpr_dbabinary_DbaDivU = 6,
  dbaexpr_dbabinary_DbaDivS = 7,
  dbaexpr_dbabinary_DbaModU = 8,
  dbaexpr_dbabinary_DbaModS = 9,
  dbaexpr_dbabinary_DbaOr = 10,
  dbaexpr_dbabinary_DbaAnd = 11,
  dbaexpr_dbabinary_DbaXor = 12,
  dbaexpr_dbabinary_DbaConcat = 13,
  dbaexpr_dbabinary_DbaLShiftU = 14,
  dbaexpr_dbabinary_DbaRShiftU = 15,
  dbaexpr_dbabinary_DbaRShiftS = 16,
  dbaexpr_dbabinary_DbaLeftRotate = 17,
  dbaexpr_dbabinary_DbaRightRotate = 18,
  dbaexpr_dbabinary_DbaEq = 19,
  dbaexpr_dbabinary_DbaDiff = 20,
  dbaexpr_dbabinary_DbaLeqU = 21,
  dbaexpr_dbabinary_DbaLtU = 22,
  dbaexpr_dbabinary_DbaGeqU = 23,
  dbaexpr_dbabinary_DbaGtU = 24,
  dbaexpr_dbabinary_DbaLeqS = 25,
  dbaexpr_dbabinary_DbaLtS = 26,
  dbaexpr_dbabinary_DbaGeqS = 27,
  dbaexpr_dbabinary_DbaGtS = 28
};
bool dbaexpr_dbabinary_IsValid(int value);
const dbaexpr_dbabinary dbaexpr_dbabinary_dbabinary_MIN = dbaexpr_dbabinary_DbaPlus;
const dbaexpr_dbabinary dbaexpr_dbabinary_dbabinary_MAX = dbaexpr_dbabinary_DbaGtS;
const int dbaexpr_dbabinary_dbabinary_ARRAYSIZE = dbaexpr_dbabinary_dbabinary_MAX + 1;

const ::google::protobuf::EnumDescriptor* dbaexpr_dbabinary_descriptor();
inline const ::std::string& dbaexpr_dbabinary_Name(dbaexpr_dbabinary value) {
  return ::google::protobuf::internal::NameOfEnum(
    dbaexpr_dbabinary_descriptor(), value);
}
inline bool dbaexpr_dbabinary_Parse(
    const ::std::string& name, dbaexpr_dbabinary* value) {
  return ::google::protobuf::internal::ParseNamedEnum<dbaexpr_dbabinary>(
    dbaexpr_dbabinary_descriptor(), name, value);
}
enum dbacond_typeid_dbacond {
  dbacond_typeid_dbacond_DbaCondReif = 1,
  dbacond_typeid_dbacond_DbaCondNot = 2,
  dbacond_typeid_dbacond_DbaCondAnd = 3,
  dbacond_typeid_dbacond_DbaCondOr = 4,
  dbacond_typeid_dbacond_DbaTrue = 5,
  dbacond_typeid_dbacond_DbaFalse = 6
};
bool dbacond_typeid_dbacond_IsValid(int value);
const dbacond_typeid_dbacond dbacond_typeid_dbacond_typeid_dbacond_MIN = dbacond_typeid_dbacond_DbaCondReif;
const dbacond_typeid_dbacond dbacond_typeid_dbacond_typeid_dbacond_MAX = dbacond_typeid_dbacond_DbaFalse;
const int dbacond_typeid_dbacond_typeid_dbacond_ARRAYSIZE = dbacond_typeid_dbacond_typeid_dbacond_MAX + 1;

const ::google::protobuf::EnumDescriptor* dbacond_typeid_dbacond_descriptor();
inline const ::std::string& dbacond_typeid_dbacond_Name(dbacond_typeid_dbacond value) {
  return ::google::protobuf::internal::NameOfEnum(
    dbacond_typeid_dbacond_descriptor(), value);
}
inline bool dbacond_typeid_dbacond_Parse(
    const ::std::string& name, dbacond_typeid_dbacond* value) {
  return ::google::protobuf::internal::ParseNamedEnum<dbacond_typeid_dbacond>(
    dbacond_typeid_dbacond_descriptor(), name, value);
}
enum dbaLhs_typeid_dbalhs {
  dbaLhs_typeid_dbalhs_DbaLhsVar = 1,
  dbaLhs_typeid_dbalhs_DbaLhsVarRestrict = 2,
  dbaLhs_typeid_dbalhs_DbaStore = 3
};
bool dbaLhs_typeid_dbalhs_IsValid(int value);
const dbaLhs_typeid_dbalhs dbaLhs_typeid_dbalhs_typeid_dbalhs_MIN = dbaLhs_typeid_dbalhs_DbaLhsVar;
const dbaLhs_typeid_dbalhs dbaLhs_typeid_dbalhs_typeid_dbalhs_MAX = dbaLhs_typeid_dbalhs_DbaStore;
const int dbaLhs_typeid_dbalhs_typeid_dbalhs_ARRAYSIZE = dbaLhs_typeid_dbalhs_typeid_dbalhs_MAX + 1;

const ::google::protobuf::EnumDescriptor* dbaLhs_typeid_dbalhs_descriptor();
inline const ::std::string& dbaLhs_typeid_dbalhs_Name(dbaLhs_typeid_dbalhs value) {
  return ::google::protobuf::internal::NameOfEnum(
    dbaLhs_typeid_dbalhs_descriptor(), value);
}
inline bool dbaLhs_typeid_dbalhs_Parse(
    const ::std::string& name, dbaLhs_typeid_dbalhs* value) {
  return ::google::protobuf::internal::ParseNamedEnum<dbaLhs_typeid_dbalhs>(
    dbaLhs_typeid_dbalhs_descriptor(), name, value);
}
enum dbainstr_typeid_instrkind {
  dbainstr_typeid_instrkind_DbaIkAssign = 1,
  dbainstr_typeid_instrkind_DbaIkSJump = 2,
  dbainstr_typeid_instrkind_DbaIkDJump = 3,
  dbainstr_typeid_instrkind_DbaIkIf = 4,
  dbainstr_typeid_instrkind_DbaIkStop = 5,
  dbainstr_typeid_instrkind_DbaIkAssert = 6,
  dbainstr_typeid_instrkind_DbaIkAssume = 7,
  dbainstr_typeid_instrkind_DbaIkNondetAssume = 8,
  dbainstr_typeid_instrkind_DbaIkNondet = 9,
  dbainstr_typeid_instrkind_DbaIkUndef = 10,
  dbainstr_typeid_instrkind_DbaIkMalloc = 11,
  dbainstr_typeid_instrkind_DbaIkFree = 12,
  dbainstr_typeid_instrkind_DbaIkPrint = 13
};
bool dbainstr_typeid_instrkind_IsValid(int value);
const dbainstr_typeid_instrkind dbainstr_typeid_instrkind_typeid_instrkind_MIN = dbainstr_typeid_instrkind_DbaIkAssign;
const dbainstr_typeid_instrkind dbainstr_typeid_instrkind_typeid_instrkind_MAX = dbainstr_typeid_instrkind_DbaIkPrint;
const int dbainstr_typeid_instrkind_typeid_instrkind_ARRAYSIZE = dbainstr_typeid_instrkind_typeid_instrkind_MAX + 1;

const ::google::protobuf::EnumDescriptor* dbainstr_typeid_instrkind_descriptor();
inline const ::std::string& dbainstr_typeid_instrkind_Name(dbainstr_typeid_instrkind value) {
  return ::google::protobuf::internal::NameOfEnum(
    dbainstr_typeid_instrkind_descriptor(), value);
}
inline bool dbainstr_typeid_instrkind_Parse(
    const ::std::string& name, dbainstr_typeid_instrkind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<dbainstr_typeid_instrkind>(
    dbainstr_typeid_instrkind_descriptor(), name, value);
}
enum endianness {
  Little = 1,
  Big = 2
};
bool endianness_IsValid(int value);
const endianness endianness_MIN = Little;
const endianness endianness_MAX = Big;
const int endianness_ARRAYSIZE = endianness_MAX + 1;

const ::google::protobuf::EnumDescriptor* endianness_descriptor();
inline const ::std::string& endianness_Name(endianness value) {
  return ::google::protobuf::internal::NameOfEnum(
    endianness_descriptor(), value);
}
inline bool endianness_Parse(
    const ::std::string& name, endianness* value) {
  return ::google::protobuf::internal::ParseNamedEnum<endianness>(
    endianness_descriptor(), name, value);
}
// ===================================================================

class bitvector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dba.bitvector) */ {
 public:
  bitvector();
  virtual ~bitvector();

  bitvector(const bitvector& from);

  inline bitvector& operator=(const bitvector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const bitvector& default_instance();

  static inline const bitvector* internal_default_instance() {
    return reinterpret_cast<const bitvector*>(
               &_bitvector_default_instance_);
  }

  void Swap(bitvector* other);

  // implements Message ----------------------------------------------

  inline bitvector* New() const PROTOBUF_FINAL { return New(NULL); }

  bitvector* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const bitvector& from);
  void MergeFrom(const bitvector& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(bitvector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 bv = 1;
  bool has_bv() const;
  void clear_bv();
  static const int kBvFieldNumber = 1;
  ::google::protobuf::uint64 bv() const;
  void set_bv(::google::protobuf::uint64 value);

  // required uint32 size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::uint32 size() const;
  void set_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dba.bitvector)
 private:
  void set_has_bv();
  void clear_has_bv();
  void set_has_size();
  void clear_has_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 bv_;
  ::google::protobuf::uint32 size_;
  friend struct  protobuf_dba_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class dbacodeaddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dba.dbacodeaddress) */ {
 public:
  dbacodeaddress();
  virtual ~dbacodeaddress();

  dbacodeaddress(const dbacodeaddress& from);

  inline dbacodeaddress& operator=(const dbacodeaddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dbacodeaddress& default_instance();

  static inline const dbacodeaddress* internal_default_instance() {
    return reinterpret_cast<const dbacodeaddress*>(
               &_dbacodeaddress_default_instance_);
  }

  void Swap(dbacodeaddress* other);

  // implements Message ----------------------------------------------

  inline dbacodeaddress* New() const PROTOBUF_FINAL { return New(NULL); }

  dbacodeaddress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const dbacodeaddress& from);
  void MergeFrom(const dbacodeaddress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(dbacodeaddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .dba.bitvector bitvector = 1;
  bool has_bitvector() const;
  void clear_bitvector();
  static const int kBitvectorFieldNumber = 1;
  const ::dba::bitvector& bitvector() const;
  ::dba::bitvector* mutable_bitvector();
  ::dba::bitvector* release_bitvector();
  void set_allocated_bitvector(::dba::bitvector* bitvector);

  // required uint32 dbaoffset = 2;
  bool has_dbaoffset() const;
  void clear_dbaoffset();
  static const int kDbaoffsetFieldNumber = 2;
  ::google::protobuf::uint32 dbaoffset() const;
  void set_dbaoffset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dba.dbacodeaddress)
 private:
  void set_has_bitvector();
  void clear_has_bitvector();
  void set_has_dbaoffset();
  void clear_has_dbaoffset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::dba::bitvector* bitvector_;
  ::google::protobuf::uint32 dbaoffset_;
  friend struct  protobuf_dba_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class codeaddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dba.codeaddress) */ {
 public:
  codeaddress();
  virtual ~codeaddress();

  codeaddress(const codeaddress& from);

  inline codeaddress& operator=(const codeaddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const codeaddress& default_instance();

  static inline const codeaddress* internal_default_instance() {
    return reinterpret_cast<const codeaddress*>(
               &_codeaddress_default_instance_);
  }

  void Swap(codeaddress* other);

  // implements Message ----------------------------------------------

  inline codeaddress* New() const PROTOBUF_FINAL { return New(NULL); }

  codeaddress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const codeaddress& from);
  void MergeFrom(const codeaddress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(codeaddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef codeaddress_typeid_codeaddress typeid_codeaddress;
  static const typeid_codeaddress Local =
    codeaddress_typeid_codeaddress_Local;
  static const typeid_codeaddress NonLocal =
    codeaddress_typeid_codeaddress_NonLocal;
  static inline bool typeid_codeaddress_IsValid(int value) {
    return codeaddress_typeid_codeaddress_IsValid(value);
  }
  static const typeid_codeaddress typeid_codeaddress_MIN =
    codeaddress_typeid_codeaddress_typeid_codeaddress_MIN;
  static const typeid_codeaddress typeid_codeaddress_MAX =
    codeaddress_typeid_codeaddress_typeid_codeaddress_MAX;
  static const int typeid_codeaddress_ARRAYSIZE =
    codeaddress_typeid_codeaddress_typeid_codeaddress_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  typeid_codeaddress_descriptor() {
    return codeaddress_typeid_codeaddress_descriptor();
  }
  static inline const ::std::string& typeid_codeaddress_Name(typeid_codeaddress value) {
    return codeaddress_typeid_codeaddress_Name(value);
  }
  static inline bool typeid_codeaddress_Parse(const ::std::string& name,
      typeid_codeaddress* value) {
    return codeaddress_typeid_codeaddress_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .dba.dbacodeaddress address = 3;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 3;
  const ::dba::dbacodeaddress& address() const;
  ::dba::dbacodeaddress* mutable_address();
  ::dba::dbacodeaddress* release_address();
  void set_allocated_address(::dba::dbacodeaddress* address);

  // required .dba.codeaddress.typeid_codeaddress typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  ::dba::codeaddress_typeid_codeaddress typeid_() const;
  void set_typeid_(::dba::codeaddress_typeid_codeaddress value);

  // optional uint32 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:dba.codeaddress)
 private:
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_offset();
  void clear_has_offset();
  void set_has_address();
  void clear_has_address();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::dba::dbacodeaddress* address_;
  int typeid__;
  ::google::protobuf::uint32 offset_;
  friend struct  protobuf_dba_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class dbatag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dba.dbatag) */ {
 public:
  dbatag();
  virtual ~dbatag();

  dbatag(const dbatag& from);

  inline dbatag& operator=(const dbatag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dbatag& default_instance();

  static inline const dbatag* internal_default_instance() {
    return reinterpret_cast<const dbatag*>(
               &_dbatag_default_instance_);
  }

  void Swap(dbatag* other);

  // implements Message ----------------------------------------------

  inline dbatag* New() const PROTOBUF_FINAL { return New(NULL); }

  dbatag* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const dbatag& from);
  void MergeFrom(const dbatag& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(dbatag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef dbatag_typeid_dbatag typeid_dbatag;
  static const typeid_dbatag DbaCall =
    dbatag_typeid_dbatag_DbaCall;
  static const typeid_dbatag DbaReturn =
    dbatag_typeid_dbatag_DbaReturn;
  static inline bool typeid_dbatag_IsValid(int value) {
    return dbatag_typeid_dbatag_IsValid(value);
  }
  static const typeid_dbatag typeid_dbatag_MIN =
    dbatag_typeid_dbatag_typeid_dbatag_MIN;
  static const typeid_dbatag typeid_dbatag_MAX =
    dbatag_typeid_dbatag_typeid_dbatag_MAX;
  static const int typeid_dbatag_ARRAYSIZE =
    dbatag_typeid_dbatag_typeid_dbatag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  typeid_dbatag_descriptor() {
    return dbatag_typeid_dbatag_descriptor();
  }
  static inline const ::std::string& typeid_dbatag_Name(typeid_dbatag value) {
    return dbatag_typeid_dbatag_Name(value);
  }
  static inline bool typeid_dbatag_Parse(const ::std::string& name,
      typeid_dbatag* value) {
    return dbatag_typeid_dbatag_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .dba.dbacodeaddress address = 2;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::dba::dbacodeaddress& address() const;
  ::dba::dbacodeaddress* mutable_address();
  ::dba::dbacodeaddress* release_address();
  void set_allocated_address(::dba::dbacodeaddress* address);

  // required .dba.dbatag.typeid_dbatag typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  ::dba::dbatag_typeid_dbatag typeid_() const;
  void set_typeid_(::dba::dbatag_typeid_dbatag value);

  // @@protoc_insertion_point(class_scope:dba.dbatag)
 private:
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_address();
  void clear_has_address();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::dba::dbacodeaddress* address_;
  int typeid__;
  friend struct  protobuf_dba_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class dbastopstate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dba.dbastopstate) */ {
 public:
  dbastopstate();
  virtual ~dbastopstate();

  dbastopstate(const dbastopstate& from);

  inline dbastopstate& operator=(const dbastopstate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dbastopstate& default_instance();

  static inline const dbastopstate* internal_default_instance() {
    return reinterpret_cast<const dbastopstate*>(
               &_dbastopstate_default_instance_);
  }

  void Swap(dbastopstate* other);

  // implements Message ----------------------------------------------

  inline dbastopstate* New() const PROTOBUF_FINAL { return New(NULL); }

  dbastopstate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const dbastopstate& from);
  void MergeFrom(const dbastopstate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(dbastopstate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef dbastopstate_typeid_dbastate typeid_dbastate;
  static const typeid_dbastate Ok =
    dbastopstate_typeid_dbastate_Ok;
  static const typeid_dbastate Ko =
    dbastopstate_typeid_dbastate_Ko;
  static const typeid_dbastate Undefined =
    dbastopstate_typeid_dbastate_Undefined;
  static const typeid_dbastate Unsupported =
    dbastopstate_typeid_dbastate_Unsupported;
  static inline bool typeid_dbastate_IsValid(int value) {
    return dbastopstate_typeid_dbastate_IsValid(value);
  }
  static const typeid_dbastate typeid_dbastate_MIN =
    dbastopstate_typeid_dbastate_typeid_dbastate_MIN;
  static const typeid_dbastate typeid_dbastate_MAX =
    dbastopstate_typeid_dbastate_typeid_dbastate_MAX;
  static const int typeid_dbastate_ARRAYSIZE =
    dbastopstate_typeid_dbastate_typeid_dbastate_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  typeid_dbastate_descriptor() {
    return dbastopstate_typeid_dbastate_descriptor();
  }
  static inline const ::std::string& typeid_dbastate_Name(typeid_dbastate value) {
    return dbastopstate_typeid_dbastate_Name(value);
  }
  static inline bool typeid_dbastate_Parse(const ::std::string& name,
      typeid_dbastate* value) {
    return dbastopstate_typeid_dbastate_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string infos = 2;
  bool has_infos() const;
  void clear_infos();
  static const int kInfosFieldNumber = 2;
  const ::std::string& infos() const;
  void set_infos(const ::std::string& value);
  #if LANG_CXX11
  void set_infos(::std::string&& value);
  #endif
  void set_infos(const char* value);
  void set_infos(const char* value, size_t size);
  ::std::string* mutable_infos();
  ::std::string* release_infos();
  void set_allocated_infos(::std::string* infos);

  // required .dba.dbastopstate.typeid_dbastate typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  ::dba::dbastopstate_typeid_dbastate typeid_() const;
  void set_typeid_(::dba::dbastopstate_typeid_dbastate value);

  // @@protoc_insertion_point(class_scope:dba.dbastopstate)
 private:
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_infos();
  void clear_has_infos();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr infos_;
  int typeid__;
  friend struct  protobuf_dba_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class dbaexpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dba.dbaexpr) */ {
 public:
  dbaexpr();
  virtual ~dbaexpr();

  dbaexpr(const dbaexpr& from);

  inline dbaexpr& operator=(const dbaexpr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dbaexpr& default_instance();

  static inline const dbaexpr* internal_default_instance() {
    return reinterpret_cast<const dbaexpr*>(
               &_dbaexpr_default_instance_);
  }

  void Swap(dbaexpr* other);

  // implements Message ----------------------------------------------

  inline dbaexpr* New() const PROTOBUF_FINAL { return New(NULL); }

  dbaexpr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const dbaexpr& from);
  void MergeFrom(const dbaexpr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(dbaexpr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef dbaexpr_typeid_dbaexpr typeid_dbaexpr;
  static const typeid_dbaexpr DbaExprVar =
    dbaexpr_typeid_dbaexpr_DbaExprVar;
  static const typeid_dbaexpr DbaLoad =
    dbaexpr_typeid_dbaexpr_DbaLoad;
  static const typeid_dbaexpr DbaExprCst =
    dbaexpr_typeid_dbaexpr_DbaExprCst;
  static const typeid_dbaexpr DbaExprUnary =
    dbaexpr_typeid_dbaexpr_DbaExprUnary;
  static const typeid_dbaexpr DbaExprBinary =
    dbaexpr_typeid_dbaexpr_DbaExprBinary;
  static const typeid_dbaexpr DbaExprRestrict =
    dbaexpr_typeid_dbaexpr_DbaExprRestrict;
  static const typeid_dbaexpr DbaExprExtU =
    dbaexpr_typeid_dbaexpr_DbaExprExtU;
  static const typeid_dbaexpr DbaExprExtS =
    dbaexpr_typeid_dbaexpr_DbaExprExtS;
  static const typeid_dbaexpr DbaExprIte =
    dbaexpr_typeid_dbaexpr_DbaExprIte;
  static const typeid_dbaexpr DbaExprAlternative =
    dbaexpr_typeid_dbaexpr_DbaExprAlternative;
  static inline bool typeid_dbaexpr_IsValid(int value) {
    return dbaexpr_typeid_dbaexpr_IsValid(value);
  }
  static const typeid_dbaexpr typeid_dbaexpr_MIN =
    dbaexpr_typeid_dbaexpr_typeid_dbaexpr_MIN;
  static const typeid_dbaexpr typeid_dbaexpr_MAX =
    dbaexpr_typeid_dbaexpr_typeid_dbaexpr_MAX;
  static const int typeid_dbaexpr_ARRAYSIZE =
    dbaexpr_typeid_dbaexpr_typeid_dbaexpr_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  typeid_dbaexpr_descriptor() {
    return dbaexpr_typeid_dbaexpr_descriptor();
  }
  static inline const ::std::string& typeid_dbaexpr_Name(typeid_dbaexpr value) {
    return dbaexpr_typeid_dbaexpr_Name(value);
  }
  static inline bool typeid_dbaexpr_Parse(const ::std::string& name,
      typeid_dbaexpr* value) {
    return dbaexpr_typeid_dbaexpr_Parse(name, value);
  }

  typedef dbaexpr_dbaunary dbaunary;
  static const dbaunary DbaUnaryMinus =
    dbaexpr_dbaunary_DbaUnaryMinus;
  static const dbaunary DbaUnaryNot =
    dbaexpr_dbaunary_DbaUnaryNot;
  static inline bool dbaunary_IsValid(int value) {
    return dbaexpr_dbaunary_IsValid(value);
  }
  static const dbaunary dbaunary_MIN =
    dbaexpr_dbaunary_dbaunary_MIN;
  static const dbaunary dbaunary_MAX =
    dbaexpr_dbaunary_dbaunary_MAX;
  static const int dbaunary_ARRAYSIZE =
    dbaexpr_dbaunary_dbaunary_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  dbaunary_descriptor() {
    return dbaexpr_dbaunary_descriptor();
  }
  static inline const ::std::string& dbaunary_Name(dbaunary value) {
    return dbaexpr_dbaunary_Name(value);
  }
  static inline bool dbaunary_Parse(const ::std::string& name,
      dbaunary* value) {
    return dbaexpr_dbaunary_Parse(name, value);
  }

  typedef dbaexpr_dbabinary dbabinary;
  static const dbabinary DbaPlus =
    dbaexpr_dbabinary_DbaPlus;
  static const dbabinary DbaMinus =
    dbaexpr_dbabinary_DbaMinus;
  static const dbabinary DbaMultU =
    dbaexpr_dbabinary_DbaMultU;
  static const dbabinary DbaMultS =
    dbaexpr_dbabinary_DbaMultS;
  static const dbabinary DbaDivU =
    dbaexpr_dbabinary_DbaDivU;
  static const dbabinary DbaDivS =
    dbaexpr_dbabinary_DbaDivS;
  static const dbabinary DbaModU =
    dbaexpr_dbabinary_DbaModU;
  static const dbabinary DbaModS =
    dbaexpr_dbabinary_DbaModS;
  static const dbabinary DbaOr =
    dbaexpr_dbabinary_DbaOr;
  static const dbabinary DbaAnd =
    dbaexpr_dbabinary_DbaAnd;
  static const dbabinary DbaXor =
    dbaexpr_dbabinary_DbaXor;
  static const dbabinary DbaConcat =
    dbaexpr_dbabinary_DbaConcat;
  static const dbabinary DbaLShiftU =
    dbaexpr_dbabinary_DbaLShiftU;
  static const dbabinary DbaRShiftU =
    dbaexpr_dbabinary_DbaRShiftU;
  static const dbabinary DbaRShiftS =
    dbaexpr_dbabinary_DbaRShiftS;
  static const dbabinary DbaLeftRotate =
    dbaexpr_dbabinary_DbaLeftRotate;
  static const dbabinary DbaRightRotate =
    dbaexpr_dbabinary_DbaRightRotate;
  static const dbabinary DbaEq =
    dbaexpr_dbabinary_DbaEq;
  static const dbabinary DbaDiff =
    dbaexpr_dbabinary_DbaDiff;
  static const dbabinary DbaLeqU =
    dbaexpr_dbabinary_DbaLeqU;
  static const dbabinary DbaLtU =
    dbaexpr_dbabinary_DbaLtU;
  static const dbabinary DbaGeqU =
    dbaexpr_dbabinary_DbaGeqU;
  static const dbabinary DbaGtU =
    dbaexpr_dbabinary_DbaGtU;
  static const dbabinary DbaLeqS =
    dbaexpr_dbabinary_DbaLeqS;
  static const dbabinary DbaLtS =
    dbaexpr_dbabinary_DbaLtS;
  static const dbabinary DbaGeqS =
    dbaexpr_dbabinary_DbaGeqS;
  static const dbabinary DbaGtS =
    dbaexpr_dbabinary_DbaGtS;
  static inline bool dbabinary_IsValid(int value) {
    return dbaexpr_dbabinary_IsValid(value);
  }
  static const dbabinary dbabinary_MIN =
    dbaexpr_dbabinary_dbabinary_MIN;
  static const dbabinary dbabinary_MAX =
    dbaexpr_dbabinary_dbabinary_MAX;
  static const int dbabinary_ARRAYSIZE =
    dbaexpr_dbabinary_dbabinary_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  dbabinary_descriptor() {
    return dbaexpr_dbabinary_descriptor();
  }
  static inline const ::std::string& dbabinary_Name(dbabinary value) {
    return dbaexpr_dbabinary_Name(value);
  }
  static inline bool dbabinary_Parse(const ::std::string& name,
      dbabinary* value) {
    return dbaexpr_dbabinary_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .dba.bitvector bitvector = 5;
  bool has_bitvector() const;
  void clear_bitvector();
  static const int kBitvectorFieldNumber = 5;
  const ::dba::bitvector& bitvector() const;
  ::dba::bitvector* mutable_bitvector();
  ::dba::bitvector* release_bitvector();
  void set_allocated_bitvector(::dba::bitvector* bitvector);

  // optional .dba.dbaexpr expr1 = 6;
  bool has_expr1() const;
  void clear_expr1();
  static const int kExpr1FieldNumber = 6;
  const ::dba::dbaexpr& expr1() const;
  ::dba::dbaexpr* mutable_expr1();
  ::dba::dbaexpr* release_expr1();
  void set_allocated_expr1(::dba::dbaexpr* expr1);

  // optional .dba.dbaexpr expr2 = 7;
  bool has_expr2() const;
  void clear_expr2();
  static const int kExpr2FieldNumber = 7;
  const ::dba::dbaexpr& expr2() const;
  ::dba::dbaexpr* mutable_expr2();
  ::dba::dbaexpr* release_expr2();
  void set_allocated_expr2(::dba::dbaexpr* expr2);

  // optional .dba.dbacond cond = 13;
  bool has_cond() const;
  void clear_cond();
  static const int kCondFieldNumber = 13;
  const ::dba::dbacond& cond() const;
  ::dba::dbacond* mutable_cond();
  ::dba::dbacond* release_cond();
  void set_allocated_cond(::dba::dbacond* cond);

  // optional uint32 size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::uint32 size() const;
  void set_size(::google::protobuf::uint32 value);

  // optional uint32 low = 11;
  bool has_low() const;
  void clear_low();
  static const int kLowFieldNumber = 11;
  ::google::protobuf::uint32 low() const;
  void set_low(::google::protobuf::uint32 value);

  // optional uint32 high = 12;
  bool has_high() const;
  void clear_high();
  static const int kHighFieldNumber = 12;
  ::google::protobuf::uint32 high() const;
  void set_high(::google::protobuf::uint32 value);

  // required .dba.dbaexpr.typeid_dbaexpr typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  ::dba::dbaexpr_typeid_dbaexpr typeid_() const;
  void set_typeid_(::dba::dbaexpr_typeid_dbaexpr value);

  // optional .dba.endianness endian = 4;
  bool has_endian() const;
  void clear_endian();
  static const int kEndianFieldNumber = 4;
  ::dba::endianness endian() const;
  void set_endian(::dba::endianness value);

  // optional .dba.dbaexpr.dbaunary unaryop = 9;
  bool has_unaryop() const;
  void clear_unaryop();
  static const int kUnaryopFieldNumber = 9;
  ::dba::dbaexpr_dbaunary unaryop() const;
  void set_unaryop(::dba::dbaexpr_dbaunary value);

  // optional .dba.dbaexpr.dbabinary binaryop = 10;
  bool has_binaryop() const;
  void clear_binaryop();
  static const int kBinaryopFieldNumber = 10;
  ::dba::dbaexpr_dbabinary binaryop() const;
  void set_binaryop(::dba::dbaexpr_dbabinary value);

  // @@protoc_insertion_point(class_scope:dba.dbaexpr)
 private:
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_name();
  void clear_has_name();
  void set_has_size();
  void clear_has_size();
  void set_has_endian();
  void clear_has_endian();
  void set_has_bitvector();
  void clear_has_bitvector();
  void set_has_expr1();
  void clear_has_expr1();
  void set_has_expr2();
  void clear_has_expr2();
  void set_has_unaryop();
  void clear_has_unaryop();
  void set_has_binaryop();
  void clear_has_binaryop();
  void set_has_low();
  void clear_has_low();
  void set_has_high();
  void clear_has_high();
  void set_has_cond();
  void clear_has_cond();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::dba::bitvector* bitvector_;
  ::dba::dbaexpr* expr1_;
  ::dba::dbaexpr* expr2_;
  ::dba::dbacond* cond_;
  ::google::protobuf::uint32 size_;
  ::google::protobuf::uint32 low_;
  ::google::protobuf::uint32 high_;
  int typeid__;
  int endian_;
  int unaryop_;
  int binaryop_;
  friend struct  protobuf_dba_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class dbacond : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dba.dbacond) */ {
 public:
  dbacond();
  virtual ~dbacond();

  dbacond(const dbacond& from);

  inline dbacond& operator=(const dbacond& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dbacond& default_instance();

  static inline const dbacond* internal_default_instance() {
    return reinterpret_cast<const dbacond*>(
               &_dbacond_default_instance_);
  }

  void Swap(dbacond* other);

  // implements Message ----------------------------------------------

  inline dbacond* New() const PROTOBUF_FINAL { return New(NULL); }

  dbacond* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const dbacond& from);
  void MergeFrom(const dbacond& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(dbacond* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef dbacond_typeid_dbacond typeid_dbacond;
  static const typeid_dbacond DbaCondReif =
    dbacond_typeid_dbacond_DbaCondReif;
  static const typeid_dbacond DbaCondNot =
    dbacond_typeid_dbacond_DbaCondNot;
  static const typeid_dbacond DbaCondAnd =
    dbacond_typeid_dbacond_DbaCondAnd;
  static const typeid_dbacond DbaCondOr =
    dbacond_typeid_dbacond_DbaCondOr;
  static const typeid_dbacond DbaTrue =
    dbacond_typeid_dbacond_DbaTrue;
  static const typeid_dbacond DbaFalse =
    dbacond_typeid_dbacond_DbaFalse;
  static inline bool typeid_dbacond_IsValid(int value) {
    return dbacond_typeid_dbacond_IsValid(value);
  }
  static const typeid_dbacond typeid_dbacond_MIN =
    dbacond_typeid_dbacond_typeid_dbacond_MIN;
  static const typeid_dbacond typeid_dbacond_MAX =
    dbacond_typeid_dbacond_typeid_dbacond_MAX;
  static const int typeid_dbacond_ARRAYSIZE =
    dbacond_typeid_dbacond_typeid_dbacond_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  typeid_dbacond_descriptor() {
    return dbacond_typeid_dbacond_descriptor();
  }
  static inline const ::std::string& typeid_dbacond_Name(typeid_dbacond value) {
    return dbacond_typeid_dbacond_Name(value);
  }
  static inline bool typeid_dbacond_Parse(const ::std::string& name,
      typeid_dbacond* value) {
    return dbacond_typeid_dbacond_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .dba.dbaexpr expr = 2;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 2;
  const ::dba::dbaexpr& expr() const;
  ::dba::dbaexpr* mutable_expr();
  ::dba::dbaexpr* release_expr();
  void set_allocated_expr(::dba::dbaexpr* expr);

  // optional .dba.dbacond cond1 = 3;
  bool has_cond1() const;
  void clear_cond1();
  static const int kCond1FieldNumber = 3;
  const ::dba::dbacond& cond1() const;
  ::dba::dbacond* mutable_cond1();
  ::dba::dbacond* release_cond1();
  void set_allocated_cond1(::dba::dbacond* cond1);

  // optional .dba.dbacond cond2 = 4;
  bool has_cond2() const;
  void clear_cond2();
  static const int kCond2FieldNumber = 4;
  const ::dba::dbacond& cond2() const;
  ::dba::dbacond* mutable_cond2();
  ::dba::dbacond* release_cond2();
  void set_allocated_cond2(::dba::dbacond* cond2);

  // required .dba.dbacond.typeid_dbacond typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  ::dba::dbacond_typeid_dbacond typeid_() const;
  void set_typeid_(::dba::dbacond_typeid_dbacond value);

  // @@protoc_insertion_point(class_scope:dba.dbacond)
 private:
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_expr();
  void clear_has_expr();
  void set_has_cond1();
  void clear_has_cond1();
  void set_has_cond2();
  void clear_has_cond2();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::dba::dbaexpr* expr_;
  ::dba::dbacond* cond1_;
  ::dba::dbacond* cond2_;
  int typeid__;
  friend struct  protobuf_dba_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class dbaLhs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dba.dbaLhs) */ {
 public:
  dbaLhs();
  virtual ~dbaLhs();

  dbaLhs(const dbaLhs& from);

  inline dbaLhs& operator=(const dbaLhs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dbaLhs& default_instance();

  static inline const dbaLhs* internal_default_instance() {
    return reinterpret_cast<const dbaLhs*>(
               &_dbaLhs_default_instance_);
  }

  void Swap(dbaLhs* other);

  // implements Message ----------------------------------------------

  inline dbaLhs* New() const PROTOBUF_FINAL { return New(NULL); }

  dbaLhs* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const dbaLhs& from);
  void MergeFrom(const dbaLhs& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(dbaLhs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef dbaLhs_typeid_dbalhs typeid_dbalhs;
  static const typeid_dbalhs DbaLhsVar =
    dbaLhs_typeid_dbalhs_DbaLhsVar;
  static const typeid_dbalhs DbaLhsVarRestrict =
    dbaLhs_typeid_dbalhs_DbaLhsVarRestrict;
  static const typeid_dbalhs DbaStore =
    dbaLhs_typeid_dbalhs_DbaStore;
  static inline bool typeid_dbalhs_IsValid(int value) {
    return dbaLhs_typeid_dbalhs_IsValid(value);
  }
  static const typeid_dbalhs typeid_dbalhs_MIN =
    dbaLhs_typeid_dbalhs_typeid_dbalhs_MIN;
  static const typeid_dbalhs typeid_dbalhs_MAX =
    dbaLhs_typeid_dbalhs_typeid_dbalhs_MAX;
  static const int typeid_dbalhs_ARRAYSIZE =
    dbaLhs_typeid_dbalhs_typeid_dbalhs_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  typeid_dbalhs_descriptor() {
    return dbaLhs_typeid_dbalhs_descriptor();
  }
  static inline const ::std::string& typeid_dbalhs_Name(typeid_dbalhs value) {
    return dbaLhs_typeid_dbalhs_Name(value);
  }
  static inline bool typeid_dbalhs_Parse(const ::std::string& name,
      typeid_dbalhs* value) {
    return dbaLhs_typeid_dbalhs_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .dba.dbaexpr expr = 7;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 7;
  const ::dba::dbaexpr& expr() const;
  ::dba::dbaexpr* mutable_expr();
  ::dba::dbaexpr* release_expr();
  void set_allocated_expr(::dba::dbaexpr* expr);

  // optional uint32 size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::uint32 size() const;
  void set_size(::google::protobuf::uint32 value);

  // optional uint32 low = 4;
  bool has_low() const;
  void clear_low();
  static const int kLowFieldNumber = 4;
  ::google::protobuf::uint32 low() const;
  void set_low(::google::protobuf::uint32 value);

  // optional uint32 high = 5;
  bool has_high() const;
  void clear_high();
  static const int kHighFieldNumber = 5;
  ::google::protobuf::uint32 high() const;
  void set_high(::google::protobuf::uint32 value);

  // required .dba.dbaLhs.typeid_dbalhs typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  ::dba::dbaLhs_typeid_dbalhs typeid_() const;
  void set_typeid_(::dba::dbaLhs_typeid_dbalhs value);

  // optional .dba.endianness endian = 6;
  bool has_endian() const;
  void clear_endian();
  static const int kEndianFieldNumber = 6;
  ::dba::endianness endian() const;
  void set_endian(::dba::endianness value);

  // @@protoc_insertion_point(class_scope:dba.dbaLhs)
 private:
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_name();
  void clear_has_name();
  void set_has_size();
  void clear_has_size();
  void set_has_low();
  void clear_has_low();
  void set_has_high();
  void clear_has_high();
  void set_has_endian();
  void clear_has_endian();
  void set_has_expr();
  void clear_has_expr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::dba::dbaexpr* expr_;
  ::google::protobuf::uint32 size_;
  ::google::protobuf::uint32 low_;
  ::google::protobuf::uint32 high_;
  int typeid__;
  int endian_;
  friend struct  protobuf_dba_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class dbainstr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dba.dbainstr) */ {
 public:
  dbainstr();
  virtual ~dbainstr();

  dbainstr(const dbainstr& from);

  inline dbainstr& operator=(const dbainstr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dbainstr& default_instance();

  static inline const dbainstr* internal_default_instance() {
    return reinterpret_cast<const dbainstr*>(
               &_dbainstr_default_instance_);
  }

  void Swap(dbainstr* other);

  // implements Message ----------------------------------------------

  inline dbainstr* New() const PROTOBUF_FINAL { return New(NULL); }

  dbainstr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const dbainstr& from);
  void MergeFrom(const dbainstr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(dbainstr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef dbainstr_typeid_instrkind typeid_instrkind;
  static const typeid_instrkind DbaIkAssign =
    dbainstr_typeid_instrkind_DbaIkAssign;
  static const typeid_instrkind DbaIkSJump =
    dbainstr_typeid_instrkind_DbaIkSJump;
  static const typeid_instrkind DbaIkDJump =
    dbainstr_typeid_instrkind_DbaIkDJump;
  static const typeid_instrkind DbaIkIf =
    dbainstr_typeid_instrkind_DbaIkIf;
  static const typeid_instrkind DbaIkStop =
    dbainstr_typeid_instrkind_DbaIkStop;
  static const typeid_instrkind DbaIkAssert =
    dbainstr_typeid_instrkind_DbaIkAssert;
  static const typeid_instrkind DbaIkAssume =
    dbainstr_typeid_instrkind_DbaIkAssume;
  static const typeid_instrkind DbaIkNondetAssume =
    dbainstr_typeid_instrkind_DbaIkNondetAssume;
  static const typeid_instrkind DbaIkNondet =
    dbainstr_typeid_instrkind_DbaIkNondet;
  static const typeid_instrkind DbaIkUndef =
    dbainstr_typeid_instrkind_DbaIkUndef;
  static const typeid_instrkind DbaIkMalloc =
    dbainstr_typeid_instrkind_DbaIkMalloc;
  static const typeid_instrkind DbaIkFree =
    dbainstr_typeid_instrkind_DbaIkFree;
  static const typeid_instrkind DbaIkPrint =
    dbainstr_typeid_instrkind_DbaIkPrint;
  static inline bool typeid_instrkind_IsValid(int value) {
    return dbainstr_typeid_instrkind_IsValid(value);
  }
  static const typeid_instrkind typeid_instrkind_MIN =
    dbainstr_typeid_instrkind_typeid_instrkind_MIN;
  static const typeid_instrkind typeid_instrkind_MAX =
    dbainstr_typeid_instrkind_typeid_instrkind_MAX;
  static const int typeid_instrkind_ARRAYSIZE =
    dbainstr_typeid_instrkind_typeid_instrkind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  typeid_instrkind_descriptor() {
    return dbainstr_typeid_instrkind_descriptor();
  }
  static inline const ::std::string& typeid_instrkind_Name(typeid_instrkind value) {
    return dbainstr_typeid_instrkind_Name(value);
  }
  static inline bool typeid_instrkind_Parse(const ::std::string& name,
      typeid_instrkind* value) {
    return dbainstr_typeid_instrkind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .dba.dbaexpr exprs = 10;
  int exprs_size() const;
  void clear_exprs();
  static const int kExprsFieldNumber = 10;
  const ::dba::dbaexpr& exprs(int index) const;
  ::dba::dbaexpr* mutable_exprs(int index);
  ::dba::dbaexpr* add_exprs();
  ::google::protobuf::RepeatedPtrField< ::dba::dbaexpr >*
      mutable_exprs();
  const ::google::protobuf::RepeatedPtrField< ::dba::dbaexpr >&
      exprs() const;

  // required .dba.dbacodeaddress location = 2;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  const ::dba::dbacodeaddress& location() const;
  ::dba::dbacodeaddress* mutable_location();
  ::dba::dbacodeaddress* release_location();
  void set_allocated_location(::dba::dbacodeaddress* location);

  // optional .dba.dbaLhs lhs = 3;
  bool has_lhs() const;
  void clear_lhs();
  static const int kLhsFieldNumber = 3;
  const ::dba::dbaLhs& lhs() const;
  ::dba::dbaLhs* mutable_lhs();
  ::dba::dbaLhs* release_lhs();
  void set_allocated_lhs(::dba::dbaLhs* lhs);

  // optional .dba.dbaexpr expr = 4;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 4;
  const ::dba::dbaexpr& expr() const;
  ::dba::dbaexpr* mutable_expr();
  ::dba::dbaexpr* release_expr();
  void set_allocated_expr(::dba::dbaexpr* expr);

  // optional .dba.codeaddress address = 6;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 6;
  const ::dba::codeaddress& address() const;
  ::dba::codeaddress* mutable_address();
  ::dba::codeaddress* release_address();
  void set_allocated_address(::dba::codeaddress* address);

  // optional .dba.dbatag tags = 7;
  bool has_tags() const;
  void clear_tags();
  static const int kTagsFieldNumber = 7;
  const ::dba::dbatag& tags() const;
  ::dba::dbatag* mutable_tags();
  ::dba::dbatag* release_tags();
  void set_allocated_tags(::dba::dbatag* tags);

  // optional .dba.dbacond cond = 8;
  bool has_cond() const;
  void clear_cond();
  static const int kCondFieldNumber = 8;
  const ::dba::dbacond& cond() const;
  ::dba::dbacond* mutable_cond();
  ::dba::dbacond* release_cond();
  void set_allocated_cond(::dba::dbacond* cond);

  // optional .dba.dbastopstate stopinfos = 9;
  bool has_stopinfos() const;
  void clear_stopinfos();
  static const int kStopinfosFieldNumber = 9;
  const ::dba::dbastopstate& stopinfos() const;
  ::dba::dbastopstate* mutable_stopinfos();
  ::dba::dbastopstate* release_stopinfos();
  void set_allocated_stopinfos(::dba::dbastopstate* stopinfos);

  // optional uint32 offset = 5;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 5;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // required .dba.dbainstr.typeid_instrkind typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  ::dba::dbainstr_typeid_instrkind typeid_() const;
  void set_typeid_(::dba::dbainstr_typeid_instrkind value);

  // @@protoc_insertion_point(class_scope:dba.dbainstr)
 private:
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_location();
  void clear_has_location();
  void set_has_lhs();
  void clear_has_lhs();
  void set_has_expr();
  void clear_has_expr();
  void set_has_offset();
  void clear_has_offset();
  void set_has_address();
  void clear_has_address();
  void set_has_tags();
  void clear_has_tags();
  void set_has_cond();
  void clear_has_cond();
  void set_has_stopinfos();
  void clear_has_stopinfos();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::dba::dbaexpr > exprs_;
  ::dba::dbacodeaddress* location_;
  ::dba::dbaLhs* lhs_;
  ::dba::dbaexpr* expr_;
  ::dba::codeaddress* address_;
  ::dba::dbatag* tags_;
  ::dba::dbacond* cond_;
  ::dba::dbastopstate* stopinfos_;
  ::google::protobuf::uint32 offset_;
  int typeid__;
  friend struct  protobuf_dba_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class dba_list : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dba.dba_list) */ {
 public:
  dba_list();
  virtual ~dba_list();

  dba_list(const dba_list& from);

  inline dba_list& operator=(const dba_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dba_list& default_instance();

  static inline const dba_list* internal_default_instance() {
    return reinterpret_cast<const dba_list*>(
               &_dba_list_default_instance_);
  }

  void Swap(dba_list* other);

  // implements Message ----------------------------------------------

  inline dba_list* New() const PROTOBUF_FINAL { return New(NULL); }

  dba_list* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const dba_list& from);
  void MergeFrom(const dba_list& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(dba_list* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dba.dbainstr instrs = 1;
  int instrs_size() const;
  void clear_instrs();
  static const int kInstrsFieldNumber = 1;
  const ::dba::dbainstr& instrs(int index) const;
  ::dba::dbainstr* mutable_instrs(int index);
  ::dba::dbainstr* add_instrs();
  ::google::protobuf::RepeatedPtrField< ::dba::dbainstr >*
      mutable_instrs();
  const ::google::protobuf::RepeatedPtrField< ::dba::dbainstr >&
      instrs() const;

  // @@protoc_insertion_point(class_scope:dba.dba_list)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::dba::dbainstr > instrs_;
  friend struct  protobuf_dba_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// bitvector

// required uint64 bv = 1;
inline bool bitvector::has_bv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void bitvector::set_has_bv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void bitvector::clear_has_bv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void bitvector::clear_bv() {
  bv_ = GOOGLE_ULONGLONG(0);
  clear_has_bv();
}
inline ::google::protobuf::uint64 bitvector::bv() const {
  // @@protoc_insertion_point(field_get:dba.bitvector.bv)
  return bv_;
}
inline void bitvector::set_bv(::google::protobuf::uint64 value) {
  set_has_bv();
  bv_ = value;
  // @@protoc_insertion_point(field_set:dba.bitvector.bv)
}

// required uint32 size = 2;
inline bool bitvector::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void bitvector::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void bitvector::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void bitvector::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 bitvector::size() const {
  // @@protoc_insertion_point(field_get:dba.bitvector.size)
  return size_;
}
inline void bitvector::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:dba.bitvector.size)
}

// -------------------------------------------------------------------

// dbacodeaddress

// required .dba.bitvector bitvector = 1;
inline bool dbacodeaddress::has_bitvector() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dbacodeaddress::set_has_bitvector() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dbacodeaddress::clear_has_bitvector() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dbacodeaddress::clear_bitvector() {
  if (bitvector_ != NULL) bitvector_->::dba::bitvector::Clear();
  clear_has_bitvector();
}
inline const ::dba::bitvector& dbacodeaddress::bitvector() const {
  // @@protoc_insertion_point(field_get:dba.dbacodeaddress.bitvector)
  return bitvector_ != NULL ? *bitvector_
                         : *::dba::bitvector::internal_default_instance();
}
inline ::dba::bitvector* dbacodeaddress::mutable_bitvector() {
  set_has_bitvector();
  if (bitvector_ == NULL) {
    bitvector_ = new ::dba::bitvector;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbacodeaddress.bitvector)
  return bitvector_;
}
inline ::dba::bitvector* dbacodeaddress::release_bitvector() {
  // @@protoc_insertion_point(field_release:dba.dbacodeaddress.bitvector)
  clear_has_bitvector();
  ::dba::bitvector* temp = bitvector_;
  bitvector_ = NULL;
  return temp;
}
inline void dbacodeaddress::set_allocated_bitvector(::dba::bitvector* bitvector) {
  delete bitvector_;
  bitvector_ = bitvector;
  if (bitvector) {
    set_has_bitvector();
  } else {
    clear_has_bitvector();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbacodeaddress.bitvector)
}

// required uint32 dbaoffset = 2;
inline bool dbacodeaddress::has_dbaoffset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dbacodeaddress::set_has_dbaoffset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dbacodeaddress::clear_has_dbaoffset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dbacodeaddress::clear_dbaoffset() {
  dbaoffset_ = 0u;
  clear_has_dbaoffset();
}
inline ::google::protobuf::uint32 dbacodeaddress::dbaoffset() const {
  // @@protoc_insertion_point(field_get:dba.dbacodeaddress.dbaoffset)
  return dbaoffset_;
}
inline void dbacodeaddress::set_dbaoffset(::google::protobuf::uint32 value) {
  set_has_dbaoffset();
  dbaoffset_ = value;
  // @@protoc_insertion_point(field_set:dba.dbacodeaddress.dbaoffset)
}

// -------------------------------------------------------------------

// codeaddress

// required .dba.codeaddress.typeid_codeaddress typeid = 1;
inline bool codeaddress::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void codeaddress::set_has_typeid_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void codeaddress::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void codeaddress::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::dba::codeaddress_typeid_codeaddress codeaddress::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.codeaddress.typeid)
  return static_cast< ::dba::codeaddress_typeid_codeaddress >(typeid__);
}
inline void codeaddress::set_typeid_(::dba::codeaddress_typeid_codeaddress value) {
  assert(::dba::codeaddress_typeid_codeaddress_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.codeaddress.typeid)
}

// optional uint32 offset = 2;
inline bool codeaddress::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void codeaddress::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void codeaddress::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void codeaddress::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 codeaddress::offset() const {
  // @@protoc_insertion_point(field_get:dba.codeaddress.offset)
  return offset_;
}
inline void codeaddress::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:dba.codeaddress.offset)
}

// optional .dba.dbacodeaddress address = 3;
inline bool codeaddress::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void codeaddress::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void codeaddress::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void codeaddress::clear_address() {
  if (address_ != NULL) address_->::dba::dbacodeaddress::Clear();
  clear_has_address();
}
inline const ::dba::dbacodeaddress& codeaddress::address() const {
  // @@protoc_insertion_point(field_get:dba.codeaddress.address)
  return address_ != NULL ? *address_
                         : *::dba::dbacodeaddress::internal_default_instance();
}
inline ::dba::dbacodeaddress* codeaddress::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    address_ = new ::dba::dbacodeaddress;
  }
  // @@protoc_insertion_point(field_mutable:dba.codeaddress.address)
  return address_;
}
inline ::dba::dbacodeaddress* codeaddress::release_address() {
  // @@protoc_insertion_point(field_release:dba.codeaddress.address)
  clear_has_address();
  ::dba::dbacodeaddress* temp = address_;
  address_ = NULL;
  return temp;
}
inline void codeaddress::set_allocated_address(::dba::dbacodeaddress* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.codeaddress.address)
}

// -------------------------------------------------------------------

// dbatag

// required .dba.dbatag.typeid_dbatag typeid = 1;
inline bool dbatag::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dbatag::set_has_typeid_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dbatag::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dbatag::clear_typeid_() {
  typeid__ = 1;
  clear_has_typeid_();
}
inline ::dba::dbatag_typeid_dbatag dbatag::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbatag.typeid)
  return static_cast< ::dba::dbatag_typeid_dbatag >(typeid__);
}
inline void dbatag::set_typeid_(::dba::dbatag_typeid_dbatag value) {
  assert(::dba::dbatag_typeid_dbatag_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbatag.typeid)
}

// optional .dba.dbacodeaddress address = 2;
inline bool dbatag::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dbatag::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dbatag::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dbatag::clear_address() {
  if (address_ != NULL) address_->::dba::dbacodeaddress::Clear();
  clear_has_address();
}
inline const ::dba::dbacodeaddress& dbatag::address() const {
  // @@protoc_insertion_point(field_get:dba.dbatag.address)
  return address_ != NULL ? *address_
                         : *::dba::dbacodeaddress::internal_default_instance();
}
inline ::dba::dbacodeaddress* dbatag::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    address_ = new ::dba::dbacodeaddress;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbatag.address)
  return address_;
}
inline ::dba::dbacodeaddress* dbatag::release_address() {
  // @@protoc_insertion_point(field_release:dba.dbatag.address)
  clear_has_address();
  ::dba::dbacodeaddress* temp = address_;
  address_ = NULL;
  return temp;
}
inline void dbatag::set_allocated_address(::dba::dbacodeaddress* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbatag.address)
}

// -------------------------------------------------------------------

// dbastopstate

// required .dba.dbastopstate.typeid_dbastate typeid = 1;
inline bool dbastopstate::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dbastopstate::set_has_typeid_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dbastopstate::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dbastopstate::clear_typeid_() {
  typeid__ = 1;
  clear_has_typeid_();
}
inline ::dba::dbastopstate_typeid_dbastate dbastopstate::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbastopstate.typeid)
  return static_cast< ::dba::dbastopstate_typeid_dbastate >(typeid__);
}
inline void dbastopstate::set_typeid_(::dba::dbastopstate_typeid_dbastate value) {
  assert(::dba::dbastopstate_typeid_dbastate_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbastopstate.typeid)
}

// optional string infos = 2;
inline bool dbastopstate::has_infos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dbastopstate::set_has_infos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dbastopstate::clear_has_infos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dbastopstate::clear_infos() {
  infos_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_infos();
}
inline const ::std::string& dbastopstate::infos() const {
  // @@protoc_insertion_point(field_get:dba.dbastopstate.infos)
  return infos_.GetNoArena();
}
inline void dbastopstate::set_infos(const ::std::string& value) {
  set_has_infos();
  infos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dba.dbastopstate.infos)
}
#if LANG_CXX11
inline void dbastopstate::set_infos(::std::string&& value) {
  set_has_infos();
  infos_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dba.dbastopstate.infos)
}
#endif
inline void dbastopstate::set_infos(const char* value) {
  set_has_infos();
  infos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dba.dbastopstate.infos)
}
inline void dbastopstate::set_infos(const char* value, size_t size) {
  set_has_infos();
  infos_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dba.dbastopstate.infos)
}
inline ::std::string* dbastopstate::mutable_infos() {
  set_has_infos();
  // @@protoc_insertion_point(field_mutable:dba.dbastopstate.infos)
  return infos_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dbastopstate::release_infos() {
  // @@protoc_insertion_point(field_release:dba.dbastopstate.infos)
  clear_has_infos();
  return infos_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dbastopstate::set_allocated_infos(::std::string* infos) {
  if (infos != NULL) {
    set_has_infos();
  } else {
    clear_has_infos();
  }
  infos_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), infos);
  // @@protoc_insertion_point(field_set_allocated:dba.dbastopstate.infos)
}

// -------------------------------------------------------------------

// dbaexpr

// required .dba.dbaexpr.typeid_dbaexpr typeid = 1;
inline bool dbaexpr::has_typeid_() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void dbaexpr::set_has_typeid_() {
  _has_bits_[0] |= 0x00000100u;
}
inline void dbaexpr::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void dbaexpr::clear_typeid_() {
  typeid__ = 1;
  clear_has_typeid_();
}
inline ::dba::dbaexpr_typeid_dbaexpr dbaexpr::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.typeid)
  return static_cast< ::dba::dbaexpr_typeid_dbaexpr >(typeid__);
}
inline void dbaexpr::set_typeid_(::dba::dbaexpr_typeid_dbaexpr value) {
  assert(::dba::dbaexpr_typeid_dbaexpr_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.typeid)
}

// optional string name = 2;
inline bool dbaexpr::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dbaexpr::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dbaexpr::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dbaexpr::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& dbaexpr::name() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.name)
  return name_.GetNoArena();
}
inline void dbaexpr::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dba.dbaexpr.name)
}
#if LANG_CXX11
inline void dbaexpr::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dba.dbaexpr.name)
}
#endif
inline void dbaexpr::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dba.dbaexpr.name)
}
inline void dbaexpr::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dba.dbaexpr.name)
}
inline ::std::string* dbaexpr::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:dba.dbaexpr.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dbaexpr::release_name() {
  // @@protoc_insertion_point(field_release:dba.dbaexpr.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dbaexpr::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dba.dbaexpr.name)
}

// optional uint32 size = 3;
inline bool dbaexpr::has_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dbaexpr::set_has_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dbaexpr::clear_has_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dbaexpr::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 dbaexpr::size() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.size)
  return size_;
}
inline void dbaexpr::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.size)
}

// optional .dba.endianness endian = 4;
inline bool dbaexpr::has_endian() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void dbaexpr::set_has_endian() {
  _has_bits_[0] |= 0x00000200u;
}
inline void dbaexpr::clear_has_endian() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void dbaexpr::clear_endian() {
  endian_ = 1;
  clear_has_endian();
}
inline ::dba::endianness dbaexpr::endian() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.endian)
  return static_cast< ::dba::endianness >(endian_);
}
inline void dbaexpr::set_endian(::dba::endianness value) {
  assert(::dba::endianness_IsValid(value));
  set_has_endian();
  endian_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.endian)
}

// optional .dba.bitvector bitvector = 5;
inline bool dbaexpr::has_bitvector() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dbaexpr::set_has_bitvector() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dbaexpr::clear_has_bitvector() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dbaexpr::clear_bitvector() {
  if (bitvector_ != NULL) bitvector_->::dba::bitvector::Clear();
  clear_has_bitvector();
}
inline const ::dba::bitvector& dbaexpr::bitvector() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.bitvector)
  return bitvector_ != NULL ? *bitvector_
                         : *::dba::bitvector::internal_default_instance();
}
inline ::dba::bitvector* dbaexpr::mutable_bitvector() {
  set_has_bitvector();
  if (bitvector_ == NULL) {
    bitvector_ = new ::dba::bitvector;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbaexpr.bitvector)
  return bitvector_;
}
inline ::dba::bitvector* dbaexpr::release_bitvector() {
  // @@protoc_insertion_point(field_release:dba.dbaexpr.bitvector)
  clear_has_bitvector();
  ::dba::bitvector* temp = bitvector_;
  bitvector_ = NULL;
  return temp;
}
inline void dbaexpr::set_allocated_bitvector(::dba::bitvector* bitvector) {
  delete bitvector_;
  bitvector_ = bitvector;
  if (bitvector) {
    set_has_bitvector();
  } else {
    clear_has_bitvector();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbaexpr.bitvector)
}

// optional .dba.dbaexpr expr1 = 6;
inline bool dbaexpr::has_expr1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dbaexpr::set_has_expr1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dbaexpr::clear_has_expr1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dbaexpr::clear_expr1() {
  if (expr1_ != NULL) expr1_->::dba::dbaexpr::Clear();
  clear_has_expr1();
}
inline const ::dba::dbaexpr& dbaexpr::expr1() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.expr1)
  return expr1_ != NULL ? *expr1_
                         : *::dba::dbaexpr::internal_default_instance();
}
inline ::dba::dbaexpr* dbaexpr::mutable_expr1() {
  set_has_expr1();
  if (expr1_ == NULL) {
    expr1_ = new ::dba::dbaexpr;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbaexpr.expr1)
  return expr1_;
}
inline ::dba::dbaexpr* dbaexpr::release_expr1() {
  // @@protoc_insertion_point(field_release:dba.dbaexpr.expr1)
  clear_has_expr1();
  ::dba::dbaexpr* temp = expr1_;
  expr1_ = NULL;
  return temp;
}
inline void dbaexpr::set_allocated_expr1(::dba::dbaexpr* expr1) {
  delete expr1_;
  expr1_ = expr1;
  if (expr1) {
    set_has_expr1();
  } else {
    clear_has_expr1();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbaexpr.expr1)
}

// optional .dba.dbaexpr expr2 = 7;
inline bool dbaexpr::has_expr2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dbaexpr::set_has_expr2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dbaexpr::clear_has_expr2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dbaexpr::clear_expr2() {
  if (expr2_ != NULL) expr2_->::dba::dbaexpr::Clear();
  clear_has_expr2();
}
inline const ::dba::dbaexpr& dbaexpr::expr2() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.expr2)
  return expr2_ != NULL ? *expr2_
                         : *::dba::dbaexpr::internal_default_instance();
}
inline ::dba::dbaexpr* dbaexpr::mutable_expr2() {
  set_has_expr2();
  if (expr2_ == NULL) {
    expr2_ = new ::dba::dbaexpr;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbaexpr.expr2)
  return expr2_;
}
inline ::dba::dbaexpr* dbaexpr::release_expr2() {
  // @@protoc_insertion_point(field_release:dba.dbaexpr.expr2)
  clear_has_expr2();
  ::dba::dbaexpr* temp = expr2_;
  expr2_ = NULL;
  return temp;
}
inline void dbaexpr::set_allocated_expr2(::dba::dbaexpr* expr2) {
  delete expr2_;
  expr2_ = expr2;
  if (expr2) {
    set_has_expr2();
  } else {
    clear_has_expr2();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbaexpr.expr2)
}

// optional .dba.dbaexpr.dbaunary unaryop = 9;
inline bool dbaexpr::has_unaryop() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void dbaexpr::set_has_unaryop() {
  _has_bits_[0] |= 0x00000400u;
}
inline void dbaexpr::clear_has_unaryop() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void dbaexpr::clear_unaryop() {
  unaryop_ = 1;
  clear_has_unaryop();
}
inline ::dba::dbaexpr_dbaunary dbaexpr::unaryop() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.unaryop)
  return static_cast< ::dba::dbaexpr_dbaunary >(unaryop_);
}
inline void dbaexpr::set_unaryop(::dba::dbaexpr_dbaunary value) {
  assert(::dba::dbaexpr_dbaunary_IsValid(value));
  set_has_unaryop();
  unaryop_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.unaryop)
}

// optional .dba.dbaexpr.dbabinary binaryop = 10;
inline bool dbaexpr::has_binaryop() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void dbaexpr::set_has_binaryop() {
  _has_bits_[0] |= 0x00000800u;
}
inline void dbaexpr::clear_has_binaryop() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void dbaexpr::clear_binaryop() {
  binaryop_ = 1;
  clear_has_binaryop();
}
inline ::dba::dbaexpr_dbabinary dbaexpr::binaryop() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.binaryop)
  return static_cast< ::dba::dbaexpr_dbabinary >(binaryop_);
}
inline void dbaexpr::set_binaryop(::dba::dbaexpr_dbabinary value) {
  assert(::dba::dbaexpr_dbabinary_IsValid(value));
  set_has_binaryop();
  binaryop_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.binaryop)
}

// optional uint32 low = 11;
inline bool dbaexpr::has_low() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dbaexpr::set_has_low() {
  _has_bits_[0] |= 0x00000040u;
}
inline void dbaexpr::clear_has_low() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void dbaexpr::clear_low() {
  low_ = 0u;
  clear_has_low();
}
inline ::google::protobuf::uint32 dbaexpr::low() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.low)
  return low_;
}
inline void dbaexpr::set_low(::google::protobuf::uint32 value) {
  set_has_low();
  low_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.low)
}

// optional uint32 high = 12;
inline bool dbaexpr::has_high() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void dbaexpr::set_has_high() {
  _has_bits_[0] |= 0x00000080u;
}
inline void dbaexpr::clear_has_high() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void dbaexpr::clear_high() {
  high_ = 0u;
  clear_has_high();
}
inline ::google::protobuf::uint32 dbaexpr::high() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.high)
  return high_;
}
inline void dbaexpr::set_high(::google::protobuf::uint32 value) {
  set_has_high();
  high_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.high)
}

// optional .dba.dbacond cond = 13;
inline bool dbaexpr::has_cond() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dbaexpr::set_has_cond() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dbaexpr::clear_has_cond() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dbaexpr::clear_cond() {
  if (cond_ != NULL) cond_->::dba::dbacond::Clear();
  clear_has_cond();
}
inline const ::dba::dbacond& dbaexpr::cond() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.cond)
  return cond_ != NULL ? *cond_
                         : *::dba::dbacond::internal_default_instance();
}
inline ::dba::dbacond* dbaexpr::mutable_cond() {
  set_has_cond();
  if (cond_ == NULL) {
    cond_ = new ::dba::dbacond;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbaexpr.cond)
  return cond_;
}
inline ::dba::dbacond* dbaexpr::release_cond() {
  // @@protoc_insertion_point(field_release:dba.dbaexpr.cond)
  clear_has_cond();
  ::dba::dbacond* temp = cond_;
  cond_ = NULL;
  return temp;
}
inline void dbaexpr::set_allocated_cond(::dba::dbacond* cond) {
  delete cond_;
  cond_ = cond;
  if (cond) {
    set_has_cond();
  } else {
    clear_has_cond();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbaexpr.cond)
}

// -------------------------------------------------------------------

// dbacond

// required .dba.dbacond.typeid_dbacond typeid = 1;
inline bool dbacond::has_typeid_() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dbacond::set_has_typeid_() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dbacond::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dbacond::clear_typeid_() {
  typeid__ = 1;
  clear_has_typeid_();
}
inline ::dba::dbacond_typeid_dbacond dbacond::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbacond.typeid)
  return static_cast< ::dba::dbacond_typeid_dbacond >(typeid__);
}
inline void dbacond::set_typeid_(::dba::dbacond_typeid_dbacond value) {
  assert(::dba::dbacond_typeid_dbacond_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbacond.typeid)
}

// optional .dba.dbaexpr expr = 2;
inline bool dbacond::has_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dbacond::set_has_expr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dbacond::clear_has_expr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dbacond::clear_expr() {
  if (expr_ != NULL) expr_->::dba::dbaexpr::Clear();
  clear_has_expr();
}
inline const ::dba::dbaexpr& dbacond::expr() const {
  // @@protoc_insertion_point(field_get:dba.dbacond.expr)
  return expr_ != NULL ? *expr_
                         : *::dba::dbaexpr::internal_default_instance();
}
inline ::dba::dbaexpr* dbacond::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) {
    expr_ = new ::dba::dbaexpr;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbacond.expr)
  return expr_;
}
inline ::dba::dbaexpr* dbacond::release_expr() {
  // @@protoc_insertion_point(field_release:dba.dbacond.expr)
  clear_has_expr();
  ::dba::dbaexpr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void dbacond::set_allocated_expr(::dba::dbaexpr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbacond.expr)
}

// optional .dba.dbacond cond1 = 3;
inline bool dbacond::has_cond1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dbacond::set_has_cond1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dbacond::clear_has_cond1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dbacond::clear_cond1() {
  if (cond1_ != NULL) cond1_->::dba::dbacond::Clear();
  clear_has_cond1();
}
inline const ::dba::dbacond& dbacond::cond1() const {
  // @@protoc_insertion_point(field_get:dba.dbacond.cond1)
  return cond1_ != NULL ? *cond1_
                         : *::dba::dbacond::internal_default_instance();
}
inline ::dba::dbacond* dbacond::mutable_cond1() {
  set_has_cond1();
  if (cond1_ == NULL) {
    cond1_ = new ::dba::dbacond;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbacond.cond1)
  return cond1_;
}
inline ::dba::dbacond* dbacond::release_cond1() {
  // @@protoc_insertion_point(field_release:dba.dbacond.cond1)
  clear_has_cond1();
  ::dba::dbacond* temp = cond1_;
  cond1_ = NULL;
  return temp;
}
inline void dbacond::set_allocated_cond1(::dba::dbacond* cond1) {
  delete cond1_;
  cond1_ = cond1;
  if (cond1) {
    set_has_cond1();
  } else {
    clear_has_cond1();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbacond.cond1)
}

// optional .dba.dbacond cond2 = 4;
inline bool dbacond::has_cond2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dbacond::set_has_cond2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dbacond::clear_has_cond2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dbacond::clear_cond2() {
  if (cond2_ != NULL) cond2_->::dba::dbacond::Clear();
  clear_has_cond2();
}
inline const ::dba::dbacond& dbacond::cond2() const {
  // @@protoc_insertion_point(field_get:dba.dbacond.cond2)
  return cond2_ != NULL ? *cond2_
                         : *::dba::dbacond::internal_default_instance();
}
inline ::dba::dbacond* dbacond::mutable_cond2() {
  set_has_cond2();
  if (cond2_ == NULL) {
    cond2_ = new ::dba::dbacond;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbacond.cond2)
  return cond2_;
}
inline ::dba::dbacond* dbacond::release_cond2() {
  // @@protoc_insertion_point(field_release:dba.dbacond.cond2)
  clear_has_cond2();
  ::dba::dbacond* temp = cond2_;
  cond2_ = NULL;
  return temp;
}
inline void dbacond::set_allocated_cond2(::dba::dbacond* cond2) {
  delete cond2_;
  cond2_ = cond2;
  if (cond2) {
    set_has_cond2();
  } else {
    clear_has_cond2();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbacond.cond2)
}

// -------------------------------------------------------------------

// dbaLhs

// required .dba.dbaLhs.typeid_dbalhs typeid = 1;
inline bool dbaLhs::has_typeid_() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dbaLhs::set_has_typeid_() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dbaLhs::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dbaLhs::clear_typeid_() {
  typeid__ = 1;
  clear_has_typeid_();
}
inline ::dba::dbaLhs_typeid_dbalhs dbaLhs::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.typeid)
  return static_cast< ::dba::dbaLhs_typeid_dbalhs >(typeid__);
}
inline void dbaLhs::set_typeid_(::dba::dbaLhs_typeid_dbalhs value) {
  assert(::dba::dbaLhs_typeid_dbalhs_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbaLhs.typeid)
}

// optional string name = 2;
inline bool dbaLhs::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dbaLhs::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dbaLhs::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dbaLhs::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& dbaLhs::name() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.name)
  return name_.GetNoArena();
}
inline void dbaLhs::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dba.dbaLhs.name)
}
#if LANG_CXX11
inline void dbaLhs::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dba.dbaLhs.name)
}
#endif
inline void dbaLhs::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dba.dbaLhs.name)
}
inline void dbaLhs::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dba.dbaLhs.name)
}
inline ::std::string* dbaLhs::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:dba.dbaLhs.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dbaLhs::release_name() {
  // @@protoc_insertion_point(field_release:dba.dbaLhs.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dbaLhs::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dba.dbaLhs.name)
}

// optional uint32 size = 3;
inline bool dbaLhs::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dbaLhs::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dbaLhs::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dbaLhs::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 dbaLhs::size() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.size)
  return size_;
}
inline void dbaLhs::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaLhs.size)
}

// optional uint32 low = 4;
inline bool dbaLhs::has_low() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dbaLhs::set_has_low() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dbaLhs::clear_has_low() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dbaLhs::clear_low() {
  low_ = 0u;
  clear_has_low();
}
inline ::google::protobuf::uint32 dbaLhs::low() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.low)
  return low_;
}
inline void dbaLhs::set_low(::google::protobuf::uint32 value) {
  set_has_low();
  low_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaLhs.low)
}

// optional uint32 high = 5;
inline bool dbaLhs::has_high() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dbaLhs::set_has_high() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dbaLhs::clear_has_high() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dbaLhs::clear_high() {
  high_ = 0u;
  clear_has_high();
}
inline ::google::protobuf::uint32 dbaLhs::high() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.high)
  return high_;
}
inline void dbaLhs::set_high(::google::protobuf::uint32 value) {
  set_has_high();
  high_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaLhs.high)
}

// optional .dba.endianness endian = 6;
inline bool dbaLhs::has_endian() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dbaLhs::set_has_endian() {
  _has_bits_[0] |= 0x00000040u;
}
inline void dbaLhs::clear_has_endian() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void dbaLhs::clear_endian() {
  endian_ = 1;
  clear_has_endian();
}
inline ::dba::endianness dbaLhs::endian() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.endian)
  return static_cast< ::dba::endianness >(endian_);
}
inline void dbaLhs::set_endian(::dba::endianness value) {
  assert(::dba::endianness_IsValid(value));
  set_has_endian();
  endian_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaLhs.endian)
}

// optional .dba.dbaexpr expr = 7;
inline bool dbaLhs::has_expr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dbaLhs::set_has_expr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dbaLhs::clear_has_expr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dbaLhs::clear_expr() {
  if (expr_ != NULL) expr_->::dba::dbaexpr::Clear();
  clear_has_expr();
}
inline const ::dba::dbaexpr& dbaLhs::expr() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.expr)
  return expr_ != NULL ? *expr_
                         : *::dba::dbaexpr::internal_default_instance();
}
inline ::dba::dbaexpr* dbaLhs::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) {
    expr_ = new ::dba::dbaexpr;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbaLhs.expr)
  return expr_;
}
inline ::dba::dbaexpr* dbaLhs::release_expr() {
  // @@protoc_insertion_point(field_release:dba.dbaLhs.expr)
  clear_has_expr();
  ::dba::dbaexpr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void dbaLhs::set_allocated_expr(::dba::dbaexpr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbaLhs.expr)
}

// -------------------------------------------------------------------

// dbainstr

// required .dba.dbainstr.typeid_instrkind typeid = 1;
inline bool dbainstr::has_typeid_() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void dbainstr::set_has_typeid_() {
  _has_bits_[0] |= 0x00000100u;
}
inline void dbainstr::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void dbainstr::clear_typeid_() {
  typeid__ = 1;
  clear_has_typeid_();
}
inline ::dba::dbainstr_typeid_instrkind dbainstr::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.typeid)
  return static_cast< ::dba::dbainstr_typeid_instrkind >(typeid__);
}
inline void dbainstr::set_typeid_(::dba::dbainstr_typeid_instrkind value) {
  assert(::dba::dbainstr_typeid_instrkind_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbainstr.typeid)
}

// required .dba.dbacodeaddress location = 2;
inline bool dbainstr::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dbainstr::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dbainstr::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dbainstr::clear_location() {
  if (location_ != NULL) location_->::dba::dbacodeaddress::Clear();
  clear_has_location();
}
inline const ::dba::dbacodeaddress& dbainstr::location() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.location)
  return location_ != NULL ? *location_
                         : *::dba::dbacodeaddress::internal_default_instance();
}
inline ::dba::dbacodeaddress* dbainstr::mutable_location() {
  set_has_location();
  if (location_ == NULL) {
    location_ = new ::dba::dbacodeaddress;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.location)
  return location_;
}
inline ::dba::dbacodeaddress* dbainstr::release_location() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.location)
  clear_has_location();
  ::dba::dbacodeaddress* temp = location_;
  location_ = NULL;
  return temp;
}
inline void dbainstr::set_allocated_location(::dba::dbacodeaddress* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.location)
}

// optional .dba.dbaLhs lhs = 3;
inline bool dbainstr::has_lhs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dbainstr::set_has_lhs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dbainstr::clear_has_lhs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dbainstr::clear_lhs() {
  if (lhs_ != NULL) lhs_->::dba::dbaLhs::Clear();
  clear_has_lhs();
}
inline const ::dba::dbaLhs& dbainstr::lhs() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.lhs)
  return lhs_ != NULL ? *lhs_
                         : *::dba::dbaLhs::internal_default_instance();
}
inline ::dba::dbaLhs* dbainstr::mutable_lhs() {
  set_has_lhs();
  if (lhs_ == NULL) {
    lhs_ = new ::dba::dbaLhs;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.lhs)
  return lhs_;
}
inline ::dba::dbaLhs* dbainstr::release_lhs() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.lhs)
  clear_has_lhs();
  ::dba::dbaLhs* temp = lhs_;
  lhs_ = NULL;
  return temp;
}
inline void dbainstr::set_allocated_lhs(::dba::dbaLhs* lhs) {
  delete lhs_;
  lhs_ = lhs;
  if (lhs) {
    set_has_lhs();
  } else {
    clear_has_lhs();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.lhs)
}

// optional .dba.dbaexpr expr = 4;
inline bool dbainstr::has_expr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dbainstr::set_has_expr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dbainstr::clear_has_expr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dbainstr::clear_expr() {
  if (expr_ != NULL) expr_->::dba::dbaexpr::Clear();
  clear_has_expr();
}
inline const ::dba::dbaexpr& dbainstr::expr() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.expr)
  return expr_ != NULL ? *expr_
                         : *::dba::dbaexpr::internal_default_instance();
}
inline ::dba::dbaexpr* dbainstr::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) {
    expr_ = new ::dba::dbaexpr;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.expr)
  return expr_;
}
inline ::dba::dbaexpr* dbainstr::release_expr() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.expr)
  clear_has_expr();
  ::dba::dbaexpr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void dbainstr::set_allocated_expr(::dba::dbaexpr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.expr)
}

// optional uint32 offset = 5;
inline bool dbainstr::has_offset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void dbainstr::set_has_offset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void dbainstr::clear_has_offset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void dbainstr::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 dbainstr::offset() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.offset)
  return offset_;
}
inline void dbainstr::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:dba.dbainstr.offset)
}

// optional .dba.codeaddress address = 6;
inline bool dbainstr::has_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dbainstr::set_has_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dbainstr::clear_has_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dbainstr::clear_address() {
  if (address_ != NULL) address_->::dba::codeaddress::Clear();
  clear_has_address();
}
inline const ::dba::codeaddress& dbainstr::address() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.address)
  return address_ != NULL ? *address_
                         : *::dba::codeaddress::internal_default_instance();
}
inline ::dba::codeaddress* dbainstr::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    address_ = new ::dba::codeaddress;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.address)
  return address_;
}
inline ::dba::codeaddress* dbainstr::release_address() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.address)
  clear_has_address();
  ::dba::codeaddress* temp = address_;
  address_ = NULL;
  return temp;
}
inline void dbainstr::set_allocated_address(::dba::codeaddress* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.address)
}

// optional .dba.dbatag tags = 7;
inline bool dbainstr::has_tags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dbainstr::set_has_tags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dbainstr::clear_has_tags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dbainstr::clear_tags() {
  if (tags_ != NULL) tags_->::dba::dbatag::Clear();
  clear_has_tags();
}
inline const ::dba::dbatag& dbainstr::tags() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.tags)
  return tags_ != NULL ? *tags_
                         : *::dba::dbatag::internal_default_instance();
}
inline ::dba::dbatag* dbainstr::mutable_tags() {
  set_has_tags();
  if (tags_ == NULL) {
    tags_ = new ::dba::dbatag;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.tags)
  return tags_;
}
inline ::dba::dbatag* dbainstr::release_tags() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.tags)
  clear_has_tags();
  ::dba::dbatag* temp = tags_;
  tags_ = NULL;
  return temp;
}
inline void dbainstr::set_allocated_tags(::dba::dbatag* tags) {
  delete tags_;
  tags_ = tags;
  if (tags) {
    set_has_tags();
  } else {
    clear_has_tags();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.tags)
}

// optional .dba.dbacond cond = 8;
inline bool dbainstr::has_cond() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dbainstr::set_has_cond() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dbainstr::clear_has_cond() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dbainstr::clear_cond() {
  if (cond_ != NULL) cond_->::dba::dbacond::Clear();
  clear_has_cond();
}
inline const ::dba::dbacond& dbainstr::cond() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.cond)
  return cond_ != NULL ? *cond_
                         : *::dba::dbacond::internal_default_instance();
}
inline ::dba::dbacond* dbainstr::mutable_cond() {
  set_has_cond();
  if (cond_ == NULL) {
    cond_ = new ::dba::dbacond;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.cond)
  return cond_;
}
inline ::dba::dbacond* dbainstr::release_cond() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.cond)
  clear_has_cond();
  ::dba::dbacond* temp = cond_;
  cond_ = NULL;
  return temp;
}
inline void dbainstr::set_allocated_cond(::dba::dbacond* cond) {
  delete cond_;
  cond_ = cond;
  if (cond) {
    set_has_cond();
  } else {
    clear_has_cond();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.cond)
}

// optional .dba.dbastopstate stopinfos = 9;
inline bool dbainstr::has_stopinfos() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dbainstr::set_has_stopinfos() {
  _has_bits_[0] |= 0x00000040u;
}
inline void dbainstr::clear_has_stopinfos() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void dbainstr::clear_stopinfos() {
  if (stopinfos_ != NULL) stopinfos_->::dba::dbastopstate::Clear();
  clear_has_stopinfos();
}
inline const ::dba::dbastopstate& dbainstr::stopinfos() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.stopinfos)
  return stopinfos_ != NULL ? *stopinfos_
                         : *::dba::dbastopstate::internal_default_instance();
}
inline ::dba::dbastopstate* dbainstr::mutable_stopinfos() {
  set_has_stopinfos();
  if (stopinfos_ == NULL) {
    stopinfos_ = new ::dba::dbastopstate;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.stopinfos)
  return stopinfos_;
}
inline ::dba::dbastopstate* dbainstr::release_stopinfos() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.stopinfos)
  clear_has_stopinfos();
  ::dba::dbastopstate* temp = stopinfos_;
  stopinfos_ = NULL;
  return temp;
}
inline void dbainstr::set_allocated_stopinfos(::dba::dbastopstate* stopinfos) {
  delete stopinfos_;
  stopinfos_ = stopinfos;
  if (stopinfos) {
    set_has_stopinfos();
  } else {
    clear_has_stopinfos();
  }
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.stopinfos)
}

// repeated .dba.dbaexpr exprs = 10;
inline int dbainstr::exprs_size() const {
  return exprs_.size();
}
inline void dbainstr::clear_exprs() {
  exprs_.Clear();
}
inline const ::dba::dbaexpr& dbainstr::exprs(int index) const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.exprs)
  return exprs_.Get(index);
}
inline ::dba::dbaexpr* dbainstr::mutable_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.exprs)
  return exprs_.Mutable(index);
}
inline ::dba::dbaexpr* dbainstr::add_exprs() {
  // @@protoc_insertion_point(field_add:dba.dbainstr.exprs)
  return exprs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dba::dbaexpr >*
dbainstr::mutable_exprs() {
  // @@protoc_insertion_point(field_mutable_list:dba.dbainstr.exprs)
  return &exprs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dba::dbaexpr >&
dbainstr::exprs() const {
  // @@protoc_insertion_point(field_list:dba.dbainstr.exprs)
  return exprs_;
}

// -------------------------------------------------------------------

// dba_list

// repeated .dba.dbainstr instrs = 1;
inline int dba_list::instrs_size() const {
  return instrs_.size();
}
inline void dba_list::clear_instrs() {
  instrs_.Clear();
}
inline const ::dba::dbainstr& dba_list::instrs(int index) const {
  // @@protoc_insertion_point(field_get:dba.dba_list.instrs)
  return instrs_.Get(index);
}
inline ::dba::dbainstr* dba_list::mutable_instrs(int index) {
  // @@protoc_insertion_point(field_mutable:dba.dba_list.instrs)
  return instrs_.Mutable(index);
}
inline ::dba::dbainstr* dba_list::add_instrs() {
  // @@protoc_insertion_point(field_add:dba.dba_list.instrs)
  return instrs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dba::dbainstr >*
dba_list::mutable_instrs() {
  // @@protoc_insertion_point(field_mutable_list:dba.dba_list.instrs)
  return &instrs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dba::dbainstr >&
dba_list::instrs() const {
  // @@protoc_insertion_point(field_list:dba.dba_list.instrs)
  return instrs_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace dba

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::dba::codeaddress_typeid_codeaddress> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::codeaddress_typeid_codeaddress>() {
  return ::dba::codeaddress_typeid_codeaddress_descriptor();
}
template <> struct is_proto_enum< ::dba::dbatag_typeid_dbatag> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::dbatag_typeid_dbatag>() {
  return ::dba::dbatag_typeid_dbatag_descriptor();
}
template <> struct is_proto_enum< ::dba::dbastopstate_typeid_dbastate> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::dbastopstate_typeid_dbastate>() {
  return ::dba::dbastopstate_typeid_dbastate_descriptor();
}
template <> struct is_proto_enum< ::dba::dbaexpr_typeid_dbaexpr> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::dbaexpr_typeid_dbaexpr>() {
  return ::dba::dbaexpr_typeid_dbaexpr_descriptor();
}
template <> struct is_proto_enum< ::dba::dbaexpr_dbaunary> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::dbaexpr_dbaunary>() {
  return ::dba::dbaexpr_dbaunary_descriptor();
}
template <> struct is_proto_enum< ::dba::dbaexpr_dbabinary> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::dbaexpr_dbabinary>() {
  return ::dba::dbaexpr_dbabinary_descriptor();
}
template <> struct is_proto_enum< ::dba::dbacond_typeid_dbacond> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::dbacond_typeid_dbacond>() {
  return ::dba::dbacond_typeid_dbacond_descriptor();
}
template <> struct is_proto_enum< ::dba::dbaLhs_typeid_dbalhs> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::dbaLhs_typeid_dbalhs>() {
  return ::dba::dbaLhs_typeid_dbalhs_descriptor();
}
template <> struct is_proto_enum< ::dba::dbainstr_typeid_instrkind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::dbainstr_typeid_instrkind>() {
  return ::dba::dbainstr_typeid_instrkind_descriptor();
}
template <> struct is_proto_enum< ::dba::endianness> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::endianness>() {
  return ::dba::endianness_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_dba_2eproto__INCLUDED
